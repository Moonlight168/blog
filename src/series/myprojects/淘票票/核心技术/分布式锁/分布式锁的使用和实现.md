# 淘票票分布式锁实战：基于Redisson与AOP的高并发防护体系

在淘票票高并发场景中，日均千万级订单支付和百万级电影票秒杀容易出现"重复支付""库存超卖"等问题。分布式锁是解决跨服务并发冲突的核心技术。我们最终采用**Redisson+AOP**方案：Redisson保障分布式锁的可靠性，AOP实现业务与锁逻辑解耦，开发者只需一行注解即可为核心接口添加并发防护。本文将详细解析该方案的设计思路、实现细节与最佳实践。


## 一、为什么淘票票需要分布式锁？

分布式系统中，多个服务实例共享同一资源（如订单、库存）时，本地锁（`synchronized`、`ReentrantLock`）只能控制单实例内的并发，[跨实例](/blogs/基本概念/跨实例.md)的并发冲突成为“重灾区”。3类典型问题：

- **重复支付**：用户快速点击两次支付按钮，两个服务实例同时发起扣款，导致用户被重复收费；
- **库存超卖**：热门场次电影票库存仅剩1张，两个用户同时下单，均查询到“有库存”并扣减，最终超卖；
- **状态混乱**：同一笔订单的“支付回调”和“手动取消”同时执行，订单状态被交替修改，出现既“已支付”又“已取消”的矛盾状态。

这些问题源于**多个进程/线程在无协调的情况下并发操作同一资源**。分布式锁的核心作用是让所有服务实例"共享同一把锁"，确保同一时间只有一个实例能操作关键资源。


## 二、为什么选择Redisson？原生Redis的痛点与Redisson的解决方案

最初我们尝试用原生Redis命令（如`SET key value NX EX`）实现分布式锁，但很快发现一系列难以解决的问题。而Redisson作为Redis的Java客户端，完美封装了这些细节，成为我们的最终选择。

### 2.1 原生Redis实现分布式锁的3大痛点

1. **不可重入导致死锁**  
   若方法A调用方法B，两者都需要获取同一把锁，原生Redis锁会导致“方法A已加锁，方法B再加锁时失败”的死锁（同一线程无法重复获取锁）。

2. **锁过期时间难平衡**  
   必须手动设置锁的过期时间：设短了，业务没执行完锁就释放，导致并发冲突；设长了，若服务宕机，锁长期不释放，引发死锁。

3. **释放锁可能误删他人锁**  
   线程1的锁过期后未释放，线程2成功加锁，此时线程1执行完释放锁，会误删线程2的锁，导致新的并发冲突。


### 2.2 Redisson如何解决这些痛点？

Redisson基于Redis的`Hash`结构和Lua脚本，从底层设计上解决了上述问题，核心特性如下：

| 痛点                | Redisson解决方案                                                                 |
|---------------------|---------------------------------------------------------------------------------|
| 不可重入            | 用`Hash`存储“线程标识+重入次数”，同一线程加锁时重入次数+1，释放时-1，为0则删除锁 |
| 过期时间难设置      | 内置“看门狗”机制：锁过期前自动续约（默认30秒过期，每10秒续约一次），业务未执行完不会释放 |
| 释放锁误删          | 释放前检查“当前线程是否持有锁”，仅允许持有者释放，避免误删他人锁                 |
| 原子性保障          | 所有锁操作（加锁、释放、续约）通过[Lua脚本](blogs/基本概念/Lua脚本.md)实现，确保Redis操作原子性               |
| 丰富锁类型          | 支持可重入锁、公平锁、读写锁、[红锁](blogs/基本概念/红锁.md)等10+种锁，适配不同业务场景                   |


## 三、Redisson分布式锁底层原理：以可重入锁为例

Redisson的分布式锁实现中，**[可重入锁（RedissonReentrantLock）](/blogs/分布式锁/可重入锁.md)** 是最常用的类型，其底层依赖Redis的`Hash`结构和Lua脚本，核心逻辑如下：


### 3.1 数据结构：用Hash存储锁信息

Redisson在Redis中用`Hash`结构存储锁的元数据：
- `key`：锁的唯一标识（如`taopiaopiao:pay:ORDER123456`）；
- `field`：加锁线程的唯一标识（格式：`线程ID:UUID`，避免不同服务实例的线程ID冲突）；
- `value`：该线程的重入次数（同一线程多次加锁时递增）。

示例：
```redis
# 锁key为"taopiaopiao:pay:ORDER123456"的Hash结构
HGETALL taopiaopiao:pay:ORDER123456
1) "16384:5f4dcc3b-6bb2-4453-91bf-9e2e4dcc8e5d"  # 线程标识（线程ID:UUID）
2) "2"                                           # 重入次数（该线程第2次获取锁）
```


### 3.2 加锁逻辑：3种场景的原子性处理

Redisson的加锁操作通过[Lua脚本](blogs/基本概念/Lua脚本.md)实现（确保原子性），核心逻辑分3种场景：

1. **锁不存在**：直接创建`Hash`结构，设置`field=当前线程标识`、`value=1`，并设置锁过期时间（默认30秒）；
2. **锁存在且属于当前线程**：重入次数+1，重置锁过期时间（触发看门狗续约）；
3. **锁存在且属于其他线程**：返回加锁失败，等待或直接退出。

**核心加锁Lua脚本（简化版）**：
```lua
local lockKey = KEYS[1]          -- 锁key
local threadId = ARGV[1]         -- 当前线程标识（field）
local expireTime = ARGV[2]       -- 过期时间（毫秒）

-- 场景1：锁不存在，创建锁
if redis.call('exists', lockKey) == 0 then
    redis.call('hset', lockKey, threadId, 1)  -- 设置Hash
    redis.call('pexpire', lockKey, expireTime) -- 设置过期时间
    return 1  -- 加锁成功
end

-- 场景2：锁存在且属于当前线程，重入次数+1
if redis.call('hexists', lockKey, threadId) == 1 then
    redis.call('hincrby', lockKey, threadId, 1) -- 重入次数+1
    redis.call('pexpire', lockKey, expireTime)  -- 重置过期时间
    return 1  -- 加锁成功
end

-- 场景3：锁被其他线程持有，加锁失败
return 0
```


### 3.3 看门狗机制：自动续约防止锁提前释放

为解决“业务执行时间 > 锁过期时间”导致的锁提前释放问题，Redisson内置“看门狗”（Watch Dog）机制：

- **触发条件**：当线程成功获取锁且未指定`leaseTime`（锁过期时间）时，自动启动看门狗；
- **续约逻辑**：看门狗是一个后台线程，每隔`leaseTime/3`（默认10秒）检查一次，若线程仍持有锁，则将锁的过期时间重置为30秒；
- **停止时机**：当线程释放锁或异常终止时，看门狗自动停止，锁到期后自动删除。

**效果**：只要业务没执行完，锁就会一直“续期”，避免提前释放；业务执行完或服务宕机，锁最终会自动释放，不会死锁。


### 3.4 释放锁逻辑：安全释放与重入次数递减

释放锁同样通过Lua脚本实现，确保操作原子性，核心逻辑：

1. **检查锁归属**：若锁不存在或不属于当前线程，直接返回（避免误删他人锁）；
2. **重入次数递减**：若重入次数 > 1，递减后重置过期时间（仍持有锁）；
3. **删除锁**：若重入次数 = 1，直接删除锁`key`（完全释放）。

**核心释放锁Lua脚本（简化版）**：
```lua
local lockKey = KEYS[1]
local threadId = ARGV[1]

-- 锁不存在或不属于当前线程，释放失败
if redis.call('exists', lockKey) == 0 or redis.call('hexists', lockKey, threadId) == 0 then
    return 0
end

-- 重入次数-1
local count = redis.call('hincrby', lockKey, threadId, -1)

-- 重入次数=0，删除锁
if count == 0 then
    redis.call('del', lockKey)
    return 1
end

-- 重入次数>0，重置过期时间
redis.call('pexpire', lockKey, 30000)
return 1
```


## 四、淘票票的分布式锁实践：Redisson+AOP的无侵入式集成

为让开发者专注业务逻辑，我们基于Redisson封装了“注解+AOP”的分布式锁框架，实现“一行注解加锁”的便捷体验。


### 4.1 核心设计：3层架构实现解耦

整个方案分为3层，从下到上依次为：
- **底层引擎**：Redisson提供分布式锁的基础实现（可重入锁、公平锁等）；
- **切面层**：AOP拦截标注自定义注解的方法，自动执行“获取锁→执行方法→释放锁”逻辑；
- **业务层**：开发者只需在方法上标注注解，无需关心锁的实现细节。

架构图：
```mermaid
graph TD
    A[开发者：在方法上标注@ServiceLock] --> B[AOP切面拦截方法]
    B --> C[生成锁key（基于业务参数）]
    B --> D[通过Redisson获取对应类型的锁]
    D --> E[获取锁成功：执行目标方法]
    D --> F[获取锁失败：执行超时策略]
    E --> G[方法执行完毕：释放锁]
```


### 4.2 实现步骤：从注解定义到业务使用

#### 步骤1：定义@ServiceLock注解（标记需要加锁的方法）

注解参数包含锁类型、业务名称、锁key表达式等，用于传递锁的配置：
```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ServiceLock {
    // 锁类型：可重入锁（默认）、公平锁、读锁、写锁
    LockType lockType() default LockType.REENTRANT;
    
    // 业务名称（如"PAY"、"SECKILL"）
    String name();
    
    // 锁key的动态参数（支持SpEL表达式，如#payDto.orderNo）
    String[] keys() default {};
    
    // 获取锁的最大等待时间（默认5秒）
    long waitTime() default 5;
    
    // 时间单位（默认秒）
    TimeUnit timeUnit() default TimeUnit.SECONDS;
    
    // 加锁超时策略（默认抛异常）
    LockTimeoutStrategy timeoutStrategy() default LockTimeoutStrategy.THROW_EXCEPTION;
}

// 锁类型枚举
enum LockType { REENTRANT, FAIR, READ, WRITE }

// 超时策略枚举
enum LockTimeoutStrategy { THROW_EXCEPTION, RETURN_NULL, RETURN_DEFAULT }
```


#### 步骤2：实现AOP切面（核心拦截逻辑）

切面类`ServiceLockAspect`通过`@Around`通知拦截标注`@ServiceLock`的方法，自动处理锁的生命周期：
```java
@Aspect
@Component
@Slf4j
public class ServiceLockAspect {
    @Autowired
    private RedissonClient redissonClient;
    @Autowired
    private SpelExpressionParser spelParser; // 解析SpEL表达式

    // 切点：拦截所有标注@ServiceLock的方法
    @Pointcut("@annotation(serviceLock)")
    public void lockPointcut(ServiceLock serviceLock) {}

    // 环绕通知：实现锁的获取、执行、释放全流程
    @Around("lockPointcut(serviceLock)")
    public Object around(ProceedingJoinPoint joinPoint, ServiceLock serviceLock) throws Throwable {
        // 1. 生成唯一锁key（格式：项目前缀+业务名+动态参数）
        String lockKey = generateLockKey(joinPoint, serviceLock);
        log.info("生成分布式锁key：{}", lockKey);

        // 2. 根据锁类型获取Redisson锁实例
        RLock lock = getRedissonLock(lockKey, serviceLock.lockType());

        // 3. 尝试获取锁
        boolean isLocked = lock.tryLock(
            serviceLock.waitTime(), 
            serviceLock.timeUnit()
        );

        if (!isLocked) {
            // 3.1 加锁失败：执行超时策略（如抛异常）
            return handleLockTimeout(serviceLock.timeoutStrategy());
        }

        try {
            // 3.2 加锁成功：执行目标业务方法
            return joinPoint.proceed();
        } finally {
            // 4. 释放锁（仅当前线程持有锁时才释放）
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
                log.info("释放分布式锁key：{}", lockKey);
            }
        }
    }

    // 生成锁key：解析SpEL表达式，拼接动态参数
    private String generateLockKey(ProceedingJoinPoint joinPoint, ServiceLock serviceLock) {
        // 解析方法参数（如#payDto.orderNo → 实际订单号）
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        EvaluationContext context = new StandardEvaluationContext();
        String[] paramNames = signature.getParameterNames();
        Object[] args = joinPoint.getArgs();
        for (int i = 0; i < paramNames.length; i++) {
            context.setVariable(paramNames[i], args[i]);
        }

        // 拼接锁key：项目前缀+业务名+动态参数
        StringBuilder keyBuilder = new StringBuilder("taopiaopiao:")
            .append(serviceLock.name()).append(":");
        for (String key : serviceLock.keys()) {
            Object value = spelParser.parseExpression(key).getValue(context);
            keyBuilder.append(value).append(":");
        }
        return keyBuilder.toString();
    }

    // 根据锁类型获取Redisson锁实例
    private RLock getRedissonLock(String lockKey, LockType lockType) {
        return switch (lockType) {
            case REENTRANT -> redissonClient.getLock(lockKey);
            case FAIR -> redissonClient.getFairLock(lockKey);
            case READ -> redissonClient.getReadWriteLock(lockKey).readLock();
            case WRITE -> redissonClient.getReadWriteLock(lockKey).writeLock();
        };
    }

    // 处理加锁超时
    private Object handleLockTimeout(LockTimeoutStrategy strategy) {
        switch (strategy) {
            case THROW_EXCEPTION:
                throw new BusinessException("操作太频繁，请稍后再试");
            case RETURN_NULL:
                return null;
            case RETURN_DEFAULT:
                return ApiResponse.error("操作繁忙");
            default:
                throw new BusinessException("加锁超时");
        }
    }
}
```


#### 步骤3：业务层使用示例（3个核心场景）

开发者只需在方法上标注`@ServiceLock`，即可自动触发分布式锁逻辑，无需手动处理锁的获取与释放。

##### 场景1：支付接口防重复提交（可重入锁）

支付接口需要确保同一订单号的支付请求不会并发执行，使用可重入锁（支持嵌套加锁）：
```java
@Service
public class PayService {
    /**
     * 支付接口：同一订单号只能同时有一个请求执行
     */
    @ServiceLock(
        name = "PAY",  // 业务名称：支付
        keys = {"#payDto.orderNo"},  // 锁key：订单号（确保唯一）
        lockType = LockType.REENTRANT,  // 可重入锁（支持嵌套）
        waitTime = 3  // 最多等待3秒
    )
    public ApiResponse<String> pay(PayDto payDto) {
        // 1. 检查订单状态（可能嵌套调用加锁方法）
        checkOrderStatus(payDto.getOrderNo());
        
        // 2. 调用支付渠道（如支付宝、微信支付）
        PayResult result = paymentChannelClient.pay(payDto);
        
        // 3. 更新订单状态为“已支付”
        orderMapper.updateStatus(payDto.getOrderNo(), OrderStatus.PAID);
        
        return ApiResponse.ok(result.getTradeNo());
    }

    // 嵌套加锁方法（同一订单号的锁，支持重入）
    private void checkOrderStatus(String orderNo) {
        // 业务逻辑：检查订单是否已支付、是否有效
    }
}
```


##### 场景2：电影票秒杀防超卖（公平锁）

秒杀场景需要按用户请求顺序处理，避免“后点击的用户先抢到票”的不公平情况，使用[公平锁](blogs/基本概念/公平锁.md)：
```java
@Service
public class SeckillService {
    /**
     * 秒杀接口：按请求顺序获取锁，避免超卖
     */
    @ServiceLock(
        name = "SECKILL",  // 业务名称：秒杀
        keys = {"#seckillDto.movieId", "#seckillDto.sessionId"},  // 锁key：电影ID+场次ID
        lockType = LockType.FAIR,  // 公平锁（按顺序获取）
        waitTime = 5  // 等待5秒
    )
    public ApiResponse<SeckillResult> seckill(SeckillDto seckillDto) {
        // 1. 检查库存（加锁后查询，确保库存准确）
        int stock = stockMapper.getStock(seckillDto.getMovieId(), seckillDto.getSessionId());
        if (stock <= 0) {
            return ApiResponse.error("票已售罄");
        }
        
        // 2. 扣减库存
        stockMapper.decreaseStock(seckillDto.getMovieId(), seckillDto.getSessionId());
        
        // 3. 创建订单
        String orderNo = orderGenerator.generate();
        orderMapper.insert(new Order(orderNo, seckillDto.getUserId(), seckillDto.getMovieId()));
        
        return ApiResponse.ok(new SeckillResult(orderNo, "秒杀成功"));
    }
}
```


##### 场景3：库存查询与扣减（读写锁）

库存场景“读多写少”：查询库存时允许多线程并发，扣减库存时需独占锁，使用读写锁：
```java
@Service
public class StockService {
    /**
     * 库存查询：读锁，支持并发查询
     */
    @ServiceLock(
        name = "STOCK",
        keys = {"#movieId", "#sessionId"},
        lockType = LockType.READ  // 读锁（共享）
    )
    public ApiResponse<Integer> getStock(Long movieId, Long sessionId) {
        return ApiResponse.ok(stockMapper.getStock(movieId, sessionId));
    }

    /**
     * 库存扣减：写锁，独占锁
     */
    @ServiceLock(
        name = "STOCK",
        keys = {"#movieId", "#sessionId"},
        lockType = LockType.WRITE  // 写锁（排他）
    )
    public ApiResponse<Boolean> decreaseStock(Long movieId, Long sessionId) {
        int rows = stockMapper.decreaseStock(movieId, sessionId);
        return ApiResponse.ok(rows > 0);
    }
}
```


### 4.3 Redisson配置：集群环境的高可用保障

淘票票的Redis采用集群部署（3主3从），Redisson配置需适配集群环境，确保锁的高可用：
```yaml
# application.yml
spring:
  redis:
    cluster:
      nodes: 192.168.0.101:6379,192.168.0.102:6379,192.168.0.103:6379  # 主节点
      max-redirects: 3  # 集群最大重定向次数
    password: tp_redis@2024  # 密码
    database: 0  # 数据库索引

# Redisson额外配置
redisson:
  clusterServersConfig:
    scanInterval: 2000  # 集群节点扫描间隔（毫秒）
    slaveConnectionMinimumIdleSize: 3  # 从节点最小空闲连接数
    masterConnectionMinimumIdleSize: 5  # 主节点最小空闲连接数
  lockWatchdogTimeout: 30000  # 看门狗默认超时时间（30秒）
  threads: 16  # 业务线程池大小
  nettyThreads: 32  # Netty线程池大小（处理Redis通信）
```


## 五、淘票票分布式锁实战：最佳实践与避坑指南

在淘票票高并发系统中，基于Redisson封装的分布式锁框架是保障业务稳定性的核心组件。该框架覆盖了支付、下单、秒杀等关键场景，日均支撑千万级请求的并发防护。结合框架的模块化设计（如分布式锁模块、防重复执行模块），我们总结了一套经过生产验证的最佳实践与避坑指南，确保分布式锁在高效可用的同时，避免常见的并发风险。


### 一、锁设计最佳实践：从“能用”到“好用”

#### 1.1 锁Key设计：唯一、可读、可追溯
锁Key是分布式锁的“身份标识”，不合理的Key设计会导致锁冲突或难以排查问题。淘票票的锁Key设计遵循 **“项目前缀+业务模块+唯一标识”** 规范，确保全局唯一性与可读性。

##### 规范格式
```
taopiaopiao:{业务模块}:{唯一标识1}:{唯一标识2}
```
- **项目前缀**：`taopiaopiao` 固定前缀，避免与其他系统的锁Key冲突；
- **业务模块**：如 `pay`（支付）、`order`（订单）、`seckill`（秒杀），明确锁所属业务；
- **唯一标识**：通常是业务主键（如订单号、用户ID、商品ID），确保同一资源的锁唯一。

##### 实战示例
| 业务场景                | 锁Key示例                                  | 说明                                  |
|-------------------------|-------------------------------------------|---------------------------------------|
| 支付防重复提交          | `taopiaopiao:pay:ORDER123456`              | 唯一标识：订单号（同一订单只能有一把锁） |
| 秒杀防超卖              | `taopiaopiao:seckill:MOVIE1001:SESSION2024`| 唯一标识：电影ID+场次ID（精准锁定资源） |
| 用户订单创建限制        | `taopiaopiao:order:USER5678:DAY20240520`   | 唯一标识：用户ID+日期（限制用户单日下单次数） |

##### 禁忌
- ❌ 避免模糊Key：如 `taopiaopiao:pay:lock`（无唯一标识，导致所有支付请求抢同一把锁，并发能力骤降）；
- ❌ 避免过长Key：Key长度控制在64字符内，减少Redis存储与网络传输开销。


#### 1.2 锁类型选择：按场景匹配最优方案
淘票票的Redisson框架支持4种核心锁类型（可重入锁、公平锁、读锁、写锁），不同场景需选择适配的锁类型，避免“一刀切”使用可重入锁导致性能问题。

##### 锁类型适配场景
| 锁类型       | 核心特性                                  | 适用场景                                  | 淘票票实战案例                          |
|--------------|-------------------------------------------|-------------------------------------------|-----------------------------------------|
| **可重入锁** | 同一线程可多次获取同一把锁，支持嵌套加锁  | 业务存在嵌套加锁（如方法A调用方法B，两者都需加锁） | 支付流程（`pay()` 调用 `checkOrderStatus()`，均需锁定订单号） |
| **公平锁**   | 按请求顺序获取锁，避免“饥饿问题”          | 对锁获取顺序敏感，需保证用户体验公平性    | 热门电影票秒杀（按用户点击顺序分配锁，避免后点击用户先抢到票） |
| **读锁**     | 共享锁，多线程可同时获取，不阻塞读请求    | 读多写少场景（如库存查询、订单状态查询）  | 电影票库存查询（支持多线程并发查询，不影响性能） |
| **写锁**     | 排他锁，仅单线程可获取，阻塞读/写请求     | 写操作场景（如库存扣减、订单状态更新）    | 秒杀库存扣减（仅允许单线程扣减，避免超卖） |

##### 禁忌
- ❌ 读多写少场景用写锁：如库存查询用写锁，导致所有查询请求排队，性能下降10倍以上；
- ❌ 无顺序要求场景用公平锁：公平锁需维护等待队列，性能比可重入锁低30%左右，非必要不使用。


#### 1.3 超时参数配置：平衡“安全性”与“并发能力”
分布式锁的超时参数（`waitTime` 等待时间、`leaseTime` 过期时间）直接影响业务稳定性与并发能力。淘票票通过大量压测，总结出参数配置的“黄金法则”。

##### 核心参数说明
- **`waitTime`（等待时间）**：线程尝试获取锁的最大等待时间，超时则触发失败策略（如抛异常、返回默认值）；
- **`leaseTime`（过期时间）**：锁的默认过期时间，若未指定则依赖Redisson“看门狗”自动续约。

##### 配置规范
1. **`waitTime` 配置**：  
   设为 **业务平均执行时间的1~2倍**，避免等待过久影响用户体验，同时减少频繁超时重试。
   - 示例：支付业务平均执行时间3秒，`waitTime` 设为5秒；秒杀业务平均执行时间1秒，`waitTime` 设为2秒。

2. **`leaseTime` 配置**：
   - 核心业务（如支付、扣款）：**不指定`leaseTime`**，依赖看门狗自动续约（默认30秒过期，每10秒续约一次），确保业务未执行完锁不释放；
   - 非核心业务（如日志上报、数据统计）：**指定`leaseTime`为5~10秒**，避免业务异常导致锁长期占用（如日志上报超时，10秒后锁自动释放，不影响后续请求）。

##### 实战示例
```java
// 支付业务（核心业务，不指定leaseTime，依赖看门狗）
@ServiceLock(
    name = "pay",
    keys = {"#payDto.orderNo"},
    waitTime = 5, // 等待5秒
    lockType = LockType.REENTRANT
)
public void pay(PayDto payDto) { ... }

// 日志上报（非核心业务，指定leaseTime=10秒）
@ServiceLock(
    name = "log",
    keys = {"#logDto.id"},
    waitTime = 2,
    leaseTime = 10, // 10秒后自动释放锁
    lockType = LockType.REENTRANT
)
public void reportLog(LogDto logDto) { ... }
```


#### 1.4 两种使用方式：声明式与编程式结合
淘票票的Redisson框架支持 **声明式（注解）** 与 **编程式（工具类）** 两种使用方式，开发者可按业务复杂度灵活选择，兼顾易用性与灵活性。

##### 1. 声明式（注解）：简单场景首选
通过 `@ServiceLock` 注解实现无侵入式加锁，适用于逻辑简单的业务方法（如支付、订单创建），一行注解即可完成锁配置。

```java
@Service
public class PayService {
    // 声明式加锁：支付防重复提交
    @ServiceLock(
        name = "pay",
        keys = {"#payDto.orderNo"},
        waitTime = 5,
        lockTimeoutStrategy = LockTimeoutStrategy.THROW_EXCEPTION // 超时抛异常
    )
    public ApiResponse<String> pay(PayDto payDto) {
        // 业务逻辑：检查订单→调用支付渠道→更新订单状态
        return ApiResponse.ok("支付成功");
    }
}
```

##### 2. 编程式（工具类）：复杂场景适配
通过 `ServiceLockTool` 工具类手动控制锁的生命周期，适用于锁逻辑复杂的场景（如条件加锁、多锁组合）。

```java
@Service
public class OrderService {
    @Autowired
    private ServiceLockTool serviceLockTool;

    public ApiResponse<String> createOrder(OrderDto orderDto) {
        // 编程式加锁：仅当订单类型为“秒杀单”时加锁
        if (orderDto.getType() == OrderType.SECKILL) {
            String lockKey = "taopiaopiao:order:SECKILL:" + orderDto.getOrderNo();
            // 调用工具类加锁，指定锁类型与超时策略
            return serviceLockTool.executeWithLock(
                lockKey,
                LockType.FAIR, // 秒杀用公平锁，保证顺序
                3, // 等待3秒
                () -> {
                    // 加锁成功后的业务逻辑
                    return createSeckillOrder(orderDto);
                },
                () -> ApiResponse.error("创建秒杀订单繁忙，请稍后再试") // 超时回调
            );
        } else {
            // 普通订单无需加锁，直接执行
            return createNormalOrder(orderDto);
        }
    }
}
```


### 二、避坑指南：规避生产环境常见风险

#### 2.1 锁内逻辑：必须“短平快”，禁止耗时操作
分布式锁的持有时间直接影响并发能力——锁持有时间越长，同一时间能处理的请求越少。淘票票严格要求 **锁内仅执行“快速本地逻辑”**，禁止包含远程调用、大事务、复杂查询等耗时操作。

##### 错误示例（风险）
```java
@ServiceLock(name = "pay", keys = {"#payDto.orderNo"})
public void pay(PayDto payDto) {
    // 错误：锁内调用第三方支付接口（耗时不确定，可能1~10秒）
    PayResult result = thirdPartyPayClient.pay(payDto); // 风险点：远程调用耗时不可控
    if (result.isSuccess()) {
        orderMapper.updateStatus(payDto.getOrderNo(), OrderStatus.PAID);
    }
}
```
**问题**：若第三方接口超时（如10秒），锁会被“看门狗”持续续约，导致同一订单的后续支付请求长时间等待，并发能力骤降。

##### 正确示例（优化）
```java
@ServiceLock(name = "pay", keys = {"#payDto.orderNo"})
public void pay(PayDto payDto) {
    // 优化：先调用远程接口，拿到结果后再加锁处理本地逻辑
    PayResult result = thirdPartyPayClient.pay(payDto); 
    if (result.isSuccess()) {
        // 锁内仅执行本地数据库更新（快速操作，耗时<100ms）
        orderMapper.updateStatus(payDto.getOrderNo(), OrderStatus.PAID);
    }
}
```
**优化点**：将耗时的远程调用放在锁外，锁内仅处理“本地更新”，锁持有时间从“秒级”缩短到“毫秒级”，并发能力提升10倍以上。


#### 2.2 锁释放：必须在finally中执行，避免锁泄漏
锁泄漏是分布式锁的致命问题——若业务逻辑抛出异常，导致锁未释放，会使后续请求长期等待，甚至引发死锁。淘票票的规范要求 **无论业务是否异常，都必须在finally块中释放锁**，并通过 `isHeldByCurrentThread()` 校验锁归属，避免误释放他人的锁。

##### 正确释放逻辑（编程式场景）
```java
public void doBusiness(String lockKey) {
    RLock lock = redissonClient.getLock(lockKey);
    boolean isLocked = false;
    try {
        isLocked = lock.tryLock(3, TimeUnit.SECONDS);
        if (isLocked) {
            // 业务逻辑
        } else {
            throw new BusinessException("获取锁超时");
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new BusinessException("线程中断");
    } finally {
        // 关键：校验当前线程是否持有锁，避免误释放
        if (isLocked && lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```
##### 禁忌
- ❌ 不在finally中释放锁：如业务抛异常，锁未释放，导致锁泄漏；
- ❌ 直接释放锁不校验：如 `lock.unlock()` 前不判断 `isHeldByCurrentThread()`，可能释放其他线程的锁（如线程1超时未释放，线程2加锁后，线程1执行完误释放线程2的锁）。


#### 2.3 防重复执行：双层锁机制（本地锁+分布式锁）
淘票票的 `taopiaopiao-repeat-execute-limit-framework` 模块（防重复执行模块）采用 **“本地锁+分布式锁”双层锁机制**，既保证分布式环境下的幂等性，又减少Redis访问压力，避免“分布式锁成为瓶颈”。

##### 双层锁逻辑
1. **本地锁**：基于Guava Cache实现的内存锁，优先在服务实例内部拦截重复请求，减少Redis调用；
2. **分布式锁**：若本地锁未拦截（如请求落在不同实例），再通过Redisson分布式锁拦截，确保全局幂等。

##### 实战示例（接口防重复提交）
```java
@RestController
public class PaymentController {
    // 双层锁防重复执行：本地锁+分布式锁
    @RepeatExecuteLimit(
        name = "pay",
        keys = {"#request.orderNo"},
        localLockExpire = 500, // 本地锁过期时间500ms（短超时，避免内存泄漏）
        distributedLockWaitTime = 3 // 分布式锁等待3秒
    )
    @PostMapping("/pay")
    public ApiResponse pay(@RequestBody PayRequest request) {
        // 支付逻辑（无需手动加锁，注解自动处理双层锁）
        return paymentService.pay(request);
    }
}
```
**优势**：本地锁拦截90%以上的重复请求（如用户快速点击两次按钮，请求落在同一实例），仅10%的跨实例重复请求需要调用分布式锁，Redis压力降低90%。


#### 2.4 Redis集群：核心业务用红锁，避免单点故障
淘票票的Redis采用 **3主3从** 集群部署，普通业务用单节点锁即可满足需求，但核心业务（如支付、扣款）必须使用 **红锁（RedissonRedLock）**，避免单Redis节点宕机导致锁失效。

##### 红锁原理
红锁需同时在多个独立的Redis主节点（至少3个）加锁，仅当 **超过半数节点加锁成功**（如3个节点中2个加锁成功），才判定为整体加锁成功，确保单点故障不影响锁的有效性。

##### 淘票票红锁实战（支付扣款场景）
```java
@Service
public class PaymentService {
    @Autowired
    private RedissonClient redissonClient1; //  Redis主节点1
    @Autowired
    private RedissonClient redissonClient2; //  Redis主节点2
    @Autowired
    private RedissonClient redissonClient3; //  Redis主节点3

    public void deductBalance(String userId, BigDecimal amount) {
        // 1. 创建3个节点的锁实例
        RLock lock1 = redissonClient1.getLock("taopiaopiao:pay:balance:" + userId);
        RLock lock2 = redissonClient2.getLock("taopiaopiao:pay:balance:" + userId);
        RLock lock3 = redissonClient3.getLock("taopiaopiao:pay:balance:" + userId);

        // 2. 构建红锁
        RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);

        try {
            // 3. 红锁加锁：等待3秒，过期时间10秒
            boolean isLocked = redLock.tryLock(3, 10, TimeUnit.SECONDS);
            if (isLocked) {
                // 4. 扣减用户余额（核心业务，不允许锁失效）
                userMapper.deductBalance(userId, amount);
            } else {
                throw new BusinessException("扣减余额繁忙，请稍后再试");
            }
        } finally {
            // 5. 释放红锁
            if (redLock.isHeldByCurrentThread()) {
                redLock.unlock();
            }
        }
    }
}
```
**注意**：红锁会增加Redis调用次数（如3个节点需3次加锁请求），性能比单节点锁低30%左右，仅核心业务使用，避免过度设计。


### 三、监控与运维：确保锁机制稳定运行

#### 3.1 锁监控：关键指标实时告警
淘票票通过[Prometheus](blogs/基本概念/Prometheus.md)+[Grafana](blogs/基本概念/Grafana.md)搭建分布式锁监控体系，实时监控锁的关键指标，异常时触发告警（如钉钉、邮件），避免锁机制“暗箱操作”。

#### 核心监控指标
| 指标名称                | 含义                                  | 告警阈值                          |
|-------------------------|---------------------------------------|-----------------------------------|
| `redisson_lock_acquire_count` | 锁获取成功次数                        | 无（统计指标）                    |
| `redisson_lock_fail_count`    | 锁获取失败次数（超时/异常）          | 1分钟内失败次数>10次              |
| `redisson_lock_hold_time`     | 锁持有时间（毫秒）                   | 平均持有时间>500ms（需优化锁内逻辑） |
| `redisson_lock_wait_time`     | 锁等待时间（毫秒）                   | 平均等待时间>1000ms（需扩容或优化） |

##### 监控面板示例
- 按业务模块展示锁的成功/失败次数，快速定位异常业务；
- 展示锁持有时间TOP10的请求，识别锁内耗时操作；
- 展示Redis节点的锁操作QPS，避免Redis成为瓶颈。


#### 3.2 应急处理：锁异常的快速恢复
即使有完善的监控，仍可能出现锁异常（如Redis节点宕机、锁泄漏），淘票票制定了一套应急处理流程，确保快速恢复业务。

##### 常见异常处理方案
| 异常场景                | 应急方案                                  | 工具支持                          |
|-------------------------|-------------------------------------------|-----------------------------------|
| Redis节点宕机（红锁未生效） | 1. 临时切换到备用Redis集群；2. 核心业务降级为本地锁（短期应急） | Redis集群切换脚本、业务降级开关 |
| 锁泄漏（Redis中锁Key长期存在） | 1. 手动删除Redis中的异常锁Key；2. 重启服务实例释放本地锁 | Redis CLI（`DEL 锁Key`）、服务重启脚本 |
| 锁竞争激烈（等待时间过长） | 1. 拆分锁粒度（如将“商品锁”拆分为“商品+库存分区锁”）；2. 扩容服务实例分担压力 | 锁Key拆分工具、服务扩容脚本 |


## 六、总结：从“手动加锁”到“注解加锁”的效率提升

淘票票的分布式锁方案，通过Redisson解决了底层可靠性问题，通过AOP实现了业务与锁逻辑的解耦，最终达成：
- **开发效率**：开发者无需编写锁逻辑，一行注解即可完成并发防护，减少80%的重复代码；
- **可靠性**：Redisson的看门狗、重入性、安全释放机制，彻底解决了原生Redis锁的痛点；
- **可扩展性**：支持多种锁类型，通过注解参数灵活配置，适配支付、秒杀、库存等多场景。

在高并发场景中，分布式锁是“刚需”而非“可选”。选择合适的工具（如Redisson），结合AOP等编程思想，才能在保障系统稳定性的同时，让开发者专注于业务创新。

如果你在实现分布式锁时遇到具体问题（如红锁配置、死锁排查），可以留言讨论，我们会分享更多淘票票的实战经验。