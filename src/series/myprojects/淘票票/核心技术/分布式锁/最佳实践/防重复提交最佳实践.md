# 淘票票项目防重复提交（幂等性）最佳实践

在高并发系统中，防止用户重复提交请求是一个常见且重要的问题。淘票票项目中通过实现一个专门的防重复提交模块来解决这个问题，该模块基于Redis和本地锁实现了一套完整的防重复提交机制。

## 1. 模块概述

防重复提交模块位于 [taopiaopiao-repeat-execute-limit-framework](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-redisson-service-framework/taopiaopiao-repeat-execute-limit-framework) 目录下，通过AOP（面向切面编程）和注解的方式实现防重复提交功能。

### 1.1 核心组件

1. **RepeatExecuteLimit注解** - 用于标记需要防重复提交的方法
2. **RepeatExecuteLimitAspect切面** - 实现防重复提交的核心逻辑
3. **RepeatExecuteLimitAutoConfiguration** - 自动配置类，注册相关Bean
4. **RepeatExecuteLimitLockInfoHandle** - 锁信息处理器实现

## 2. 核心实现原理

### 2.1 三重防护机制

淘票票的防重复提交机制采用了三重防护机制，确保在各种并发场景下都能有效防止重复提交：

1. **Redis标记检查** - 首先检查Redis中是否存在重复请求标记，如果存在则直接拒绝
2. **本地锁检查** - 使用ReentrantLock防止同一JVM内的并发请求
3. **分布式锁检查** - 使用Redisson分布式锁防止多实例环境下的并发请求

### 2.2 执行流程

```
检查Redis标记 -> 获取本地锁 -> 获取分布式锁 -> 再次检查Redis标记 -> 执行业务方法 -> 设置Redis标记 -> 释放锁资源
```

## 3. 完整代码实现

### 3.1 注解定义

```java
package com.taopiaopiao.repeatexecutelimit.annotion;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 防重复幂等 注解
 * @author: GGBOND
 **/
@Target(value= {ElementType.TYPE, ElementType.METHOD})
@Retention(value= RetentionPolicy.RUNTIME)
public @interface RepeatExecuteLimit {

    /**
     * 业务名称
     * @return name
     */
    String name() default "";
    /**
     * key设置
     * @return key
     */
    String [] keys();
    
    /**
     * 在多长时间内一直保持幂等，如果不配置则以执行方法为准
     * */
    long durationTime() default 0L;

    /**
     * 当消息执行已经出发防重复执行的限制时，提示信息
     * */
    String message() default "提交频繁，请稍后重试";
    
}
```

### 3.2 切面实现

```java
package com.taopiaopiao.repeatexecutelimit.aspect;

import com.taopiaopiao.constant.LockInfoType;
import com.taopiaopiao.exception.TaoPiaoPiaoFrameException;
import com.taopiaopiao.handle.RedissonDataHandle;
import com.taopiaopiao.locallock.LocalLockCache;
import com.taopiaopiao.lockinfo.LockInfoHandle;
import com.taopiaopiao.lockinfo.factory.LockInfoHandleFactory;
import com.taopiaopiao.repeatexecutelimit.annotion.RepeatExecuteLimit;
import com.taopiaopiao.servicelock.LockType;
import com.taopiaopiao.servicelock.ServiceLocker;
import com.taopiaopiao.servicelock.factory.ServiceLockFactory;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.core.annotation.Order;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import static com.taopiaopiao.repeatexecutelimit.constant.RepeatExecuteLimitConstant.PREFIX_NAME;
import static com.taopiaopiao.repeatexecutelimit.constant.RepeatExecuteLimitConstant.SUCCESS_FLAG;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 防重复幂等 切面
 * @author: GGBOND
 **/
@Slf4j
@Aspect
@Order(-11)
@AllArgsConstructor
public class RepeatExecuteLimitAspect {

    private final LocalLockCache localLockCache;

    private final LockInfoHandleFactory lockInfoHandleFactory;

    private final ServiceLockFactory serviceLockFactory;

    private final RedissonDataHandle redissonDataHandle;


    @Around("@annotation(repeatLimit)")

    /**
     * 环绕通知处理防重复提交逻辑
     * 实现三重防护机制：
     * 1. Redis标记检查：首先检查Redis中是否存在重复请求标记，如果存在则直接拒绝
     * 2. 本地锁检查：使用ReentrantLock防止同一JVM内的并发请求
     * 3. 分布式锁检查：使用Redisson分布式锁防止多实例环境下的并发请求
     * 
     * 执行流程：
     * - 检查Redis标记 -> 获取本地锁 -> 获取分布式锁 -> 再次检查Redis标记 -> 执行业务方法 -> 设置Redis标记 -> 释放锁资源
     * - 任何一步检查失败都会抛出异常，阻止重复执行
     * - 成功执行后根据配置决定是否在Redis中设置防重复标记
     * @param joinPoint 切入点
     * @param repeatLimit 防重复提交注解
     * @return 方法执行结果
     * @throws Throwable 异常
     */
    public Object around(ProceedingJoinPoint joinPoint, RepeatExecuteLimit repeatLimit) throws Throwable {
        // 获取注解配置的参数
        long durationTime = repeatLimit.durationTime();
        String message = repeatLimit.message();
        Object obj;

        // 获取锁信息处理器，生成唯一的锁名称
        LockInfoHandle lockInfoHandle = lockInfoHandleFactory.getLockInfoHandle(LockInfoType.REPEAT_EXECUTE_LIMIT);
        String lockName = lockInfoHandle.getLockName(joinPoint, repeatLimit.name(), repeatLimit.keys());
        String repeatFlagName = PREFIX_NAME + lockName;

        // 第一层检查：通过Redis检查是否已存在重复请求标记
        String flagObject = redissonDataHandle.get(repeatFlagName);
        if (SUCCESS_FLAG.equals(flagObject)) {
            throw new TaoPiaoPiaoFrameException(message);
        }

        // 第二层检查：本地锁防止同一JVM内并发
        ReentrantLock localLock = localLockCache.getLock(lockName, true);
        boolean localLockResult = localLock.tryLock();
        if (!localLockResult) {
            throw new TaoPiaoPiaoFrameException(message);
        }

        try {
            // 第三层检查：分布式锁防止多实例并发
            ServiceLocker lock = serviceLockFactory.getLock(LockType.Fair);
            boolean result = lock.tryLock(lockName, TimeUnit.SECONDS, 0);
            if (result) {
                try {
                    // 再次确认Redis中无重复请求标记
                    flagObject = redissonDataHandle.get(repeatFlagName);
                    if (SUCCESS_FLAG.equals(flagObject)) {
                        throw new TaoPiaoPiaoFrameException(message);
                    }

                    // 执行目标方法
                    obj = joinPoint.proceed();

                    // 如果设置了持续时间，则在Redis中设置防重复标记
                    if (durationTime > 0) {
                        try {
                            redissonDataHandle.set(repeatFlagName, SUCCESS_FLAG, durationTime, TimeUnit.SECONDS);
                        } catch (Exception e) {
                            log.error("set repeat flag to redis error", e);
                        }
                    }
                    return obj;
                } finally {
                    // 释放分布式锁
                    lock.unlock(lockName);
                }
            } else {
                // 获取分布式锁失败，抛出异常
                throw new TaoPiaoPiaoFrameException(message);
            }
        } finally {
            // 释放本地锁
            localLock.unlock();
        }
    }
}
```

### 3.3 锁信息处理器

```java
package com.taopiaopiao.lockinfo.impl;

import com.taopiaopiao.lockinfo.AbstractLockInfoHandle;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 锁信息实现(防重复幂等)
 * @author: GGBOND
 **/
public class RepeatExecuteLimitLockInfoHandle extends AbstractLockInfoHandle {

    public static final String PREFIX_NAME = "REPEAT_EXECUTE_LIMIT";
    
    @Override
    protected String getLockPrefixName() {
        return PREFIX_NAME;
    }
}
```

### 3.4 常量定义

```java
package com.taopiaopiao.repeatexecutelimit.constant;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 防重复幂等 标记
 * @author: GGBOND
 **/
public class RepeatExecuteLimitConstant {
    
    public static final String PREFIX_NAME = "repeat_flag";
    
    public static final String SUCCESS_FLAG = "success";
}
```

### 3.5 自动配置类

```java
package com.taopiaopiao.config;

import com.taopiaopiao.constant.LockInfoType;
import com.taopiaopiao.handle.RedissonDataHandle;
import com.taopiaopiao.locallock.LocalLockCache;
import com.taopiaopiao.lockinfo.LockInfoHandle;
import com.taopiaopiao.lockinfo.factory.LockInfoHandleFactory;
import com.taopiaopiao.lockinfo.impl.RepeatExecuteLimitLockInfoHandle;
import com.taopiaopiao.repeatexecutelimit.aspect.RepeatExecuteLimitAspect;
import com.taopiaopiao.servicelock.factory.ServiceLockFactory;
import org.springframework.context.annotation.Bean;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 防重复幂等配置
 * @author: GGBOND
 **/
public class RepeatExecuteLimitAutoConfiguration {
    
    @Bean(LockInfoType.REPEAT_EXECUTE_LIMIT)
    public LockInfoHandle repeatExecuteLimitHandle(){
        return new RepeatExecuteLimitLockInfoHandle();
    }
    
    @Bean
    public RepeatExecuteLimitAspect repeatExecuteLimitAspect(LocalLockCache localLockCache,
                                                             LockInfoHandleFactory lockInfoHandleFactory,
                                                             ServiceLockFactory serviceLockFactory,
                                                             RedissonDataHandle redissonDataHandle){
        return new RepeatExecuteLimitAspect(localLockCache, lockInfoHandleFactory,serviceLockFactory,redissonDataHandle);
    }
}
```

## 4. 使用示例

在需要防重复提交的业务方法上添加@RepeatExecuteLimit注解：

```java
@RepeatExecuteLimit(name = "create_order", keys = {"#orderDto.userId", "#orderDto.programId"})
public String createOrder(OrderDto orderDto) {
    // 业务逻辑
    return "订单创建成功";
}
```

## 5. 工作原理详解

### 5.1 锁名称生成

通过[AbstractLockInfoHandle](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-redisson-service-framework/taopiaopiao-redisson-common-framework/src/main/java/com/taopiaopiao/lockinfo/AbstractLockInfoHandle.java#L22-L92)抽象类实现锁名称的生成，结合应用前缀、业务类型和业务参数生成唯一标识：

```
{应用前缀}-{锁类型前缀}-{业务名称}-{参数1}-{参数2}
```

### 5.2 Redis标记机制

通过在Redis中设置标记来实现幂等性，标记的过期时间可以通过注解的[durationTime](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-server%5Ctaopiaopiao-order-service%5Csrc%5Cmain%5Cjava%5Ccom%5Ctaopiaopiao%5Ccontroller%5COrderController.java#L49-L49)参数控制。

### 5.3 本地锁和分布式锁结合

1. **本地锁**：使用ReentrantLock防止同一JVM内的并发请求，避免不必要的Redis操作
2. **分布式锁**：使用Redisson的公平锁确保在分布式环境下的并发安全

## 6. 总结

淘票票项目的防重复提交机制通过三重防护确保了系统的高可用性和数据一致性：

1. **高效性**：通过本地锁快速过滤同一JVM内的重复请求
2. **可靠性**：通过分布式锁确保多实例环境下的并发安全
3. **灵活性**：通过注解方式使用，支持自定义业务参数和过期时间
4. **易用性**：通过AOP自动织入，业务代码无需关注防重复逻辑

这套机制在高并发场景下能够有效防止重复提交，确保业务操作的幂等性，是淘票票项目中保证数据一致性的重要手段。