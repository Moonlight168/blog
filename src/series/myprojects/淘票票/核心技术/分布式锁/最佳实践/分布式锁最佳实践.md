# 淘票票项目分布式锁最佳实践

在高并发分布式系统中，为了保证数据一致性，经常需要在多个服务实例间协调对共享资源的访问。淘票票项目通过实现一套完整的分布式锁机制来解决这个问题，本文将详细介绍该机制的设计和实现。

## 1. 模块概述

分布式锁模块位于 [taopiaopiao-service-lock-framework](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-redisson-service-framework/taopiaopiao-service-lock-framework) 目录下，基于Redisson实现，提供了多种类型的分布式锁和灵活的使用方式。

### 1.1 核心组件

1. **ServiceLock注解** - 声明式使用分布式锁的入口
2. **ServiceLockAspect切面** - 实现分布式锁的核心逻辑
3. **ServiceLocker接口及实现类** - 定义分布式锁操作规范
4. **ServiceLockFactory工厂类** - 根据锁类型创建对应的锁实现
5. **ServiceLockTool工具类** - 编程式使用分布式锁的工具类
6. **ServiceLockAutoConfiguration** - 自动配置类，注册相关Bean

## 2. 锁类型支持

淘票票分布式锁模块支持多种锁类型，以满足不同场景的需求：

1. **可重入锁（Reentrant）** - 最常用的锁类型，基于Redisson的RLock实现
2. **公平锁（Fair）** - 保证获取锁的顺序性，避免线程饥饿
3. **读锁（Read）** - 读写锁中的读锁，支持多个线程同时读取
4. **写锁（Write）** - 读写锁中的写锁，独占访问

## 3. 完整代码实现

### 3.1 注解定义

```java
package com.taopiaopiao.servicelock.annotion;

import com.taopiaopiao.servicelock.LockType;
import com.taopiaopiao.servicelock.info.LockTimeOutStrategy;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.concurrent.TimeUnit;

/**
  @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁 注解
 * @author: GGBOND
 */
/*
 * 声明该注解可以使用的元素类型：类和方法
 */
@Target(value = {ElementType.TYPE, ElementType.METHOD})
/*
  声明该注解的生命周期：运行时保留，程序运行期间可以通过反射获取注解信息
 */
@Retention(value = RetentionPolicy.RUNTIME)
public @interface ServiceLock {

    /**
     * 锁的类型(默认 可重入锁)
     * */
    LockType lockType() default LockType.Reentrant;
    
    /**
     * 业务名称
     * @return name
     */
    String name() default "";
    /**
     * 自定义业务key
     * @return keys
     */
    String [] keys();

    /**
     * 尝试加锁失败最多等待时间
     * @return waitTime
     */
    long waitTime() default 10;

    /**
     * 时间单位
     * @return TimeUnit
     */
    TimeUnit timeUnit() default TimeUnit.SECONDS;

    /**
     * 加锁超时的处理策略
     * @return LockTimeOutStrategy
     */
    LockTimeOutStrategy lockTimeoutStrategy() default LockTimeOutStrategy.FAIL;

    /**
     * 自定义加锁超时的处理策略
     * @return customLockTimeoutStrategy
     */
    String customLockTimeoutStrategy() default "";
}
```

### 3.2 切面实现

```java
package com.taopiaopiao.servicelock.aspect;

import com.taopiaopiao.constant.LockInfoType;
import com.taopiaopiao.util.StringUtil;
import com.taopiaopiao.lockinfo.LockInfoHandle;
import com.taopiaopiao.lockinfo.factory.LockInfoHandleFactory;
import com.taopiaopiao.servicelock.LockType;
import com.taopiaopiao.servicelock.ServiceLocker;
import com.taopiaopiao.servicelock.annotion.ServiceLock;
import com.taopiaopiao.servicelock.factory.ServiceLockFactory;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.annotation.Order;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁 切面
 * @author: GGBOND
 **/
@Slf4j
@Aspect
@Order(-10) // 设置切面优先级，数值越小优先级越高，确保分布式锁在其他切面之前执行
@AllArgsConstructor
public class ServiceLockAspect {

    private final LockInfoHandleFactory lockInfoHandleFactory;

    private final ServiceLockFactory serviceLockFactory;


    /**
     * 环绕通知处理分布式锁逻辑
     *
     * @param joinPoint   连接点
     * @param servicelock 分布式锁注解
     * @return 方法执行结果
     * @throws Throwable 异常
     */
    @Around("@annotation(servicelock)")
    public Object around(ProceedingJoinPoint joinPoint, ServiceLock servicelock) throws Throwable {
        // 获取锁信息处理器
        LockInfoHandle lockInfoHandle = lockInfoHandleFactory.getLockInfoHandle(LockInfoType.SERVICE_LOCK);
        // 构造锁名称
        String lockName = lockInfoHandle.getLockName(joinPoint, servicelock.name(), servicelock.keys());
        // 获取锁类型、等待时间、时间单位等配置
        LockType lockType = servicelock.lockType();
        long waitTime = servicelock.waitTime();
        TimeUnit timeUnit = servicelock.timeUnit();

        // 获取对应类型的锁实例
        ServiceLocker lock = serviceLockFactory.getLock(lockType);
        // 尝试获取锁
        boolean result = lock.tryLock(lockName, timeUnit, waitTime);

        if (result) {
            // 获取锁成功，执行目标方法
            try {
                return joinPoint.proceed();
            } finally {
                // 释放锁
                lock.unlock(lockName);
            }
        } else {
            // 获取锁失败，超时处理
            log.warn("Timeout while acquiring serviceLock:{}", lockName);
            String customLockTimeoutStrategy = servicelock.customLockTimeoutStrategy();
            if (StringUtil.isNotEmpty(customLockTimeoutStrategy)) {
                // 使用自定义超时处理策略
                return handleCustomLockTimeoutStrategy(customLockTimeoutStrategy, joinPoint);
            } else {
                // 使用默认超时处理策略
                servicelock.lockTimeoutStrategy().handler(lockName);
            }
            return joinPoint.proceed();
        }
    }


    /**
     * 处理自定义锁超时策略
     *
     * @param customLockTimeoutStrategy 自定义超时处理方法名
     * @param joinPoint                 连接点
     * @return 自定义处理方法的返回值
     */
    public Object handleCustomLockTimeoutStrategy(String customLockTimeoutStrategy, JoinPoint joinPoint) {
        // 准备调用上下文：获取当前方法签名、目标对象和参数
        Method currentMethod = ((MethodSignature) joinPoint.getSignature()).getMethod();
        Object target = joinPoint.getTarget();
        Method handleMethod = null;
        
        // 通过反射获取自定义超时处理方法
        try {
            handleMethod = target.getClass().getDeclaredMethod(customLockTimeoutStrategy, currentMethod.getParameterTypes());
            // 设置方法可访问，允许调用私有方法
            handleMethod.setAccessible(true);
        } catch (NoSuchMethodException e) {
            // 如果找不到指定的方法，抛出运行时异常
            throw new RuntimeException("Illegal annotation param customLockTimeoutStrategy :" + customLockTimeoutStrategy, e);
        }
        
        // 获取连接点的参数
        Object[] args = joinPoint.getArgs();

        // 调用自定义超时处理方法
        Object result;
        try {
            result = handleMethod.invoke(target, args);
        } catch (IllegalAccessException e) {
            // 如果没有权限访问该方法，抛出运行时异常
            throw new RuntimeException("Fail to illegal access custom lock timeout handler: " + customLockTimeoutStrategy, e);
        } catch (InvocationTargetException e) {
            // 如果调用过程中发生异常，抛出运行时异常
            throw new RuntimeException("Fail to invoke custom lock timeout handler: " + customLockTimeoutStrategy, e);
        }
        
        // 返回自定义处理方法的执行结果
        return result;
    }
}
```

### 3.3 锁接口及实现

```java
package com.taopiaopiao.servicelock;

import org.redisson.api.RLock;

import java.util.concurrent.TimeUnit;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁 方法抽象
 * @author: GGBOND
 **/
public interface ServiceLocker {
    
    /**
     * 获取锁
     * @param lockKey 锁的key
     * @return 结果
     * */
    RLock getLock(String lockKey);
    
    /**
     * 加锁
     * @param lockKey 锁的key
     * @return 结果
     * */
    RLock lock(String lockKey);
    
    /**
     * 加锁
     * @param lockKey 锁的key
     * @param leaseTime 释放时间
     * @return 结果
     * */
    RLock lock(String lockKey, long leaseTime);
    
    /**
     * 加锁
     * @param lockKey 锁的key
     * @param unit 时间单位
     * @param leaseTime 释放时间
     * @return 结果
     * */
    RLock lock(String lockKey, TimeUnit unit, long leaseTime);
    
    /**
     * 加锁
     * @param lockKey 锁的key
     * @param unit 时间单位
     * @param waitTime 等待时间
     * @return 结果
     * */
    boolean tryLock(String lockKey, TimeUnit unit, long waitTime);
    
    /**
     * 加锁
     * @param lockKey 锁的key
     * @param unit 时间单位
     * @param waitTime 等待时间
     * @param leaseTime 释放时间
     * @return 结果
     * */
    boolean tryLock(String lockKey, TimeUnit unit, long waitTime, long leaseTime);
    
    /**
     * 解锁
     * @param lockKey 锁的key
     * */
    void unlock(String lockKey);
    
    /**
     * 解锁
     * @param lock 锁
     * */
    void unlock(RLock lock);
}
```

### 3.4 锁工厂类

```java
package com.taopiaopiao.servicelock.factory;

import com.taopiaopiao.core.ManageLocker;
import com.taopiaopiao.servicelock.LockType;
import com.taopiaopiao.servicelock.ServiceLocker;
import lombok.AllArgsConstructor;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁类型工厂
 * @author: GGBOND
 **/
@AllArgsConstructor
public class ServiceLockFactory {
    
    private final ManageLocker manageLocker;
    

    public ServiceLocker getLock(LockType lockType){
        ServiceLocker lock;
        switch (lockType) {
            case Fair:
                lock = manageLocker.getFairLocker();
                break;
            case Write:
                lock = manageLocker.getWriteLocker();
                break;
            case Read:
                lock = manageLocker.getReadLocker();
                break;
            default:
                lock = manageLocker.getReentrantLocker();
                break;
        }
        return lock;
    }
}
```

### 3.5 锁管理器

```java
package com.taopiaopiao.core;

import com.taopiaopiao.servicelock.LockType;
import com.taopiaopiao.servicelock.ServiceLocker;
import com.taopiaopiao.servicelock.impl.RedissonFairLocker;
import com.taopiaopiao.servicelock.impl.RedissonReadLocker;
import com.taopiaopiao.servicelock.impl.RedissonReentrantLocker;
import com.taopiaopiao.servicelock.impl.RedissonWriteLocker;
import org.redisson.api.RedissonClient;

import java.util.HashMap;
import java.util.Map;

import static com.taopiaopiao.servicelock.LockType.Fair;
import static com.taopiaopiao.servicelock.LockType.Read;
import static com.taopiaopiao.servicelock.LockType.Reentrant;
import static com.taopiaopiao.servicelock.LockType.Write;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁 锁缓存
 * @author: GGBOND
 **/
public class ManageLocker {

    private final Map<LockType, ServiceLocker> cacheLocker = new HashMap<>();
    
    public ManageLocker(RedissonClient redissonClient){
        cacheLocker.put(Reentrant,new RedissonReentrantLocker(redissonClient));
        cacheLocker.put(Fair,new RedissonFairLocker(redissonClient));
        cacheLocker.put(Write,new RedissonWriteLocker(redissonClient));
        cacheLocker.put(Read,new RedissonReadLocker(redissonClient));
    }
    
    public ServiceLocker getReentrantLocker(){
        return cacheLocker.get(Reentrant);
    }
    
    public ServiceLocker getFairLocker(){
        return cacheLocker.get(Fair);
    }
    
    public ServiceLocker getWriteLocker(){
        return cacheLocker.get(Write);
    }
    
    public ServiceLocker getReadLocker(){
        return cacheLocker.get(Read);
    }
}
```

### 3.6 锁信息处理器

```java
package com.taopiaopiao.lockinfo.impl;

import com.taopiaopiao.lockinfo.AbstractLockInfoHandle;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 锁信息实现(分布式锁)
 * @author: GGBOND
 **/
public class ServiceLockInfoHandle extends AbstractLockInfoHandle {

    private static final String LOCK_PREFIX_NAME = "SERVICE_LOCK";
    
    @Override
    protected String getLockPrefixName() {
        return LOCK_PREFIX_NAME;
    }
}
```

### 3.7 自动配置类

```java
package com.taopiaopiao.config;

import com.taopiaopiao.constant.LockInfoType;
import com.taopiaopiao.core.ManageLocker;
import com.taopiaopiao.lockinfo.LockInfoHandle;
import com.taopiaopiao.lockinfo.factory.LockInfoHandleFactory;
import com.taopiaopiao.lockinfo.impl.ServiceLockInfoHandle;
import com.taopiaopiao.servicelock.aspect.ServiceLockAspect;
import com.taopiaopiao.servicelock.factory.ServiceLockFactory;
import com.taopiaopiao.util.ServiceLockTool;
import org.redisson.api.RedissonClient;
import org.springframework.context.annotation.Bean;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 分布式锁 配置
 * @author: GGBOND
 **/
public class ServiceLockAutoConfiguration {
    
    @Bean(LockInfoType.SERVICE_LOCK)
    public LockInfoHandle serviceLockInfoHandle(){
        return new ServiceLockInfoHandle();
    }
    
    @Bean
    public ManageLocker manageLocker(RedissonClient redissonClient){
        return new ManageLocker(redissonClient);
    }
    
    @Bean
    public ServiceLockFactory serviceLockFactory(ManageLocker manageLocker){
        return new ServiceLockFactory(manageLocker);
    }
    
    @Bean
    public ServiceLockAspect serviceLockAspect(LockInfoHandleFactory lockInfoHandleFactory,ServiceLockFactory serviceLockFactory){
        return new ServiceLockAspect(lockInfoHandleFactory,serviceLockFactory);
    }
    
    @Bean
    public ServiceLockTool serviceLockUtil(LockInfoHandleFactory lockInfoHandleFactory,ServiceLockFactory serviceLockFactory){
        return new ServiceLockTool(lockInfoHandleFactory,serviceLockFactory);
    }
}
```

## 4. 使用示例

### 4.1 声明式使用（推荐）

```java
@Service
public class OrderService {
    
    @ServiceLock(name = "create_order", keys = {"#order.userId", "#order.programId"})
    public void createOrder(Order order) {
        // 创建订单的业务逻辑
    }
}
```

### 4.2 编程式使用

```java
@Service
public class OrderService {
    
    @Autowired
    private ServiceLockTool serviceLockTool;
    
    public void createOrder(Order order) {
        serviceLockTool.execute(
            () -> {
                // 创建订单的业务逻辑
            }, 
            "create_order", 
            new String[]{String.valueOf(order.getUserId()), String.valueOf(order.getProgramId())}
        );
    }
}
```

## 5. 工作原理详解

### 5.1 锁名称生成

通过[AbstractLockInfoHandle](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-redisson-service-framework/taopiaopiao-redisson-common-framework/src/main/java/com/taopiaopiao/lockinfo/AbstractLockInfoHandle.java#L22-L92)抽象类实现锁名称的生成，结合应用前缀、业务类型和业务参数生成唯一标识：

```
{应用前缀}-{锁类型前缀}-{业务名称}-{参数1}-{参数2}
```

支持使用SpEL表达式动态生成参数值。

### 5.2 锁获取与释放流程

1. **切面拦截** - 通过AOP拦截带有@ServiceLock注解的方法
2. **锁名称生成** - 根据注解配置生成唯一锁名称
3. **锁实例获取** - 根据锁类型从工厂获取对应的锁实现
4. **尝试获取锁** - 调用Redisson的tryLock方法尝试获取锁
5. **执行业务逻辑** - 获取锁成功后执行目标方法
6. **释放锁** - 方法执行完成后自动释放锁

### 5.3 超时处理机制

提供了两种超时处理方式：
1. **默认处理策略** - 直接抛出异常
2. **自定义处理策略** - 调用指定的方法处理超时情况

## 6. 总结

淘票票项目的分布式锁机制具有以下特点：

1. **多种锁类型支持** - 支持可重入锁、公平锁、读写锁等多种类型
2. **灵活的使用方式** - 提供声明式和编程式两种使用方式
3. **完善的超时处理** - 支持默认和自定义超时处理策略
4. **基于Redisson实现** - 利用Redisson的强大功能保证锁的可靠性
5. **易于集成** - 通过Spring Boot自动配置简化集成过程

这套机制在高并发场景下能够有效保证数据一致性，是淘票票项目中保证系统稳定性的关键技术之一。