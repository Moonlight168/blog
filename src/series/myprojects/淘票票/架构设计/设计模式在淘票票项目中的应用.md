# 设计模式在淘票票项目中的应用

淘票票项目作为高并发的票务系统，在架构设计中广泛应用了多种设计模式，以提高代码的可维护性、可扩展性和复用性。本文将详细介绍项目中使用的主要设计模式及其具体应用。

## 1. 工厂模式（Factory Pattern）

### 1.1 模式定义
工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而是引用一个共同的接口来指向新创建的对象。

### 1.2 项目应用

#### 1.2.1 ServiceLockFactory（分布式锁工厂）
在分布式锁模块中，[ServiceLockFactory](file://F:\MyProjects\taopiaopiao\taopiaopiao-redisson-framework\taopiaopiao-redisson-service-framework\taopiaopiao-service-lock-framework\src\main\java\com\taopiaopiao\servicelock\factory\ServiceLockFactory.java#L15-L36)根据锁类型创建不同的锁实现：

```java
public class ServiceLockFactory {
    private final ManageLocker manageLocker;

    public ServiceLocker getLock(LockType lockType){
        ServiceLocker lock;
        switch (lockType) {
            case Fair:
                lock = manageLocker.getFairLocker();
                break;
            case Write:
                lock = manageLocker.getWriteLocker();
                break;
            case Read:
                lock = manageLocker.getReadLocker();
                break;
            default:
                lock = manageLocker.getReentrantLocker();
                break;
        }
        return lock;
    }
}
```

#### 1.2.2 LockInfoHandleFactory（锁信息处理器工厂）
[LockInfoHandleFactory](file://F:\MyProjects\taopiaopiao\taopiaopiao-redisson-framework\taopiaopiao-redisson-service-framework\taopiaopiao-redisson-common-framework\src\main\java\com\taopiaopiao\lockinfo\factory\LockInfoHandleFactory.java#L15-L25)通过Spring容器获取不同类型的锁信息处理器：

```java
public class LockInfoHandleFactory implements ApplicationContextAware {
    private ApplicationContext applicationContext;

    public LockInfoHandle getLockInfoHandle(String lockInfoType){
        return applicationContext.getBean(lockInfoType, LockInfoHandle.class);
    }
}
```

#### 1.2.3 CaptchaServiceFactory（验证码服务工厂）
[CaptchaServiceFactory](file://F:\MyProjects\taopiaopiao\taopiaopiao-captcha-manage-framework\taopiaopiao-base-captcha\src\main\java\com\taopiaopiao\captcha\service\impl\CaptchaServiceFactory.java#L19-L54)使用Java SPI机制加载所有验证码服务实现：

```java
public class CaptchaServiceFactory {
    static {
        ServiceLoader<CaptchaService> services = ServiceLoader.load(CaptchaService.class);
        for (CaptchaService item : services) {
            instances.put(item.captchaType(), item);
        }
    }

    public static CaptchaService getInstance(Properties config) {
        String captchaType = config.getProperty(Const.CAPTCHA_TYPE, "default");
        CaptchaService ret = instances.get(captchaType);
        // ...
        return ret;
    }
}
```

## 2. 策略模式（Strategy Pattern）

### 2.1 模式定义
策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，使算法的变化独立于使用它们的客户端。

### 2.2 项目应用

#### 2.2.1 支付策略
在支付服务中，项目通过策略模式支持多种支付方式：

1. [PayStrategyHandler](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-pay-service\src\main\java\com\taopiaopiao\pay\PayStrategyHandler.java#L12-L60)定义支付策略接口：
```java
public interface PayStrategyHandler {
    PayResult pay(String outTradeNo, BigDecimal price, String subject, String notifyUrl, String returnUrl);
    boolean signVerify(Map<String, String> params);
    boolean dataVerify(Map<String, String> params, PayBill payBill);
    TradeResult queryTrade(String outTradeNo);
    RefundResult refund(String outTradeNo, BigDecimal price, String reason);
    String getChannel();
}
```

2. [AlipayStrategyHandler](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-pay-service\src\main\java\com\taopiaopiao\pay\alipay\AlipayStrategyHandler.java#L35-L202)实现支付宝支付策略：
```java
public class AlipayStrategyHandler implements PayStrategyHandler {
    @Override
    public PayResult pay(String outTradeNo, BigDecimal price, String subject, String notifyUrl, String returnUrl) {
        // 支付宝支付具体实现
    }
    
    @Override
    public String getChannel() {
        return PayChannel.ALIPAY.getValue();
    }
    // 其他方法实现...
}
```

3. [PayStrategyContext](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-pay-service\src\main\java\com\taopiaopiao\pay\PayStrategyContext.java#L15-L26)管理支付策略：
```java
public class PayStrategyContext {
    private final Map<String,PayStrategyHandler> payStrategyHandlerMap = new HashMap<>();
    
    public PayStrategyHandler get(String channel){
        return Optional.ofNullable(payStrategyHandlerMap.get(channel)).orElseThrow(
                () -> new TaoPiaoPiaoFrameException(BaseCode.PAY_STRATEGY_NOT_EXIST));
    }
}
```

#### 2.2.2 订单创建策略
在节目订单服务中，项目通过策略模式支持多个版本的订单创建逻辑：

1. [ProgramOrderStrategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-program-service\src\main\java\com\taopiaopiao\service\strategy\ProgramOrderStrategy.java#L10-L17)定义订单创建策略接口：
```java
public interface ProgramOrderStrategy {
    String createOrder(ProgramOrderCreateDto programOrderCreateDto);
}
```

2. 不同版本的实现类：
- [ProgramOrderV1Strategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-program-service\src\main\java\com\taopiaopiao\service\strategy\impl\ProgramOrderV1Strategy.java#L23-L53)
- [ProgramOrderV2Strategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-program-service\src\main\java\com\taopiaopiao\service\strategy\impl\ProgramOrderV2Strategy.java#L1-L58)
- [ProgramOrderV3Strategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-program-service\src\main\java\com\taopiaopiao\service\strategy\impl\ProgramOrderV3Strategy.java#L1-L55)
- [ProgramOrderV4Strategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-program-service\src\main\java\com\taopiaopiao\service\strategy\impl\ProgramOrderV4Strategy.java#L1-L55)

#### 2.2.3 锁超时策略
在分布式锁模块中，通过策略模式处理锁获取超时的情况：

[LockTimeOutStrategy](file://F:\MyProjects\taopiaopiao\taopiaopiao-redisson-framework\taopiaopiao-redisson-service-framework\taopiaopiao-service-lock-framework\src\main\java\com\taopiaopiao\servicelock\info\LockTimeOutStrategy.java#L11-L20)枚举定义了锁超时处理策略：
```java
public enum LockTimeOutStrategy implements LockTimeOutHandler{
    FAIL(){
        @Override
        public void handler(String lockName) {
            String msg = String.format("%s请求频繁",lockName);
            throw new RuntimeException(msg);
        }
    }
}
```

## 3. 单例模式（Singleton Pattern）

### 3.1 模式定义
单例模式是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。

### 3.2 项目应用

在淘票票项目中，许多Spring管理的Bean实际上就是单例模式的体现，如各种Service、Mapper、Util类等。Spring默认的Bean作用域就是单例。

## 4. 装饰器模式（Decorator Pattern）

### 4.1 模式定义
装饰器模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

### 4.2 项目应用

在网关的请求处理中，使用了装饰器模式来包装请求对象：

```java
private ServerHttpRequestDecorator decorateHead(ServerWebExchange exchange, HttpHeaders headers, CachedBodyOutputMessage outputMessage, RequestTemporaryWrapper requestTemporaryWrapper, Map<String,String> headMap){
    return new ServerHttpRequestDecorator(exchange.getRequest()){
        @Override
        public HttpHeaders getHeaders() {
            // 装饰原始请求头
        }

        @Override
        public Flux<DataBuffer> getBody() {
            // 装饰原始请求体
            return outputMessage.getBody();
        }
    };
}
```

## 5. 代理模式（Proxy Pattern）

### 5.1 模式定义
代理模式是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

### 5.2 项目应用

### 5.2.1 AOP代理
在分布式锁和防重复执行功能中，使用Spring AOP实现动态代理：

[ServiceLockAspect](file://F:\MyProjects\taopiaopiao\taopiaopiao-redisson-framework\taopiaopiao-redisson-service-framework\taopiaopiao-service-lock-framework\src\main\java\com\taopiaopiao\servicelock\aspect\ServiceLockAspect.java#L28-L128)通过切面拦截被[@ServiceLock](file://F:\MyProjects\taopiaopiao\taopiaopiao-redisson-framework\taopiaopiao-redisson-service-framework\taopiaopiao-service-lock-framework\src\main\java\com\taopiaopiao\servicelock\annotion\ServiceLock.java#L19-L65)注解标记的方法：

```java
@Aspect
public class ServiceLockAspect {
    @Around("@annotation(servicelock)")
    public Object around(ProceedingJoinPoint joinPoint, ServiceLock servicelock) throws Throwable {
        // 在目标方法执行前后添加分布式锁逻辑
    }
}
```

## 6. 模板方法模式（Template Method Pattern）

### 6.1 模式定义
模板方法模式是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。

### 6.2 项目应用

在项目初始化模块中，使用模板方法模式定义了应用启动时的初始化流程：

```java
public abstract class AbstractApplicationCommandLineRunnerHandler implements CommandLineRunner, Ordered {
    @Override
    public final void run(String... args) throws Exception {
        // 模板方法，定义了执行流程
        executeInit();
    }
    
    // 子类需要实现的具体方法
    public abstract void executeInit();
}
```

## 7. 观察者模式（Observer Pattern）

### 7.1 模式定义
观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个"观察"该对象的其他对象。

### 7.2 项目应用

Spring框架本身大量使用了观察者模式，如事件监听机制。在淘票票项目中，通过[@EventListener](file://F:\MyProjects\taopiaopiao\taopiaopiao-server\taopiaopiao-base-data-service\src\main\java\com\taopiaopiao\listener\DataInitListener.java#L27-L27)注解实现事件监听：

```java
@Component
public class DataInitListener {
    @EventListener
    public void handleDataInitEvent(DataInitEvent event) {
        // 处理数据初始化事件
    }
}
```

## 8. 建造者模式（Builder Pattern）

### 8.1 模式定义
建造者模式是一种创建型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象。

### 8.2 项目应用

在灰度发布组件中使用了建造者模式：

```java
public class EnhanceServiceInstanceListSupplierBuilder {
    // 通过建造者模式构建服务实例列表
}
```

## 总结

淘票票项目通过合理运用各种设计模式，构建了一个高内聚、低耦合、易扩展的系统架构。这些设计模式的应用不仅提高了代码的可维护性，也增强了系统的稳定性和可扩展性，为应对高并发场景提供了坚实的基础。