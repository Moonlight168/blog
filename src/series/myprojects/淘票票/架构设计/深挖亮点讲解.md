# 淘票票项目深挖亮点讲解

## 1. 多级缓存一致性保障机制

在高并发系统中，缓存是提升性能的关键手段。淘票票项目采用了多级缓存架构，并实现了完善的缓存一致性保障机制。

### 1.1 多级缓存架构设计

淘票票项目采用三级缓存架构：
1. **本地缓存（Caffeine）**：访问速度最快，存储热点数据
2. **分布式缓存（Redis）**：支持集群部署，数据共享
3. **持久化存储（MySQL）**：数据的最终来源

```java
// 本地缓存示例
public class LocalCacheProgramShowTime {
    private final Cache<String, ProgramShowTime> localCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .build();
}
```

### 1.2 缓存一致性策略

#### 1.2.1 Cache-Aside模式
这是淘票票项目中最常用的缓存模式：
1. 读数据时，先读缓存，缓存不存在则读数据库并写入缓存
2. 写数据时，先更新数据库，再删除缓存

```java
public ProgramShowTime selectProgramShowTimeByProgramIdMultipleCache(Long programId){
    return localCacheProgramShowTime.getCache(
        RedisKeyBuild.createRedisKey(RedisKeyManage.PROGRAM_SHOW_TIME, programId).getRelKey(),
        key -> selectProgramShowTimeByProgramId(programId));
}
```

#### 1.2.2 延迟双删策略
为了解决并发场景下的缓存不一致问题，淘票票采用了延迟双删策略：
1. 删除缓存
2. 更新数据库
3. 延迟一段时间后再次删除缓存

```java
// 延迟操作节目数据的消费者
@Component
public class DelayOperateProgramDataConsumer implements ConsumerTask {
    @Autowired
    private ProgramService programService;
    
    @Override
    public void execute(String content) {
        // 延迟处理缓存更新
        programService.operateProgramData(programOperateDataDto);
    }
}
```

### 1.3 缓存穿透防护

通过布隆过滤器防止缓存穿透：
```yaml
bloom-filter:
  name: program-detail-bloom-filter
  expectedInsertions: 1000
  falseProbability: 0.01
```

### 1.4 缓存雪崩防护

通过设置不同的过期时间防止缓存雪崩：
```java
// 随机过期时间避免集体失效
long expireTime = 30 + new Random().nextInt(30); // 30-60分钟
```

## 2. 性能优化必备技巧

### 2.1 数据库优化

#### 2.1.1 分库分表策略
淘票票项目使用ShardingSphere实现分库分表：
```yaml
rules:
  - !SHARDING
    tables:
      t_order:
        actualDataNodes: ds_${0..1}.t_order_${0..3}
        databaseStrategy:
          complex:
            shardingColumns: order_number,user_id
            shardingAlgorithmName: databaseOrderComplexGeneArithmetic
```

#### 2.1.2 基因法分片
通过基因法确保相关数据存储在同一分片中：
```java
public long calculateDatabaseIndex(Integer databaseCount, Long splicingKey, Integer tableCount) {
    String splicingKeyBinary = Long.toBinaryString(splicingKey);
    long replacementLength = log2N(tableCount);
    String geneBinaryStr = splicingKeyBinary.substring(splicingKeyBinary.length() - (int) replacementLength);
    // 根据基因片段计算数据库索引
}
```

### 2.2 JVM优化

#### 2.2.1 对象复用
通过对象池减少GC压力：
```java
// RedisKeyBuild对象复用
public class RedisKeyBuild {
    private static final ThreadLocal<RedisKeyBuild> INSTANCE = ThreadLocal.withInitial(RedisKeyBuild::new);
}
```

#### 2.2.2 避免大对象创建
使用StringBuilder替代字符串拼接：
```java
String key = StrUtil.join("-", lockKeyPrefix, programId, ticketCategoryId);
```

### 2.3 网络优化

#### 2.3.1 连接池优化
```java
// Redis连接池配置
config.useSingleServer()
       .setConnectionPoolSize(64)
       .setConnectionMinimumIdleSize(32)
       .setIdleConnectionTimeout(10000);
```

#### 2.3.2 HTTP客户端优化
使用OkHttp替代默认HTTP客户端：
```xml
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-okhttp</artifactId>
</dependency>
```

## 3. 函数式接口的应用与个性化定制

### 3.1 函数式接口在分布式锁中的应用

淘票票项目通过函数式接口简化分布式锁的使用：
```java
@FunctionalInterface
public interface TaskRun {
    void run();
}

@FunctionalInterface
public interface TaskCall<T> {
    T call();
}
```

使用示例：
```java
// 使用函数式接口简化锁的使用
serviceLockTool.lockAndExecute(
    LockType.Reentrant, 
    "lock_key", 
    () -> {
        // 业务逻辑
        return result;
    }
);
```

### 3.2 自定义函数式组件

#### 3.2.1 延迟队列消费者
```java
public interface ConsumerTask {
    void execute(String content);
    String topic();
}
```

#### 3.2.2 锁信息处理器
```java
public interface LockInfoHandle {
    LockInfo getLockInfo(ProceedingJoinPoint joinPoint, ServiceLock serviceLock);
}
```

### 3.3 函数式编程优势

1. **代码简洁性**：减少样板代码
2. **可读性提升**：业务逻辑更加清晰
3. **易于测试**：函数无状态，便于单元测试
4. **复用性强**：高阶函数可以组合使用

## 4. 提升十倍性能的关键优化点

### 4.1 异步处理机制

淘票票项目大量使用异步处理提升性能：

#### 4.1.1 线程池封装
```java
public class BusinessThreadPool extends BaseThreadPool {
    public static void execute(Runnable r) {
        execute.execute(wrapTask(r, getContextForTask(), getContextForHold()));
    }
    
    public static <T> Future<T> submit(Callable<T> c) {
        return execute.submit(wrapTask(c, getContextForTask(), getContextForHold()));
    }
}
```

#### 4.1.2 异步任务解耦
```java
// 订单取消消息异步发送
public void sendMessage(String message){
    delayQueueContext.sendMessage(
        SpringUtil.getPrefixDistinctionName() + "-" + DELAY_ORDER_CANCEL_TOPIC,
        message, 
        DELAY_ORDER_CANCEL_TIME, 
        DELAY_ORDER_CANCEL_TIME_UNIT);
}
```

### 4.2 读写分离优化

通过读写锁提升并发性能：
```java
// 读锁示例
@ServiceLock(lockType= LockType.Read, name = PROGRAM_LOCK, keys = {"#programId"})
public ProgramVo getById(Long programId, Long expireTime, TimeUnit timeUnit) {
    // 读操作使用读锁，支持并发读取
}
```

### 4.3 本地缓存预热

通过本地缓存预热减少数据库访问：
```java
@PostConstruct
public void init() {
    // 系统启动时预热热点数据
    preloadHotData();
}
```

### 4.4 批量操作优化

减少网络交互次数：
```java
// 批量处理座位数据
List<String> seatDataList = new ArrayList<>();
for (SeatVo seatVo : v) {
    seatDataList.add(String.valueOf(seatVo.getId()));
    seatDataList.add(JSON.toJSONString(seatVo));
}
```

## 5. 链路追踪与上下文传递

### 5.1 TraceId传递机制

通过TransmittableThreadLocal确保TraceId在多线程间传递：
```java
TransmittableThreadLocal<String> ttl2 = new TransmittableThreadLocal<>() {
    @Override
    protected void beforeExecute() {
        String traceId = get();
        if (StringUtil.isNotEmpty(traceId)) {
            MDC.put("traceId",traceId);   
        }
    }
    
    @Override
    protected void afterExecute() {
        MDC.clear();
    }
};
```

### 5.2 上下文传递优化

通过自定义线程池确保业务参数在任务执行间传递：
```java
private static Map<String,Map<String,String>> preprocess(
        final Map<String, String> parentMdcContext, 
        final Map<String, String> parentHoldContext){
    // 上下文预处理
    Map<String,Map<String,String>> map = new HashMap<>(8);
    Map<String, String> holdContext = BaseParameterHolder.getParameterMap();
    Map<String, String> mdcContext = MDC.getCopyOfContextMap();
    // ...
    return map;
}
```

## 6. 高并发场景下的优化策略

### 6.1 无锁化设计

在购票场景中采用无锁化设计提升性能：
```java
// 使用Redis原子操作实现库存扣减
String script = "if redis.call('get', KEYS[1]) >= ARGV[1] then " +
               "return redis.call('decrby', KEYS[1], ARGV[1]) " +
               "else return -1 end";
```

### 6.2 限流与降级

通过Sentinel实现限流与降级：
```java
@SentinelResource(value = "createOrder", blockHandler = "handleException")
public String createOrder(OrderCreateDto order) {
    // 订单创建逻辑
}
```

### 6.3 熔断机制

通过Hystrix实现服务熔断：
```yaml
feign:
  hystrix:
    enabled: true
```

## 总结

淘票票项目通过以下关键技术点实现了高性能、高可用的架构：

1. **多级缓存架构**：结合本地缓存、分布式缓存和数据库，通过一致性策略保障数据一致性
2. **分库分表策略**：使用基因法分片确保相关数据存储在同一分片中
3. **函数式编程**：通过函数式接口简化复杂组件的使用
4. **异步处理**：大量使用线程池和消息队列实现异步解耦
5. **链路追踪**：通过TransmittableThreadLocal实现上下文在多线程间的传递
6. **高并发优化**：采用无锁化设计、读写分离、批量操作等策略提升性能

这些技术的综合运用使得淘票票项目能够支持高并发访问，为用户提供了流畅的购票体验。