# 淘票票项目延迟队列最佳实践

在分布式系统中，延迟队列是一种重要的组件，用于处理需要在特定时间后执行的任务。淘票票项目通过实现一套完整的延迟队列机制来解决订单超时未支付自动取消、活动开始前提醒等场景的需求。

## 1. 模块概述

延迟队列模块位于 [taopiaopiao-service-delay-queue-framework](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework) 目录下，基于Redisson实现，提供了高性能、可扩展的延迟队列功能。

### 1.1 核心组件

1. **DelayQueueContext** - 延迟队列发送者上下文，用于发送延迟消息
2. **ConsumerTask接口** - 延迟队列消费者任务接口，业务方需要实现该接口处理延迟消息
3. **DelayQueueInitHandler** - 延迟队列初始化处理器，在应用启动时自动注册消费者
4. **DelayQueueProperties** - 延迟队列配置属性，支持自定义线程池参数和分区数
5. **DelayProduceQueue** - 延迟队列生产者实现
6. **DelayConsumerQueue** - 延迟队列消费者实现
7. **IsolationRegionSelector** - 分片选择器，用于实现队列分区

## 2. 设计特点

### 2.1 高性能设计

1. **分片机制** - 通过[IsolationRegionSelector](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/core/IsolationRegionSelector.java#L11-L33)实现队列分片，提高并发处理能力
2. **线程池隔离** - 生产者和消费者使用独立的线程池，避免相互影响
3. **基于Redisson** - 利用Redisson的RDelayedQueue实现可靠的延迟队列功能

### 2.2 可扩展性设计

1. **配置化参数** - 支持自定义线程池参数和分区数
2. **SPI机制** - 通过实现[ConsumerTask](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/core/ConsumerTask.java#L7-L20)接口扩展消费者任务
3. **自动注册** - 应用启动时自动扫描并注册消费者任务

## 3. 完整代码实现

### 3.1 消费者任务接口

```java
package com.taopiaopiao.core;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 消费者接口
 * @author: GGBOND
 **/
public interface ConsumerTask {
    
    /**
     * 消费任务
     * @param content 具体参数
     * */
    void execute(String content);
    /**
     * 主题
     * @return 主题
     * */
    String topic();
}
```

### 3.2 延迟队列生产者

```java
package com.taopiaopiao.core;

import org.redisson.api.RDelayedQueue;
import org.redisson.api.RedissonClient;

import java.util.concurrent.TimeUnit;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 延迟队列
 * @author: GGBOND
 **/
public class DelayProduceQueue extends DelayBaseQueue{
    
    private final RDelayedQueue<String> delayedQueue;
    public DelayProduceQueue(RedissonClient redissonClient, final String relTopic) {
        super(redissonClient, relTopic);
        this.delayedQueue = redissonClient.getDelayedQueue(blockingQueue);
    }
    
    public void offer(String content, long delayTime, TimeUnit timeUnit) {
        delayedQueue.offer(content,delayTime,timeUnit);
    }
}
```

### 3.3 延迟队列消费者

```java
package com.taopiaopiao.core;

import com.taopiaopiao.context.DelayQueuePart;
import lombok.extern.slf4j.Slf4j;

import java.util.Objects;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 消费
 * @author: GGBOND
 **/
@Slf4j
public class DelayConsumerQueue extends DelayBaseQueue{
    
    private final AtomicInteger listenStartThreadCount = new AtomicInteger(1);
    
    private final AtomicInteger executeTaskThreadCount = new AtomicInteger(1);
    
    private final ThreadPoolExecutor listenStartThreadPool;
    
    private final ThreadPoolExecutor executeTaskThreadPool;
    
    private final AtomicBoolean runFlag = new AtomicBoolean(false);
    
    private final ConsumerTask consumerTask;
    
    public DelayConsumerQueue(DelayQueuePart delayQueuePart, String relTopic){
        super(delayQueuePart.getDelayQueueBasePart().getRedissonClient(),relTopic);
        this.listenStartThreadPool = new ThreadPoolExecutor(1,1,60, 
                TimeUnit.SECONDS,new LinkedBlockingQueue<>(),r -> new Thread(Thread.currentThread().getThreadGroup(), r,
                "listen-start-thread-" + listenStartThreadCount.getAndIncrement()));
        this.executeTaskThreadPool = new ThreadPoolExecutor(
                delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties().getCorePoolSize(),
                delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties().getMaximumPoolSize(),
                delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties().getKeepAliveTime(),
                delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties().getUnit(),
                new LinkedBlockingQueue<>(delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties().getWorkQueueSize()),
                r -> new Thread(Thread.currentThread().getThreadGroup(), r, 
                        "delay-queue-consume-thread-" + executeTaskThreadCount.getAndIncrement()));
        this.consumerTask = delayQueuePart.getConsumerTask();
    }
    
    public synchronized void listenStart(){
        if (!runFlag.get()) {
            runFlag.set(true);
            listenStartThreadPool.execute(() -> {
                while (!Thread.interrupted() && !redissonClient.isShutdown()) {
                    try {
                        assert blockingQueue != null;
                        String content = blockingQueue.take();
                        executeTaskThreadPool.execute(() -> {
                            try {
                                consumerTask.execute(content);
                            }catch (Exception e) {
                                log.error("consumer execute error",e);
                            }
                        });
                    } catch (InterruptedException e) {
                        destroy(executeTaskThreadPool);
                        Thread.currentThread().interrupt(); // 恢复中断状态
                    } catch (Throwable e) {
                        log.error("blockingQueue take error",e);
                    }
                }
            });
        }
    }
    
    public void destroy(ExecutorService executorService) {
        try {
            if (Objects.nonNull(executorService)) {
                executorService.shutdown();
            }
        } catch (Exception e) {
            log.error("destroy error",e);
        }
    }
}
```

### 3.4 分片选择器

```java
package com.taopiaopiao.core;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 分片选择器
 * @author: GGBOND
 **/
public class IsolationRegionSelector {

	private final AtomicInteger count = new AtomicInteger(0);

	private final Integer thresholdValue;

	public IsolationRegionSelector(Integer thresholdValue) {
		this.thresholdValue = thresholdValue;
	}

	private int reset() {
		count.set(0);
		return count.get();
	}
	
	public synchronized int getIndex() {
		int cur = count.get();
		if (cur >= thresholdValue) {
			cur = reset();
		} else {
			count.incrementAndGet();
		}
		return cur;
	}
}
```

### 3.5 发送者上下文

```java
package com.taopiaopiao.context;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 发送者上下文
 * @author: GGBOND
 **/
public class DelayQueueContext {
    
    private final DelayQueueBasePart delayQueueBasePart;
    /**
     * key为topic主题，value为发送消息的处理器
     * */
    private final Map<String, DelayQueueProduceCombine> delayQueueProduceCombineMap = new ConcurrentHashMap<>();
    
    public DelayQueueContext(DelayQueueBasePart delayQueueBasePart){
        this.delayQueueBasePart = delayQueueBasePart;
    }
    
    public void sendMessage(String topic,String content,long delayTime, TimeUnit timeUnit) {
        DelayQueueProduceCombine delayQueueProduceCombine = delayQueueProduceCombineMap.computeIfAbsent(
                topic, k -> new DelayQueueProduceCombine(delayQueueBasePart,topic));
        delayQueueProduceCombine.offer(content,delayTime,timeUnit);
    }
}
```

### 3.6 发送者分片组合

```java
package com.taopiaopiao.context;

import com.taopiaopiao.core.DelayProduceQueue;
import com.taopiaopiao.core.IsolationRegionSelector;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 发送者 分片选择
 * @author: GGBOND
 **/
public class DelayQueueProduceCombine {
    
    private final IsolationRegionSelector isolationRegionSelector;
    
    private final List<DelayProduceQueue> delayProduceQueueList = new ArrayList<>();
    
    public DelayQueueProduceCombine(DelayQueueBasePart delayQueueBasePart,String topic){
        Integer isolationRegionCount = delayQueueBasePart.getDelayQueueProperties().getIsolationRegionCount();
        isolationRegionSelector =new IsolationRegionSelector(isolationRegionCount);
        //开始分片
        for(int i = 0; i < isolationRegionCount; i++) {
            delayProduceQueueList.add(new DelayProduceQueue(delayQueueBasePart.getRedissonClient(),topic + "-" + i));
        }
    }
    
    public void offer(String content,long delayTime, TimeUnit timeUnit){
        int index = isolationRegionSelector.getIndex();
        //拿取分片
        delayProduceQueueList.get(index).offer(content, delayTime, timeUnit);
    }
}
```

### 3.7 配置属性

```java
package com.taopiaopiao.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.concurrent.TimeUnit;

import static com.taopiaopiao.config.DelayQueueProperties.PREFIX;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 配置属性
 * @author: GGBOND
 **/
@Data
@ConfigurationProperties(prefix = PREFIX)
public class DelayQueueProperties {

    public static final String PREFIX = "delay.queue";
    
    /**
     * 从队列拉取数据的线程池中的核心线程数量，如果业务过慢可调大
     * */
    private Integer corePoolSize = 4;
    /**
     * 从队列拉取数据的线程池中的最大线程数量，如果业务过慢可调大
     * */
    private Integer maximumPoolSize = 4;
    
    /**
     * 从队列拉取数据的线程池中的最大线程回收时间
     * */
    private long keepAliveTime = 30;
    /**
     * 从队列拉取数据的线程池中的最大线程回收时间的时间单位
     * */
    private TimeUnit unit = TimeUnit.SECONDS;
    /**
     * 从队列拉取数据的线程池中的队列数量，如果业务过慢可调大
     * */
    private Integer workQueueSize = 256;
    
    /**
     * 延时队列的隔离分区数，延时有瓶颈时 可调大次数，但会增大redis的cpu消耗(同一个topic发送者和消费者的隔离分区数必须相同)
     * */
    private Integer isolationRegionCount = 5;
}
```

### 3.8 自动配置类

```java
package com.taopiaopiao.config;

import com.taopiaopiao.context.DelayQueueBasePart;
import com.taopiaopiao.context.DelayQueueContext;
import com.taopiaopiao.event.DelayQueueInitHandler;
import org.redisson.api.RedissonClient;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 延迟队列 配置
 * @author: GGBOND
 **/
@EnableConfigurationProperties(DelayQueueProperties.class)
public class DelayQueueAutoConfig {
    
    @Bean
    public DelayQueueInitHandler delayQueueInitHandler(DelayQueueBasePart delayQueueBasePart){
        return new DelayQueueInitHandler(delayQueueBasePart);
    }
   
    @Bean
    public DelayQueueBasePart delayQueueBasePart(RedissonClient redissonClient,DelayQueueProperties delayQueueProperties){
        return new DelayQueueBasePart(redissonClient,delayQueueProperties);
    }
  
    @Bean
    public DelayQueueContext delayQueueContext(DelayQueueBasePart delayQueueBasePart){
        return new DelayQueueContext(delayQueueBasePart);
    }
}
```

### 3.9 初始化处理器

```java
package com.taopiaopiao.event;

import cn.hutool.core.collection.CollectionUtil;
import com.taopiaopiao.context.DelayQueueBasePart;
import com.taopiaopiao.context.DelayQueuePart;
import com.taopiaopiao.core.ConsumerTask;
import com.taopiaopiao.core.DelayConsumerQueue;
import lombok.AllArgsConstructor;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;

import java.util.Map;

/**
 * @program: 高度还原淘票票网高并发实战项目
 * @description: 处理应用程序启动事件
 * @author: GGBOND
 **/
@AllArgsConstructor
public class DelayQueueInitHandler implements ApplicationListener<ApplicationStartedEvent> {
    
    private final DelayQueueBasePart delayQueueBasePart;
    
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {

        Map<String, ConsumerTask> consumerTaskMap = event.getApplicationContext().getBeansOfType(ConsumerTask.class);
        if (CollectionUtil.isEmpty(consumerTaskMap)) {
            return;
        }
        for (ConsumerTask consumerTask : consumerTaskMap.values()) {
            DelayQueuePart delayQueuePart = new DelayQueuePart(delayQueueBasePart,consumerTask);
            Integer isolationRegionCount = delayQueuePart.getDelayQueueBasePart().getDelayQueueProperties()
                    .getIsolationRegionCount();
            
            for(int i = 0; i < isolationRegionCount; i++) {
                DelayConsumerQueue delayConsumerQueue = new DelayConsumerQueue(delayQueuePart, 
                        delayQueuePart.getConsumerTask().topic() + "-" + i);
                delayConsumerQueue.listenStart();
            }
        }
    }
}
```

## 4. 使用示例

### 4.1 实现消费者任务

```java
@Component
public class OrderCancelConsumerTask implements ConsumerTask {
    
    @Override
    public void execute(String content) {
        // 处理订单取消逻辑
        System.out.println("取消订单: " + content);
    }
    
    @Override
    public String topic() {
        return "order_cancel";
    }
}
```

### 4.2 发送延迟消息

```java
@Service
public class OrderService {
    
    @Autowired
    private DelayQueueContext delayQueueContext;
    
    public void createOrder(Order order) {
        // 创建订单逻辑
        
        // 发送延迟消息，30分钟后检查订单是否支付
        delayQueueContext.sendMessage("order_cancel", 
            order.getOrderNo(), 30, TimeUnit.MINUTES);
    }
}
```

## 5. 工作原理详解

### 5.1 队列分片机制

通过[IsolationRegionSelector](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/core/IsolationRegionSelector.java#L11-L33)实现队列分片，将同一个topic的消息分散到多个队列中，提高并发处理能力。分片数可通过配置项`delay.queue.isolationRegionCount`进行调整。

### 5.2 消息发送流程

1. **获取分片** - 通过[DelayQueueProduceCombine](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/context/DelayQueueProduceCombine.java#L12-L34)获取分片索引
2. **发送消息** - 将消息发送到对应的分片队列中
3. **Redisson处理** - Redisson自动处理延迟逻辑，到期后将消息放入阻塞队列

### 5.3 消息消费流程

1. **应用启动** - [DelayQueueInitHandler](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/event/DelayQueueInitHandler.java#L15-L42)监听应用启动事件
2. **注册消费者** - 自动扫描并注册所有实现[ConsumerTask](file:///F%3A/MyProjects/taopiaopiao/taopiaopiao-redisson-framework/taopiaopiao-service-delay-queue-framework/src/main/java/com/taopiaopiao/core/ConsumerTask.java#L7-L20)接口的Bean
3. **启动监听** - 为每个分片启动独立的监听线程
4. **处理消息** - 从阻塞队列中取出消息并在线程池中执行消费者逻辑

### 5.4 线程模型

1. **监听线程** - 每个分片一个独立线程负责从阻塞队列中取数据
2. **处理线程池** - 使用配置化的线程池处理具体的业务逻辑
3. **线程隔离** - 监听线程和处理线程完全隔离，避免相互影响

## 6. 配置说明

```yaml
delay:
  queue:
    # 核心线程数
    core-pool-size: 4
    # 最大线程数
    maximum-pool-size: 4
    # 线程空闲回收时间
    keep-alive-time: 30
    # 时间单位
    unit: SECONDS
    # 工作队列大小
    work-queue-size: 256
    # 隔离分区数
    isolation-region-count: 5
```

## 7. 总结

淘票票项目的延迟队列机制具有以下特点：

1. **高性能** - 通过分片机制和线程池隔离实现高并发处理
2. **易用性** - 通过SPI机制简化消费者实现
3. **可配置** - 支持自定义线程池参数和分区数
4. **可靠性** - 基于Redisson实现，保证消息不丢失
5. **自动注册** - 应用启动时自动扫描并注册消费者任务

这套机制在订单超时处理、活动提醒等场景下能够发挥重要作用，是淘票票项目中保证系统稳定性和用户体验的关键技术之一。