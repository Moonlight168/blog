---
title: 操作系统原理
icon: /assets/icon/操作系统.png
---


## 进程与线程管理

### 进程与线程的区别是什么？

* **进程是资源分配的最小单位**，拥有独立内存
* **线程是 CPU 调度的最小单位**，共享进程内存
* 进程切换开销大，线程切换开销小
* 线程共享内存需要同步控制

### 为什么线程切换比进程切换快？

* **不需要切换页表和文件描述符等重资源**
* 线程共享进程地址空间，只需切换寄存器等少量状态
* 进程切换涉及更多内核数据结构恢复

### 进程和线程的区别是什么？

* **进程是资源分配单位**，有独立内存空间
* **线程是调度单位**，共享进程资源
* 进程切换开销大；线程切换开销小
* 一个进程崩溃不会影响其他进程，但线程会影响同进程所有线程

### 为什么要有线程？

* 线程更轻量，创建/上下文切换成本低
* 更适合 **并发、IO 密集、CPU 多核利用**
* 提高程序响应性（UI 主线程 / 工作线程）

### 什么是僵尸进程与孤儿进程？

* **僵尸进程**：子进程结束但父未 wait → 占用进程表项
* **孤儿进程**：父进程结束但子还在 → 被 init 接管
* 僵尸进程过多会耗尽 PID 资源

### 进程间通信（IPC）方式有哪些？用在哪里？

* **管道**：父子进程通信
* **消息队列**：结构化消息
* **共享内存**：最快，但需同步
* **信号量**：同步
* **信号**：事件通知
* **Socket**：跨机器通信（如微服务）


### 线程间通信方式有哪些？

* **锁（synchronized、ReentrantLock）**
* **条件变量（Condition）**
* **信号量（Semaphore）**
* **wait/notify**
* **原子类（AtomicInteger）**
* **ThreadLocal（不共享数据）**

### 线程安全如何保证？

* **互斥锁（synchronized/Lock）**
* **CAS + 原子类**
* **读写锁**
* **ThreadLocal**
* **不可变对象（final）**

### 什么是线程安全？如何保证？

* 多线程访问共享变量时结果正确
* **互斥锁**
* **读写锁**
* **CAS + 原子类**
* **不可变对象**
* **ThreadLocal**

## 锁机制

### 什么是自旋锁？什么时候使用？

* 拿不到锁时 **循环等待，不挂起线程**
* 适合锁持有时间 **非常短** 的场景
* 不适合长等待，会浪费 CPU

### 什么是死锁？四个必要条件是什么？

* 死锁：线程互相等待资源，无法继续执行
* **互斥**
* **占有并等待**
* **不可剥夺**
* **循环等待**

### 如何避免死锁？

* **统一加锁顺序（最常用）**
* **tryLock + 超时**
* **减少锁粒度**
* **资源预分配**
* **破坏循环等待条件**

### 什么是死锁？如何避免？

* 线程互相等待对方持有的资源，无法继续
* 避免方式：

    * **统一锁顺序**
    * **tryLock + 超时**
    * **减少锁粒度**
    * **使用无锁结构（CAS）**

# 内存管理

## 虚拟内存管理

### 什么是虚拟内存？

* 为每个进程提供 **独立、连续的虚拟地址空间**
* 基于 **分页机制**
* 作用：隔离、保护、支持大程序和换页

### 什么是虚拟内存？有什么用？

* 程序看到的是 **连续的虚拟地址空间**
* 作用：

    * **内存隔离**
    * **可运行大于物理内存的程序（换页）**
    * **安全保护**

## 内存分页机制

### 分页与分段的区别？

* 分页：**固定大小**，避免外碎片，现代主流
* 分段：**按逻辑划分**，大小不定，易碎片
* 现代 OS：段用于保护，实际管理主要靠分页

### 为什么多级页表能节省内存？

* 一级页表为整个虚拟空间分配映射，太大
* 多级页表 **按需创建**，未使用的区域不分配页表
* 显著减少无用页表项占用

## 缺页中断

### 什么是缺页中断？

* 访问的虚拟页不在物理内存
* CPU 触发缺页异常，OS 从磁盘加载
* 属于内核态操作，进程会短暂阻塞

### 什么是缺页中断？

* 访问的虚拟页不在内存中
* 触发缺页异常 → OS 将页从磁盘加载入内存
* 会导致上下文切换（慢）

## CPU缓存优化

### 什么是缓存行？为什么会导致伪共享？

* CPU 缓存以 **缓存行（通常 64B）** 为单位读写
* 多线程修改同一缓存行的不同变量 → 缓存不断失效
* 导致性能抖动（伪共享）

# 系统调用与用户态

## 用户态与内核态

### 用户态与内核态的区别是什么？

* 用户态权限低，禁止访问硬件
* 内核态权限高，可执行特权指令
* 内核态可直接与设备交互
* 切换通过系统调用、中断、异常触发

### 为什么要有用户态和内核态？

* 保护内核不被应用程序破坏
* 保证系统安全、稳定
* 普通程序无法直接访问硬件和内核数据结构

## 系统调用机制

### 什么是系统调用？

* 用户态访问内核功能的唯一方式
* 涉及 **用户态 → 内核态切换**
* 开销比普通函数调用大，因为需要陷入（trap）

### 为什么系统调用比函数调用慢？

* 需要进行 **用户态 → 内核态模式切换**
* 保存/恢复更多上下文
* 触发陷入（trap）机制

# 性能优化

## 上下文切换

### 什么是上下文切换？

* CPU 保存当前任务状态、恢复另一个任务状态
* 包括寄存器、PC、堆栈等内容
* 切换过多会降低系统吞吐性能

### 什么是上下文切换？为什么会慢？

* CPU 保存/恢复不同任务的执行状态
* 开销来自：

    * 保存寄存器、程序计数器
    * 切换页表、内存映射
    * CPU cache 失效

# I/O管理

## 缓冲区管理

### 什么是缓冲区？为什么需要？

* 用于临时存储 IO 数据
* 作用：

    * **减少系统调用次数（降低开销）**
    * **平滑 IO 峰值**
    * **提高整体吞吐量**

## I/O多路复用

### select、poll、epoll 区别？

* **select**：监听数量有限制（1024）
* **poll**：无数量限制，但每次扫描全部 FD
* **epoll**：事件驱动，只监听变化的 FD（性能最高）

# 中断机制

## 中断基础

### 什么是中断？

* 硬件或软件向 CPU 发出的事件通知
* 异步发生，CPU 会保存当前状态并处理中断
* 用于 IO、时钟、系统调用等

