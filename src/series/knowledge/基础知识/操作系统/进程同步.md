---
title: 进程同步
order: 5
---

# 第5章 进程同步

## 什么是临界区？临界区管理的四个要求是什么？

**临界区**是一段访问共享资源的程序代码。

* **互斥**：最多一个进程在临界区
* **进步**：临界区空的时必须让进
* **有限等待**：等待时间有上界
* **与CPU速度无关**：不依赖硬件速度

## 进程间同步与互斥的区别

* **同步**：协作进程间有序执行（如生产者-消费者）
* **互斥**：多个进程竞争同一资源（如打印队列）
* 互斥是同步的特殊情况

## 什么是信号量？P/V操作的作用是什么？

**信号量**是表示资源数量的非负整数变量。

* **P操作（wait）**：申请资源，s-1，若s<0阻塞
* **V操作（signal）**：释放资源，s+1，若s<=0唤醒

## 经典同步问题

### 生产者-消费者问题
* 同步关系：生产者不能超过缓冲区容量，消费者不能消费空缓冲区
* 解决：用三个信号量（空位、满位、互斥锁）

### 读者-写者问题
* 多个读者可同时读，写者排斥其他读者和写者
* 解决：用读写锁（RW Lock）

### 哲学家就餐问题
* 防止死锁：允许最多4个哲学家同时拿筷子，或奇偶位分别拿筷子

## 管程（Monitor）是什么？

管程是封装了共享变量及其操作的高级同步原语：
* 进程只能通过管程提供的过程访问共享数据
* 管程保证在同一时刻只有一个进程在管程内活动
* Java中的synchronized关键字和wait/notify机制基于管程思想

## 系统调用与用户态

### 用户态与内核态的区别是什么？

* 用户态权限低，禁止访问硬件
* 内核态权限高，可执行特权指令
* 内核态可直接与设备交互
* 切换通过系统调用、中断、异常触发

### 为什么要有用户态和内核态？

* 保护内核不被应用程序破坏
* 保证系统安全、稳定
* 普通程序无法直接访问硬件和内核数据结构

### 什么是系统调用？

* 用户态访问内核功能的唯一方式
* 涉及 **用户态 → 内核态切换**
* 开销比普通函数调用大，因为需要陷入（trap）

### 为什么系统调用比函数调用慢？

* 需要进行 **用户态 → 内核态模式切换**
* 保存/恢复更多上下文
* 触发陷入（trap）机制

## 锁和同步

### 什么是公平锁与非公平锁？

* 公平锁：**按申请顺序**获取锁
* 非公平锁：**可能插队**，性能更好
* Java ReentrantLock 可以选择

### 偏向锁是什么？消除锁是什么？

* **偏向锁**：第一个获取锁的线程，之后操作无需加锁
* **消除锁**：编译器**消除不可能竞争的锁**

### CAS 与互斥锁的区别？

* CAS：**无锁**，compare and swap，循环尝试
* 互斥锁：**有锁**，阻塞/挂起线程
* CAS 适合轻量竞争

### 无锁编程是什么？

* 使用 **CAS（Compare-and-Swap）** 替代锁
* 线程**无需阻塞**，自旋重试
* 适合**低冲突、高并发**场景