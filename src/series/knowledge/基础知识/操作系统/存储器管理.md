---
title: 存储器管理
order: 6
---

# 第6章 存储器管理

## 程序的装入有哪几种方式？优缺点是什么？

* **绝对装入**：程序装入固定内存地址
  * 优点：执行快，无需重定位
  * 缺点：无法实现内存共享和虚拟化
* **可重定位装入（静态重定位）**：装入时完成地址转换
  * 优点：实现简单
  * 缺点：装入后无法移动，需要连续内存空间
* **动态运行时装入（动态重定位）**：执行时才转换地址
  * 优点：支持程序换入换出，便于内存共享
  * 缺点：需要硬件支持（MMU）

## 程序的链接有哪几种方式？优缺点是什么？

* **静态链接**：编译链接时合并所有目标文件
  * 优点：执行快，无额外开销
  * 缺点：程序文件大，内存利用率低
* **装入时动态链接**：装入内存时边装入边链接
  * 优点：共享库，内存利用率高
  * 缺点：装入时间长
* **运行时动态链接**：执行时才链接库文件
  * 优点：灵活性最高，支持动态加载
  * 缺点：运行时链接开销

## 内存分配方式有哪些？各自的优缺点？

* **连续分配**：
  * 单一连续分配：简单，但利用率低
  * 固定分区分配：简单，但会产生内碎片
  * 动态分区分配：利用率高，但会产生外碎片
* **分页管理**：无内碎片，但页表开销大
* **分段管理**：符合程序逻辑，便于共享和保护
* **段页式管理**：结合分页和分段优点，但管理复杂

## 分页和分段存储管理的区别

* **分页**：
  * 按固定大小分页，不考虑程序逻辑
  * 页内无碎片，页间可能有外碎片
  * 地址空间是一维的
* **分段**：
  * 按程序逻辑划分，大小不固定
  * 便于共享和保护
  * 地址空间是二维的（段号+段内偏移）

## 页面置换算法有哪些？

* **最佳置换算法（OPT）**：选择未来最长时间不用的页面置换（理论最优）
* **先进先出（FIFO）**：队列实现，简单但可能产生Belady现象
* **最近最久未使用（LRU）**：性能接近OPT，开销较大
* **时钟算法（Clock）**：LRU的近似实现，效率高
* **改进的时钟算法**：同时考虑页面修改状态

## 虚拟内存管理

### 什么是虚拟内存？

* 为每个进程提供 **独立、连续的虚拟地址空间**
* 基于 **分页机制**
* 作用：隔离、保护、支持大程序和换页

### 什么是虚拟内存？有什么用？

* 程序看到的是 **连续的虚拟地址空间**
* 作用：
  * **内存隔离**
  * **可运行大于物理内存的程序（换页）**
  * **安全保护**

## 内存分页机制

### 分页与分段的区别？

* 分页：**固定大小**，避免外碎片，现代主流
* 分段：**按逻辑划分**，大小不定，易碎片
* 现代 OS：段用于保护，实际管理主要靠分页

### 为什么多级页表能节省内存？

* 一级页表为整个虚拟空间分配映射，太大
* 多级页表 **按需创建**，未使用的区域不分配页表
* 显著减少无用页表项占用

## 缺页中断

### 什么是缺页中断？

* 访问的虚拟页不在物理内存
* CPU 触发缺页异常，OS 从磁盘加载
* 属于内核态操作，进程会短暂阻塞

### 什么是缺页中断？

* 访问的虚拟页不在内存中
* 触发缺页异常 → OS 将页从磁盘加载入内存
* 会导致上下文切换（慢）

## CPU缓存优化

### 什么是缓存行？为什么会导致伪共享？

* CPU 缓存以 **缓存行（通常 64B）** 为单位读写
* 多线程修改同一缓存行的不同变量 → 缓存不断失效
* 导致性能抖动（伪共享）