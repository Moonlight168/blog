---
title: MySQL
date: 2025-05-21
icon: /assets/icon/mysql.png
---
## 说一下你对MySQL的理解？

### 什么是 MySQL？

* **MySQL 是目前最流行的关系型数据库管理系统（RDBMS）**

### 关系数据库 vs 非关系数据库
riyi
| 特性 | **关系型数据库（MySQL）** | **非关系型数据库（NoSQL）** |
|------|------------------------|------------------------|
| **数据存储** | 表结构（行和列），预定义模式 | 文档、键值对、图、列族等灵活结构 |
| **事务支持** | **强一致性**（ACID特性） | **最终一致性**（CAP定理） |
| **查询语言** | SQL（标准化） | 各有特色（MongoDB-JS、Redis-命令等） |
| **扩展性** | **垂直扩展**（增加硬件性能） | **水平扩展**（分布式，加机器） |
| **适用场景** | 复杂关系查询、银行交易、ERP系统 | 高并发读写、大数据处理、快速迭代 |
| **数据结构** | 结构化、半结构化数据 | **非结构化**、多样化数据 |
| **示例** | MySQL、PostgreSQL、Oracle | MongoDB、Redis、Cassandra |

### 为什么大家都用它？

* **数据一致性**：事务保证数据准确性
* **查询能力强**：SQL语句支持复杂关联查询  
* **生态成熟**：工具丰富，社区支持完善
* **成本低**：开源免费


## MySQL 的事务四大特性（ACID）是什么？

* **原子性（Atomicity）**：事务要么全成功要么全失败。
* **一致性（Consistency）**：执行前后数据保持一致。
* **隔离性（Isolation）**：事务间互不干扰。
* **持久性（Durability）**：事务提交后数据永久保存。

## 索引有哪些类型？什么时候使用？

* **主键索引、唯一索引、普通索引、联合索引**。
* 适用于频繁作为 WHERE、JOIN、ORDER BY 条件的字段；不要给频繁变动的字段建索引。

## MySQL 的存储引擎有哪些？它们之间有什么区别？默认使用哪个？

**回答：**

常见存储引擎：

* **InnoDB**：支持事务、行级锁、外键，支持 MVCC，适合高并发，**MySQL 默认引擎**。
* **MyISAM**：不支持事务和外键，表级锁，读性能好，占用空间小，适合读多写少场景。
* **Memory**：数据存储在内存中，速度快，断电丢失数据，适合临时表、缓存。
* **Archive**：只支持插入和查询，压缩存储，适合日志、归档。
* **CSV**：以 CSV 文件存储，方便与其他工具交换数据，不支持索引。

区别：

* **事务支持**：InnoDB 支持，MyISAM/Memory 不支持。
* **锁机制**：InnoDB 行级锁，MyISAM 表级锁。
* **存储方式**：InnoDB 是聚簇索引，MyISAM 使用非聚簇索引。
* **数据安全性**：InnoDB 更安全，支持崩溃恢复；MyISAM 容易损坏。

**默认存储引擎：InnoDB**（MySQL 5.5 之后）

## InnoDB 是如何存储数据的？

**回答：**

1. **页（Page）为最小存储单位**

   * 默认页大小 16KB。
   * 数据存储在页中，页之间通过双向链表连接。

2. **行（Row）存储**

   * InnoDB 是 **面向行的存储引擎**。
   * 每一行数据存储在页中，行溢出时会用溢出页。

3. **表空间（Tablespace）**

   * InnoDB 把数据存储在表空间中（共享表空间 ibdata 或者独立 .ibd 文件）。

4. **索引组织表（Clustered Index）**

   * InnoDB 的表数据按 **主键顺序存储**，表数据和主键索引存储在同一棵 B+Tree 中。
   * 叶子节点存储整行数据。
   * 如果没有主键，会选择唯一索引或自动生成一个隐藏主键。

5. **辅助索引（二级索引）**

   * 二级索引叶子节点存储的是 **主键值**，再通过主键索引找到整行数据（二次查找）。

👉 **总结**：
InnoDB 使用 **页（16KB）作为最小存储单位**，数据以 **聚簇索引（B+Tree）** 形式存储在表空间中，**主键索引存整行数据，二级索引存主键值**。

## 二、SQL语句

## 如何优化 SQL 性能？

**回答：**

* 使用合适索引，避免全表扫描；
* 避免 SELECT \*，只查必要字段；
* 使用 `EXPLAIN` 查看执行计划；
* 避免子查询，尽量用 JOIN；
* 控制返回行数，分页查询要加 LIMIT。

## `OVER` 与 `GROUP BY` 的区别？

**一、核心区别**

| 特性         | `GROUP BY`                     | `OVER`（窗口函数）               |
| ---------- | ------------------------------ | -------------------------- |
| **作用方式**   | 对数据**分组后聚合**，每组只保留一行结果         | 对每一行数据进行**计算，不减少行数**       |
| **返回结果行数** | 通常比原表**少**，按组聚合                | 与原表行数**相同**，每行追加计算结果       |
| **适用场景**   | 仅关心每组的聚合结果，如“每个部门的总人数”         | 需保留明细数据并附带分析值，如“每人所在部门总人数” |
| **列限制**    | `SELECT`中只能出现`GROUP BY`字段或聚合函数 | `SELECT`中可使用任意字段           |


**二、举例说明**

#### 1. `GROUP BY` 示例：统计每个部门总工资

```sql
SELECT department_id, SUM(salary) AS total_salary
FROM employees
GROUP BY department_id;
```

* 每个部门输出一行，展示该部门工资总和。
* 结果行数 = 部门数。

GROUP BY 的聚合逻辑：

当你使用GROUP BY player_id时，SQL 会将每个玩家的所有记录合并为一个分组。

对于event_date列，你没有指定聚合函数（如 MIN、MAX），因此数据库会从分组中随机选择一个值作为结果，而不是按照日期排序后取第一个。


#### 2. `OVER` 示例：在每行展示“该员工所在部门的总工资”

```sql
SELECT employee_name, department_id,
       SUM(salary) OVER (PARTITION BY department_id) AS dept_total_salary
FROM employees;
```

* 每行保留员工信息，并显示他所在部门的总工资。
* 结果行数 = 原始员工数。

## sql语句关键字顺序？何其执行时的顺序？
**回答：**

``` sql
语句关键字顺序:
SELECT [DISTINCT] select_list
FROM table_expression
[WHERE condition]
[GROUP BY grouping_expression]
[HAVING group_condition]
[WINDOW window_definition]
[ORDER BY sort_expression]
[LIMIT | OFFSET row_count]

执行时的顺序:
-- 1. FROM 和 JOIN
FROM Employees e
JOIN Salaries s ON e.employee_id = s.employee_id
-- 2. WHERE
WHERE e.hire_date > '2020 - 01 - 01'
-- 3. GROUP BY
GROUP BY e.department_id
-- 4. HAVING
HAVING AVG(s.salary) > 50000
-- 5. SELECT
SELECT e.department_id, AVG(s.salary) AS avg_salary
-- 6. ORDER BY
ORDER BY avg_salary DESC;
```

## 一条 SQL 在 MySQL 中的执行过程?

**回答：**

1. **连接器**

   * 客户端先通过连接器与 MySQL 建立连接（TCP）。
   * 如果有连接池，会从池中获取。
   * 建立连接后进行权限认证（账号、密码、权限）。

2. **查询缓存（MySQL 8.0 已移除）**

   * 在 5.7 及之前版本，MySQL 会先检查缓存是否有相同 SQL 的结果。
   * 有则直接返回，没有则进入解析阶段。

3. **解析器**

   * 对 SQL 语句进行词法分析、语法分析。
   * 检查 SQL 语法是否正确，解析出 SQL 的语义，生成解析树。

4. **优化器**

   * 对解析树进行优化，选择合适的执行计划。
   * 比如：选择哪个索引、使用全表扫描还是索引扫描、确定表连接顺序。

5. **执行器**

   * 根据优化器生成的执行计划，调用存储引擎接口执行 SQL。
   * 判断用户是否有权限操作相关表和字段。

6. **存储引擎**

   * InnoDB、MyISAM 等存储引擎真正执行数据的读写操作。
   * InnoDB 会用到 **Buffer Pool、redo log、undo log** 等机制保证事务和持久性。

7. **返回结果**

   * 存储引擎将结果返回给执行器 → 执行器返回给客户端。

👉 **总结**：
客户端 → 连接器 → 查询缓存 → 解析器 → 优化器 → 执行器 → 存储引擎 → 返回结果?

## 三、线程池
## 为什么数据库连接很消耗资源？

1. **建立连接开销大**：需要进行网络通信（TCP/SSL握手）、身份认证、资源分配。
2. **连接占用资源**：数据库端要维护会话信息、内存、线程/进程句柄。
3. **连接保持有成本**：需要检测连接状态，空闲连接也会消耗内存和线程。
4. **连接关闭有开销**：释放资源需要时间，频繁创建/销毁连接影响性能。

因此，数据库连接属于重量级资源，通常通过**连接池**来复用以降低开销。


## 什么是数据库连接池？使用过哪些？

**回答：**
连接池通过复用连接降低连接开销，提高性能。常见连接池：

* HikariCP（推荐，轻量高效）
* Druid（阿里开源，功能全面）
* C3P0（较老，配置复杂）


## 为什么连接池可以降低开销？

1. **避免频繁建立/关闭连接**：

    * 连接池在启动时就提前创建一定数量的连接并放入池中。
    * 应用请求数据库时直接复用已有连接，减少频繁的网络通信、身份认证、资源分配开销。

2. **复用连接资源**：

    * 同一个连接可以被多个请求依次使用。
    * 避免了数据库端维护过多短生命周期连接导致的资源浪费。

3. **统一管理连接数量**：

    * 可以设置最大连接数，防止过多连接耗尽数据库资源。
    * 空闲时可以回收或保活，避免资源闲置或失效。


## 连接池是如何实现的？

1. **初始化**：启动时预先创建一定数量的数据库连接（minIdle / initialSize）。
2. **获取连接**：应用请求时，从池中取出可用连接，而不是重新建立。
3. **使用连接**：应用执行 SQL 操作。
4. **归还连接**：操作完成后，将连接放回池中，供下次复用，而不是关闭。
5. **池管理机制**：

    * **最大连接数**：限制并发连接上限，保护数据库。
    * **空闲检测**：定期检测连接是否可用，不可用则移除。
    * **连接保活**：执行心跳 SQL（如 `SELECT 1`）保持连接可用。
    * **等待队列**：当连接用尽时，新请求进入队列等待，避免直接报错。

常见实现：**HikariCP、Druid、C3P0、DBCP**。
