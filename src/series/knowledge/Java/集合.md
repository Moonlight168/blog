---
title: 集合
date: 2025-05-17
icon: /assets/icon/集合.png
---
## Java中有哪些集合？
**回答：**
![img.png](imges/img.png)


## List, Set, Queue, Map 有什么区别？

**回答：**

* **List**：有序、可重复，如 `ArrayList`、`LinkedList`
* **Set**：无序、不可重复，如 `HashSet`、`TreeSet`
* **Queue**：队列结构，先进先出，如 `LinkedList`、`PriorityQueue`
* **Map**：键值对存储，键唯一，如 `HashMap`、`TreeMap`


## ArrayList 和 数组 有什么区别？

**回答：**

* **数组**：长度固定，类型单一，性能高
* **ArrayList**：长度可变，提供丰富的API，底层基于数组实现
* **适用场景**：数组适合性能敏感、长度固定的场景，ArrayList 更适合动态增删数据的场景

## 为什么要使用集合，如何选择？

**一、使用集合的原因**

1. **动态扩容**：自动扩展容量，无需预设大小
2. **功能丰富**：提供常用操作方法
3. **类型安全**：使用泛型，避免类型错误
4. **高性能**：Java 集合经过优化，效率高

**二、选择集合的方法**

1. **按数据特点**：

    * 允许重复：用 `List`（`ArrayList`、`LinkedList`）
    * 不允许重复：用 `Set`（`HashSet`、`TreeSet`）
    * 键值对存储：用 `Map`（`HashMap`、`TreeMap`）
2. **按线程环境**：

    * 单线程：用非同步集合（`ArrayList`、`HashMap`）
    * 多线程：用同步集合（`Vector`、`ConcurrentHashMap`）


## ArrayList 的扩容机制？

**回答：**

1. **初始容量**：默认初始容量为 0（JDK 8+ 后），首次添加元素时扩容为 10。
2. **扩容触发条件**：当元素数量超过当前容量时触发扩容。
3. **扩容公式**：新容量 = **原容量 \* 1.5**（如 10 → 15 → 22 → 33）。
4. **数组复制**：扩容后通过 `Arrays.copyOf()` 复制数组，性能开销较大。
5. **优化**：可通过 `new ArrayList<>(初始容量)` 手动预分配容量，避免频繁扩容。

**面试答题模板**：

```text
1. 初始容量：默认 0，首次添加扩容为 10。
2. 触发条件：元素数量超过当前容量。
3. 扩容公式：原容量 * 1.5。
4. 数组复制：使用 `Arrays.copyOf()`，性能开销大。
5. 优化：预分配容量提升性能。
```

**源码验证（JDK 17）**
```java
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5倍
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity; // 若1.5倍不够，直接用minCapacity
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity); // 处理超大容量
    elementData = Arrays.copyOf(elementData, newCapacity); // 复制数组
}
```

## Comparable 和 Comparator 的区别

**回答：**

#### 1. 核心区别

| **维度**   | **Comparable**            | **Comparator**          |
| -------- | ------------------------- | ----------------------- |
| **接口定义** | `compareTo()` 方法，定义自然排序规则 | `compare()` 方法，定义临时排序规则 |
| **耦合度**  | 排序与类绑定，侵入性强               | 排序与类分离，解耦性好             |
| **使用场景** | 类的默认排序方式                  | 需要额外排序规则（如逆序、按其他字段排序）   |

#### 2. 代码对比

**Comparable 示例**

```java
public class Person implements Comparable<Person> {
    @Override
    public int compareTo(Person other) {
        return this.age - other.age;  // 按年龄升序
    }
}
Collections.sort(people);  // 自动按默认规则排序
```

**Comparator 示例**

```java
Comparator<Person> ageComparator = (p1, p2) -> p1.getAge() - p2.getAge();  // 按年龄升序
Collections.sort(people, ageComparator);  // 按指定规则排序
```

#### 3. 关键方法

* **Comparable**：`int compareTo(T o)`
* **Comparator**：`int compare(T o1, T o2)`

#### 4. 优缺点

| **接口**         | **优点**      | **缺点**              |
| -------------- | ----------- | ------------------- |
| **Comparable** | 直接排序，简单易用   | 排序规则固定，灵活性差         |
| **Comparator** | 多维度排序，不修改原类 | 需要额外的 Comparator 实例 |

#### 5. 应用场景

* **Comparable**：自定义类的默认排序，常用于数字、字符串等基本类型
* **Comparator**：临时排序、按多个规则排序，或对未实现 `Comparable` 的类排序

#### 6. 面试高频问题

**问**：“如何对一个没有实现 `Comparable` 的类排序？”

**答**：创建外部 `Comparator`，或者修改类实现 `Comparable`。
