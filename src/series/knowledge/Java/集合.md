---
title: 集合
date: 2025-05-17
icon: /assets/icon/集合.png
---
## Java中有哪些集合？
**回答：**
![img.png](imges/img.png)


## List, Set, Queue, Map 有什么区别？

**回答：**

* **List**：有序、可重复，如 `ArrayList`、`LinkedList`
* **Set**：无序、不可重复，如 `HashSet`、`TreeSet`
* **Queue**：队列结构，先进先出，如 `LinkedList`、`PriorityQueue`
* **Map**：键值对存储，键唯一，如 `HashMap`、`TreeMap`


## ArrayList 和 数组 有什么区别？

**回答：**

* **数组**：长度固定，类型单一，性能高
* **ArrayList**：长度可变，提供丰富的API，底层基于数组实现
* **适用场景**：数组适合性能敏感、长度固定的场景，ArrayList 更适合动态增删数据的场景

## 为什么要使用集合，如何选择？

**一、使用集合的原因**

1. **动态扩容**：自动扩展容量，无需预设大小
2. **功能丰富**：提供常用操作方法
3. **类型安全**：使用泛型，避免类型错误
4. **高性能**：Java 集合经过优化，效率高

**二、选择集合的方法**

1. **按数据特点**：

    * 允许重复：用 `List`（`ArrayList`、`LinkedList`）
    * 不允许重复：用 `Set`（`HashSet`、`TreeSet`）
    * 键值对存储：用 `Map`（`HashMap`、`TreeMap`）
2. **按线程环境**：

    * 单线程：用非同步集合（`ArrayList`、`HashMap`）
    * 多线程：用同步集合（`Vector`、`ConcurrentHashMap`）


## ArrayList 的扩容机制？

**回答：**

1. **初始容量**：默认初始容量为 0（JDK 8+ 后），首次添加元素时扩容为 10。
2. **扩容触发条件**：当元素数量超过当前容量时触发扩容。
3. **扩容公式**：新容量 = **原容量 \* 1.5**（如 10 → 15 → 22 → 33）。
4. **数组复制**：扩容后通过 `Arrays.copyOf()` 复制数组，性能开销较大。
5. **优化**：可通过 `new ArrayList<>(初始容量)` 手动预分配容量，避免频繁扩容。

**面试答题模板**：

```text
1. 初始容量：默认 0，首次添加扩容为 10。
2. 触发条件：元素数量超过当前容量。
3. 扩容公式：原容量 * 1.5。
4. 数组复制：使用 `Arrays.copyOf()`，性能开销大。
5. 优化：预分配容量提升性能。
```

**源码验证（JDK 17）**
```java
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5倍
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity; // 若1.5倍不够，直接用minCapacity
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity); // 处理超大容量
    elementData = Arrays.copyOf(elementData, newCapacity); // 复制数组
}
```

## Comparable 和 Comparator 的区别

**回答：**

#### 1. 核心区别

| **维度**   | **Comparable**            | **Comparator**          |
| -------- | ------------------------- | ----------------------- |
| **接口定义** | `compareTo()` 方法，定义自然排序规则 | `compare()` 方法，定义临时排序规则 |
| **耦合度**  | 排序与类绑定，侵入性强               | 排序与类分离，解耦性好             |
| **使用场景** | 类的默认排序方式                  | 需要额外排序规则（如逆序、按其他字段排序）   |

#### 2. 代码对比

**Comparable 示例**

```java
public class Person implements Comparable<Person> {
    @Override
    public int compareTo(Person other) {
        return this.age - other.age;  // 按年龄升序
    }
}
Collections.sort(people);  // 自动按默认规则排序
```

**Comparator 示例**

```java
Comparator<Person> ageComparator = (p1, p2) -> p1.getAge() - p2.getAge();  // 按年龄升序
Collections.sort(people, ageComparator);  // 按指定规则排序
```

#### 3. 关键方法

* **Comparable**：`int compareTo(T o)`
* **Comparator**：`int compare(T o1, T o2)`

#### 4. 优缺点

| **接口**         | **优点**      | **缺点**              |
| -------------- | ----------- | ------------------- |
| **Comparable** | 直接排序，简单易用   | 排序规则固定，灵活性差         |
| **Comparator** | 多维度排序，不修改原类 | 需要额外的 Comparator 实例 |

#### 5. 应用场景

* **Comparable**：自定义类的默认排序，常用于数字、字符串等基本类型
* **Comparator**：临时排序、按多个规则排序，或对未实现 `Comparable` 的类排序

#### 6. 面试高频问题

**问**：“如何对一个没有实现 `Comparable` 的类排序？”

**答**：创建外部 `Comparator`，或者修改类实现 `Comparable`。


## 为什么泛型不能直接使用基本类型？那如何在泛型中使用基本类型？

**回答：**

1. **原因**：

    * **Java 泛型使用类型擦除机制**：在编译时，泛型类型被擦除，转换为 `Object` 类型。由于基本类型（如 `int`, `char`）不是对象，无法作为泛型参数。
    * **类型安全**：泛型要求类型参数必须是类类型，而基本类型不是类，因此无法直接使用。

2. **如何使用基本类型**：

    * **使用包装类**：Java 提供了基本类型的包装类（如 `Integer`、`Double`、`Character`），可以使用这些包装类作为泛型类型。

      ```java
      List<Integer> list = new ArrayList<>();
      list.add(10);  // 使用包装类 Integer
      ```
    * **自动装箱与拆箱**：Java 自动将基本类型转换为包装类，或将包装类转换回基本类型，无需显式转换。


## Java中的类型擦除是什么？这样做的目的和后果是什么？

#### **1. 类型擦除定义**

* 编译器将泛型类型参数替换为上限类型（通常是`Object`，若有显式边界则为边界类型）。
* 运行时泛型类型信息被移除，`List<Integer>` 和 `List<String>` 在运行时都为 `List`。

#### **2. 擦除规则**

* **无边界泛型**：擦除为 `Object`。

  ```java
  class Box<T> { private T value; } // 编译后：private Object value;
  ```
* **有边界泛型**：擦除为边界类型。

  ```java
  class Box<T extends Number> { private T value; } // 编译后：private Number value;
  ```

#### **3. 类型擦除目的**

* **保持二进制兼容性**：确保泛型代码与老版本代码兼容。
* **简化实现**：避免为每个泛型类型生成单独的类，减少字节码大小。

#### **4. 后果**

* **运行时无法获取泛型类型信息**：`List<Integer>` 和 `List<String>` 运行时无法区分。
* **不能创建泛型数组**：如 `new List<Integer>[10]` 编译错误。
* **基本类型不能作为泛型类型**：如 `List<int>` 编译错误，需使用包装类。
* **静态成员不能引用泛型参数**：如 `private static T value;` 编译错误。

#### **5. 解决运行时无法获取泛型类型信息的方式**

* **反射**：通过反射获取泛型类型信息，例如使用 `getGenericSuperclass()` 获取类的泛型类型。

  ```java
  class Box<T> {}
  Box<Integer> box = new Box<>();
  Type type = box.getClass().getGenericSuperclass(); // 获取泛型类型
  System.out.println(type); // 输出 Box<Integer>
  ```

* **通配符**：使用通配符（`?`）来处理不同类型的泛型参数，配合反射操作实现类型获取。

  ```java
  List<?> list = new ArrayList<>();
  Type type = list.getClass().getGenericSuperclass(); // 获取 List<?> 的类型信息
  System.out.println(type); // 输出 List
  ```
#### **常见面试问题**

* **Q**：为什么选择类型擦除？

    * **A**：为了兼容老版本代码，避免修改现有类库。
* **Q**：类型擦除带来什么问题？

    * **A**：无法区分泛型类型、无法创建泛型数组、基本类型不能作为泛型。
