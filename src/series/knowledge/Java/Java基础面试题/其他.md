---
order: 15
---
# 其他
## 有一个学生类，想按照分数排序，再按学号排序，应该怎么做？
可通过**实现Comparable接口**（自然排序）或**使用Comparator接口**（定制排序）实现，推荐使用`Comparable`接口，让学生类自身具备排序能力，代码如下：

### 方法1：实现Comparable接口（推荐，自然排序）
让`Student`类实现`java.lang.Comparable`接口，重写`compareTo`方法，定义"先按分数排序，分数相同则按学号排序"的逻辑：
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Student implements Comparable<Student> {
    private int id; // 学号
    private int score; // 分数

    // 构造方法
    public Student(int id, int score) {
        this.id = id;
        this.score = score;
    }

    // 重写compareTo：定义排序规则
    @Override
    public int compareTo(Student other) {
        // 1. 先按分数降序排序（分数高的在前）
        if (this.score != other.score) {
            // Integer.compare(a, b)：a > b 返回1，a < b 返回-1，相等返回0
            // 降序：用other.score - this.score（或Integer.compare(other.score, this.score)）
            return Integer.compare(other.score, this.score);
        }
        // 2. 分数相同，按学号升序排序（学号小的在前）
        else {
            return Integer.compare(this.id, other.id);
        }
    }

    // toString：方便打印
    @Override
    public String toString() {
        return "Student{id=" + id + ", score=" + score + "}";
    }

    // 测试
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(2, 90)); // 学号2，分数90
        students.add(new Student(1, 95)); // 学号1，分数95
        students.add(new Student(3, 90)); // 学号3，分数90

        // 调用Collections.sort()，自动使用compareTo方法排序
        Collections.sort(students);

        // 输出结果：[Student{id=1, score=95}, Student{id=2, score=90}, Student{id=3, score=90}]
        System.out.println(students);
    }
}
```

### 方法2：使用Comparator接口（定制排序，灵活）
若不想修改`Student`类（如类已固化），可在排序时传入`Comparator`对象，定制排序规则：
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Student {
    private int id;
    private int score;

    public Student(int id, int score) {
        this.id = id;
        this.score = score;
    }

    // getter方法（Comparator需获取属性）
    public int getId() { return id; }
    public int getScore() { return score; }

    @Override
    public String toString() {
        return "Student{id=" + id + ", score=" + score + "}";
    }

    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(2, 90));
        students.add(new Student(1, 95));
        students.add(new Student(3, 90));

        // 传入Comparator，定制排序规则
        Collections.sort(students, new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                // 先按分数降序
                if (s1.getScore() != s2.getScore()) {
                    return Integer.compare(s2.getScore(), s1.getScore());
                }
                // 再按学号升序
                else {
                    return Integer.compare(s1.getId(), s2.getId());
                }
            }
        });

        // 输出结果与方法1一致
        System.out.println(students);
    }
}
```

### 关键说明
- **排序方向**：`Integer.compare(a, b)`返回正数表示a > b，若需降序，交换a和b的位置（如`Integer.compare(b, a)`）。
- **稳定性**：两种方法均为稳定排序，即分数和学号都相同的学生，排序后相对位置不变。
- **Java 8+简化**：可使用Lambda表达式简化`Comparator`，如`(s1, s2) -> { ... }`，代码更简洁。

## Native方法解释一下
在Java中，`native`方法是一种特殊方法，允许Java代码调用**外部本地代码**（如C、C++编写的代码），实现Java与其他语言的交互，弥补Java在底层操作（如硬件访问、操作系统API调用）上的不足。

### 1. Native方法的特点
- **无Java实现体**：`native`方法的声明仅包含方法签名，无方法体（用`native`关键字标记），实现逻辑在外部本地代码中。
- **依赖本地库**：`native`方法的实现需编译为动态链接库（Windows下为`.dll`，Linux下为`.so`，macOS下为`.dylib`），Java程序通过加载本地库调用方法。
- **跨语言交互**：主要用于Java与C/C++交互，也可用于调用其他语言（如通过C++桥接Python、Rust代码）。

### 2. Native方法的使用步骤
以Java调用C++代码为例，完整流程如下：

#### 步骤1：定义Java类，声明native方法
```java
// NativeExample.java
public class NativeExample {
    // 声明native方法：无方法体，用native关键字标记
    public native void sayHello(String name);

    // 加载本地库（静态代码块：类加载时执行）
    static {
        // 加载名为"NativeLib"的本地库（Windows下为NativeLib.dll，Linux下为libNativeLib.so）
        System.loadLibrary("NativeLib");
    }

    // 测试
    public static void main(String[] args) {
        NativeExample example = new NativeExample();
        example.sayHello("Alice"); // 调用native方法
    }
}
```

#### 步骤2：生成C/C++头文件
使用JDK自带的`javah`工具（Java 8及以下），根据Java类生成C/C++头文件，头文件包含`native`方法的函数原型。  
**命令**：
```bash
# 编译Java类为.class文件
javac NativeExample.java
# 生成头文件（生成NativeExample.h）
javah -jni NativeExample
```
生成的`NativeExample.h`关键内容：
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class NativeExample */

#ifndef _Included_NativeExample
#define _Included_NativeExample
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     NativeExample
 * Method:    sayHello
 * Signature: (Ljava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_NativeExample_sayHello
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```
- `JNIEXPORT`和`JNICALL`：JNI（Java Native Interface）定义的宏，确保函数能被Java虚拟机识别。
- `Java_NativeExample_sayHello`：函数名格式为`Java_包名_类名_方法名`（无包名时直接为`Java_类名_方法名`）。
- 参数：`JNIEnv*`（JNI环境指针，用于调用JNI函数）、`jobject`（调用方法的Java对象实例，对应`this`）、`jstring`（Java的`String`类型在JNI中的映射类型）。

#### 步骤3：编写C/C++实现代码
创建`NativeExample.cpp`，实现头文件中声明的函数，通过JNI函数与Java交互（如将`jstring`转换为C++的`string`）：
```cpp
// NativeExample.cpp
#include "NativeExample.h"
#include <iostream>
#include <string>

// 实现native方法
JNIEXPORT void JNICALL Java_NativeExample_sayHello
  (JNIEnv *env, jobject obj, jstring name) {
    // 1. 将Java的jstring转换为C++的const char*
    const char* cName = env->GetStringUTFChars(name, NULL);
    if (cName == NULL) {
        return; // 内存不足，转换失败
    }

    // 2. 业务逻辑：打印问候语
    std::cout << "Hello, " << cName << " (from C++)" << std::endl;

    // 3. 释放资源（避免内存泄漏）
    env->ReleaseStringUTFChars(name, cName);
}
```

#### 步骤4：编译C/C++代码为本地库
- **Windows（MinGW）**：  
  编译为`.dll`文件，需指定JDK的`jni.h`和`jni_md.h`头文件路径（通常在`JDK_HOME/include`和`JDK_HOME/include/win32`）：
  ```bash
  g++ -I"C:\Program Files\Java\jdk1.8.0_301\include" -I"C:\Program Files\Java\jdk1.8.0_301\include\win32" -shared -o NativeLib.dll NativeExample.cpp
  ```
- **Linux**：  
  编译为`.so`文件，指定头文件路径：
  ```bash
  g++ -I/usr/lib/jvm/jdk1.8.0_301/include -I/usr/lib/jvm/jdk1.8.0_301/include/linux -fPIC -shared -o libNativeLib.so NativeExample.cpp
  ```

#### 步骤5：运行Java程序
将生成的本地库（如`NativeLib.dll`）放入Java程序能找到的路径（如当前目录、系统`PATH`路径），运行Java程序：
```bash
java NativeExample
```
**输出**：
```
Hello, Alice (from C++)
```

### 3. Native方法的应用场景
- **底层硬件操作**：如Java调用C代码访问传感器、控制硬件设备（如嵌入式系统）。
- **操作系统API调用**：如调用Windows的`User32.dll`实现窗口操作，调用Linux的`pthread`库实现线程管理。
- **性能敏感场景**：将耗时的计算逻辑（如复杂算法、大数据处理）用C/C++实现，提升执行效率（如Java的`java.lang.Math`类的部分方法、`String`的`hashCode`方法）。
- **复用现有C/C++库**：如调用OpenCV（图像处理库）、FFmpeg（音视频处理库）的功能，避免重复开发。

### 4. 注意事项
- **内存管理**：通过JNI函数（如`GetStringUTFChars`）获取的资源，必须调用对应释放函数（如`ReleaseStringUTFChars`），避免内存泄漏。
- **跨平台兼容性**：本地库与操作系统和CPU架构绑定（如Windows x64的`.dll`无法在Linux x64上运行），需为不同平台编译不同版本的本地库。
- **安全性**：本地代码不受Java沙箱机制限制，可能直接操作内存，需确保本地库来源可靠，避免安全漏洞。