---
title: 数据类型
order: 2
---

## Java有哪些数据类型？

| **类别**        | **数据类型**   | **说明**              |
| ------------- | ---------- | ------------------- |
| **基本类型（8 个）** | byte       | 整数，1 字节             |
|               | short      | 整数，2 字节             |
|               | int        | 整数，4 字节（默认整数类型）     |
|               | long       | 整数，8 字节             |
|               | float      | 单精度浮点数，4 字节         |
|               | double     | 双精度浮点数，8 字节（默认小数类型） |
|               | char       | 单个字符，2 字节           |
|               | boolean    | 布尔类型，true/false     |
| **引用类型**      | Class      | 类对象引用               |
|               | Interface  | 接口引用                |
|               | Array      | 数组                  |
|               | Enum       | 枚举                  |
|               | Annotation | 注解                  |


## 数据类型转换方式你知道哪些？
1. **自动类型转换（隐式转换）**：目标类型范围大于源类型时，Java自动转换，无需显式操作。例如，int转long、float转double。
2. **强制类型转换（显式转换）**：目标类型范围小于源类型时，需显式声明，可能导致数据丢失或溢出。语法：`目标类型 变量名 = (目标类型) 源类型`。例如，long转int、double转int。
3. **字符串转换**：通过包装类方法将字符串转为其他类型。例如，`Integer.parseInt()`将字符串转int，`Double.parseDouble()`将字符串转double。
4. **数值之间的转换**：通过包装类实现数值类型互转（如int转char、char转int），例如`Character`类、`Integer`类的转换方法。

## 类型互转会出现什么问题吗？
- **数据丢失**：大范围类型转小范围类型时，可能丢失高位数据。例如，long转int时，若long值超int范围，结果仅保留低位，高位丢失。
- **数据溢出**：小范围类型转大范围类型时，虽原始数据不变，但可能因符号位扩展导致意外结果（如byte转int时，负byte值的符号位会扩展）。
- **精度损失**：浮点数转换时，因表示方式不同可能损失精度。例如，float转double时，虽double精度更高，但float的近似值转换后仍可能有误差。
- **类型不匹配错误**：源类型与目标类型不兼容时，会触发编译错误或运行时错误（如字符串直接转int未用`parseInt()`）。

## 为什么用bigDecimal 不用double ？
因double会出现精度丢失问题：
double执行二进制浮点运算，二进制无法准确表示部分小数（如0.1）——类似十进制无法准确表示1/3（0.333...），二进制仅能表示"1/(2^n)的和"形式，而0.1无法表示为这种形式，导致计算误差。

示例：
```java
System.out.println(0.05 + 0.01); // 输出0.060000000000000005
System.out.println(1.0 - 0.42); // 输出0.5800000000000001
System.out.println(4.015 * 100); // 输出401.49999999999994
System.out.println(123.3 / 100); // 输出1.2329999999999999
```

这种误差在金钱计算（如商品价格）中会引发严重问题（如0.05+0.01算成0.060000000000000005，导致无法下单或对账错误）。

而`BigDecimal`支持精确的十进制计算，可避免上述问题。示例：
```java
import java.math.BigDecimal;

public class BigDecimalExample {
    public static void main(String[] args) {
        BigDecimal num1 = new BigDecimal("0.1");
        BigDecimal num2 = new BigDecimal("0.2");

        BigDecimal sum = num1.add(num2);
        BigDecimal product = num1.multiply(num2);

        System.out.println("Sum: " + sum); // 输出Sum: 0.3
        System.out.println("Product: " + product); // 输出Product: 0.02
    }
}
```

注意：创建`BigDecimal`时，需用字符串作为参数，避免直接用浮点数值（否则仍会因浮点精度问题导致误差）。

## 装箱和拆箱是什么？
装箱（Boxing）和拆箱（Unboxing）是**基本数据类型与对应包装类之间的转换过程**。
```java
Integer i = 10;  // 装箱：int转Integer
int n = i;       // 拆箱：Integer转int
```

### 自动装箱的场景
1. **赋值时**：Java 1.5后，编译器自动完成转换，无需手动操作。
   ```java
   // Java 1.5前（手动转换）
   Integer iObject = Integer.valueOf(3);
   int iPrimitive = iObject.intValue();

   // Java 1.5后（自动装箱/拆箱）
   Integer iObject = 3; // 自动装箱：基本类型转包装类
   int iPrimitive = iObject; // 自动拆箱：包装类转基本类型
   ```
2. **方法调用时**：传入基本类型或接收包装类返回值时，编译器自动转换。
   ```java
   public static Integer show(Integer iParam){
       System.out.println("autoboxing example - method invocation i: " + iParam);
       return iParam;
   }

   // 方法调用时的自动装箱/拆箱
   show(3); // 自动装箱：int转Integer作为参数
   int result = show(3); // 自动拆箱：Integer返回值转int
   ```

### 自动装箱的弊端
循环中自动装箱会创建大量无用对象，影响性能。例如：
```java
Integer sum = 0; 
for(int i=1000; i<5000; i++){   
    sum += i; 
} 
```
`sum += i`等价于`sum = sum + i`：sum先自动拆箱为int与i相加，再自动装箱为Integer。循环会创建近4000个无用Integer对象，增加内存开销和垃圾回收压力。

## Integer
### Java为什么要有Integer？
Integer是int的包装类，核心作用是**将int基本类型封装为对象**，满足Java对"对象操作"的需求，主要体现在三方面：
1. **封装方法**：将int数据与处理方法结合，如`Integer.parseInt()`用于字符串转int，方便数据处理。
2. **泛型支持**：Java泛型仅支持引用类型，无法直接使用int，需用Integer才能在泛型中使用（如`List<Integer>`）。示例：
   ```java
   List<Integer> list = new ArrayList<>();
   list.add(3);
   list.add(1);
   list.add(2);
   Collections.sort(list); // 泛型依赖Integer包装类
   System.out.println(list);
   ```
3. **集合兼容**：Java集合（如List、Map）仅能存储对象，无法存储int基本类型，需将int包装为Integer才能存入集合。示例：
   ```java
   List<Integer> list = new ArrayList<>();
   list.add(3);
   list.add(1);
   list.add(2);
   // 用stream计算总和，依赖Integer包装类
   int sum = list.stream().mapToInt(Integer::intValue).sum();
   System.out.println(sum);
   ```

### Integer相比int有什么优点？
int是基本数据类型，Integer是int的包装类，两者核心区别如下：
| 对比维度 | int | Integer |
|----------|-----|---------|
| 类型性质 | 基本数据类型 | 引用数据类型 |
| 内存存储 | 变量直接存储数据 | 需为对象分配内存（引用+数据） |
| 性能 | 操作速度快 | 操作速度较慢（需对象实例化） |
| 自动转换 | 不支持 | 支持自动装箱/拆箱，转换更便捷 |
| 空值处理 | 默认值为0，无空值 | 未初始化时为null，可能触发空指针异常 |
| 功能扩展 | 无额外方法 | 提供`parseInt()`、`valueOf()`等方法，支持泛型和集合 |

### 那为什么还要保留int类型？
因基本类型在**效率和内存占用**上远超包装类：
- 内存方面：64位JVM开启引用压缩后，一个Integer对象占16字节，而int仅占4字节，前者是后者的4倍。
- 效率方面：基本类型变量直接存储数据，读写无需通过对象引用，操作速度更快；包装类需实例化对象，且自动装箱/拆箱会额外消耗性能。

因此，无需对象特性（如泛型、集合）时，用int更高效。

### 说一下 Integer的缓存
Java的Integer类内部实现了**静态缓存池**，用于复用特定范围的Integer对象：
- 默认缓存范围：-128至127。
- 缓存逻辑：通过`Integer.valueOf(int)`方法创建该范围内的整数对象时，不会新建实例，而是复用缓存中的现有对象；超出范围则新建对象。

例如，`Integer a = 100`和`Integer b = 100`会指向同一缓存对象，而`Integer c = 200`和`Integer d = 200`会指向不同对象。

例如，`Integer a = 100`和`Integer b = 100`会指向同一缓存对象，而`Integer c = 200`和`Integer d = 200`会指向不同对象。
