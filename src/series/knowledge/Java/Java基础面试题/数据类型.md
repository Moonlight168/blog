---
title: 数据类型
order: 2.5
---

## Java有哪些数据类型？

Java 的数据类型分为 **基本类型** 和 **引用类型**：

#### **1. 基本类型（8种）**

* 整数：**byte**（1B）、**short**（2B）、**int**（4B）、**long**（8B）
* 浮点：**float**（4B）、**double**（8B）
* 字符：**char**（2B）
* 布尔：**boolean**（1B）

#### **2. 引用类型**

* **类**（Class）
* **接口**（Interface）
* **数组**（Array）
* **枚举**（Enum）
* **注解**（Annotation）

引用类型存储的是 **对象的引用地址**。

## 数据类型转换

### **数据类型转换方式有哪些？**

1. **自动类型转换（隐式转换）**
   小范围 → 大范围，自动转，比如 int → long、float → double。

2. **强制类型转换（显式转换）**
   大范围 → 小范围，需要手动写 `(类型)`，可能丢数据，比如 long → int。

3. **字符串转换成基本类型**
   用包装类的 `parseXxx()`，如 `Integer.parseInt("123")`。

4. **基本类型之间互转**
   通过包装类方法实现，例如 `char` 和 `int` 的互转。


### **类型互转可能出现的问题**

* **数据丢失**：大转小，高位被截断。
* **数据溢出**：符号位扩展导致结果不符合预期。
* **精度损失**：浮点数转来转去都有误差。
* **类型不匹配**：不兼容类型会报错。


### **为什么用 BigDecimal 不用 double？**

double 属于**二进制浮点数**，无法精确表示某些小数（如 0.1），导致运算出现误差。
金融计算不能容忍误差，因此改用 **BigDecimal 精确十进制计算**。

注意：构造 BigDecimal 时必须用字符串，如：

```java
new BigDecimal("0.1")
```


### **什么是装箱和拆箱？**

* **装箱**：基本类型 → 包装类

  ```java
  Integer a = 10; // 自动装箱
  ```
* **拆箱**：包装类 → 基本类型

  ```java
  int b = a; // 自动拆箱
  ```

### 为什么需要自动装箱和拆箱？

* **方便操作**：可以直接用基本类型进行运算，而无需显式转换。
* **与集合兼容**：Java 集合只能存储对象，不能直接存储基本类型。

#### 自动装箱的性能问题

在循环里频繁装箱，会创建大量 Integer 对象，导致性能下降、GC 增加。

## Integer

### **Java 为什么要有 Integer？**

因为：

1. **支持方法和工具类操作**（如 `Integer.parseInt()`）
2. **Java 泛型只能用引用类型**
3. **集合只能存对象，不能存基本类型**

### **Integer 相比 int 的优缺点有哪些？**

| 项目 | int    | Integer   |
| -- | ------ | --------- |
| 类型 | 基本类型   | 引用类型      |
| 内存 | 仅 4 字节 | 至少 16 字节  |
| 性能 | 快      | 慢（对象操作）   |
| 空值 | 不支持    | 可以是 null  |
| 场景 | 运算密集   | 集合、泛型、工具类 |

**简单说：**
运算用 int，涉及对象操作（集合、泛型）用 Integer。

### **有了解过Integer 的缓存机制吗？**

* Java 会缓存 **-128 ~ 127** 的 Integer 对象。
* 通过 `Integer.valueOf()` 获取该范围的数字时，不会创建新对象，而是从缓存取。

举例：

```java
Integer a = 100;
Integer b = 100;
// a == b → true（缓存复用）

Integer c = 200;
Integer d = 200;
// c == d → false（超范围，重新创建）
```

一句话总结：
**小整数用缓存，大整数新建对象。**

