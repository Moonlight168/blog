---
order: 2
---
# 数据类型
## 八种基本的数据类型
Java数据类型分为**基本数据类型**和**引用数据类型**：
- 基本数据类型共8种，分三类：
   - 数值型：整数类型（byte、short、int、long）、浮点类型（float、double）
   - 字符型：char
   - 布尔型：boolean
- 引用数据类型：类（class）、接口（interface）、数组

8种基本数据类型的默认值、位数、取值范围如下表所示：

| 数据类型 | 占用大小（字节） | 位数 | 取值范围 | 默认值 | 描述 |
|----------|------------------|------|----------|--------|------|
| `byte`   | 1                | 8    | -128（-2^7）到127（2^7 - 1） | 0 | 最小整数类型，适合节省内存（如处理文件/网络流小范围整数） |
| `short`  | 2                | 16   | -32768（-2^15）到32767（2^15 - 1） | 0 | 较少使用，适用于需节省内存且数值在该区间的场景 |
| `int`    | 4                | 32   | -2147483648（-2^31）到2147483647（2^31 - 1） | 0 | 最常用整数类型，满足多数日常整数计算需求 |
| `long`   | 8                | 64   | -9223372036854775808（-2^63）到9223372036854775807（2^63 - 1） | 0L | 用于超大整数，int范围不足时使用，定义时数值后需加L/l |
| `float`  | 4                | 32   | 1.4E-45到3.4028235E38 | 0.0f | 单精度浮点数，精度较低，定义时数值后需加F/f |
| `double` | 8                | 64   | 4.9E-324到1.7976931348623157E308 | 0.0d | 双精度浮点数，精度高于float，是Java表示小数的默认类型 |
| `char`   | 2                | 16   | '\u0000'（0）到'\uffff'（65535） | '\u0000' | 表示单个字符，采用Unicode编码，可表示多语言字符 |
| `boolean`| 无明确字节大小（理论1位） | 无明确位数 | `true`或`false` | `false` | 用于逻辑判断，如条件判断、循环控制 |

**注意事项**：
- 基本数据类型字节数：1字节（byte、boolean）、2字节（short、char）、4字节（int、float）、8字节（long、double）。
- 浮点数默认类型为double，声明float需加F/f；整数默认类型为int，声明long需加L/l。
- 8种基本数据类型的包装类：char对应Character、int对应Integer，其他均为首字母大写（如Byte、Short）。
- char类型无符号，取值从0开始，不能为负。

## int和long是多少位，多少字节的？
- **`int`类型**：32位（bit），占4个字节（byte），是有符号整数，取值范围为-2^31到2^31-1（-2147483648到2147483647）。例如，简单计数器用int存储计数值，最大正数为2147483647，超范围会溢出。
- **`long`类型**：64位，占8个字节，是有符号整数，取值范围为-2^63到2^63-1（-9223372036854775808到9223372036854775807）。处理超大整数（如文件大小）时，int范围不足则用long。

## long和int可以互转吗 ？
可以，Java中`long`和`int`可相互转换，但需注意安全性：
- **int转long**：因long范围大于int，转换安全，可自动转换或强制转换。
  ```java
  int intValue = 10;
  long longValue = intValue; // 自动转换，安全
  ```
- **long转int**：因long范围大于int，转换可能导致数据丢失或溢出，需强制转换。
  ```java
  long longValue = 100L;
  int intValue = (int) longValue; // 强制转换，需注意风险
  ```

若`longValue`超出int范围，转换结果会截断高位，保留低位。建议转换前先检查`longValue`是否在int取值范围内，避免数据问题。

（此处应有“Java数据类型自动提升顺序”的示意图，图片名称：Java类型自动提升顺序图）

## 数据类型转换方式你知道哪些？
1. **自动类型转换（隐式转换）**：目标类型范围大于源类型时，Java自动转换，无需显式操作。例如，int转long、float转double。
2. **强制类型转换（显式转换）**：目标类型范围小于源类型时，需显式声明，可能导致数据丢失或溢出。语法：`目标类型 变量名 = (目标类型) 源类型`。例如，long转int、double转int。
3. **字符串转换**：通过包装类方法将字符串转为其他类型。例如，`Integer.parseInt()`将字符串转int，`Double.parseDouble()`将字符串转double。
4. **数值之间的转换**：通过包装类实现数值类型互转（如int转char、char转int），例如`Character`类、`Integer`类的转换方法。

## 类型互转会出现什么问题吗？
- **数据丢失**：大范围类型转小范围类型时，可能丢失高位数据。例如，long转int时，若long值超int范围，结果仅保留低位，高位丢失。
- **数据溢出**：小范围类型转大范围类型时，虽原始数据不变，但可能因符号位扩展导致意外结果（如byte转int时，负byte值的符号位会扩展）。
- **精度损失**：浮点数转换时，因表示方式不同可能损失精度。例如，float转double时，虽double精度更高，但float的近似值转换后仍可能有误差。
- **类型不匹配错误**：源类型与目标类型不兼容时，会触发编译错误或运行时错误（如字符串直接转int未用`parseInt()`）。

## 为什么用bigDecimal 不用double ？
因double会出现精度丢失问题：
double执行二进制浮点运算，二进制无法准确表示部分小数（如0.1）——类似十进制无法准确表示1/3（0.333...），二进制仅能表示"1/(2^n)的和"形式，而0.1无法表示为这种形式，导致计算误差。

示例：
```java
System.out.println(0.05 + 0.01); // 输出0.060000000000000005
System.out.println(1.0 - 0.42); // 输出0.5800000000000001
System.out.println(4.015 * 100); // 输出401.49999999999994
System.out.println(123.3 / 100); // 输出1.2329999999999999
```

这种误差在金钱计算（如商品价格）中会引发严重问题（如0.05+0.01算成0.060000000000000005，导致无法下单或对账错误）。

而`BigDecimal`支持精确的十进制计算，可避免上述问题。示例：
```java
import java.math.BigDecimal;

public class BigDecimalExample {
    public static void main(String[] args) {
        BigDecimal num1 = new BigDecimal("0.1");
        BigDecimal num2 = new BigDecimal("0.2");

        BigDecimal sum = num1.add(num2);
        BigDecimal product = num1.multiply(num2);

        System.out.println("Sum: " + sum); // 输出Sum: 0.3
        System.out.println("Product: " + product); // 输出Product: 0.02
    }
}
```

注意：创建`BigDecimal`时，需用字符串作为参数，避免直接用浮点数值（否则仍会因浮点精度问题导致误差）。

## 装箱和拆箱是什么？
装箱（Boxing）和拆箱（Unboxing）是**基本数据类型与对应包装类之间的转换过程**。
```java
Integer i = 10;  // 装箱：int转Integer
int n = i;       // 拆箱：Integer转int
```

### 自动装箱的场景
1. **赋值时**：Java 1.5后，编译器自动完成转换，无需手动操作。
   ```java
   // Java 1.5前（手动转换）
   Integer iObject = Integer.valueOf(3);
   int iPrimitive = iObject.intValue();

   // Java 1.5后（自动装箱/拆箱）
   Integer iObject = 3; // 自动装箱：基本类型转包装类
   int iPrimitive = iObject; // 自动拆箱：包装类转基本类型
   ```
2. **方法调用时**：传入基本类型或接收包装类返回值时，编译器自动转换。
   ```java
   public static Integer show(Integer iParam){
       System.out.println("autoboxing example - method invocation i: " + iParam);
       return iParam;
   }

   // 方法调用时的自动装箱/拆箱
   show(3); // 自动装箱：int转Integer作为参数
   int result = show(3); // 自动拆箱：Integer返回值转int
   ```

### 自动装箱的弊端
循环中自动装箱会创建大量无用对象，影响性能。例如：
```java
Integer sum = 0; 
for(int i=1000; i<5000; i++){   
    sum += i; 
} 
```
`sum += i`等价于`sum = sum + i`：sum先自动拆箱为int与i相加，再自动装箱为Integer。循环会创建近4000个无用Integer对象，增加内存开销和垃圾回收压力。

## Java为什么要有Integer？
Integer是int的包装类，核心作用是**将int基本类型封装为对象**，满足Java对"对象操作"的需求，主要体现在三方面：
1. **封装方法**：将int数据与处理方法结合，如`Integer.parseInt()`用于字符串转int，方便数据处理。
2. **泛型支持**：Java泛型仅支持引用类型，无法直接使用int，需用Integer才能在泛型中使用（如`List<Integer>`）。示例：
   ```java
   List<Integer> list = new ArrayList<>();
   list.add(3);
   list.add(1);
   list.add(2);
   Collections.sort(list); // 泛型依赖Integer包装类
   System.out.println(list);
   ```
3. **集合兼容**：Java集合（如List、Map）仅能存储对象，无法存储int基本类型，需将int包装为Integer才能存入集合。示例：
   ```java
   List<Integer> list = new ArrayList<>();
   list.add(3);
   list.add(1);
   list.add(2);
   // 用stream计算总和，依赖Integer包装类
   int sum = list.stream().mapToInt(Integer::intValue).sum();
   System.out.println(sum);
   ```

## Integer相比int有什么优点？
int是基本数据类型，Integer是int的包装类，两者核心区别如下：
| 对比维度 | int | Integer |
|----------|-----|---------|
| 类型性质 | 基本数据类型 | 引用数据类型 |
| 内存存储 | 变量直接存储数据 | 需为对象分配内存（引用+数据） |
| 性能 | 操作速度快 | 操作速度较慢（需对象实例化） |
| 自动转换 | 不支持 | 支持自动装箱/拆箱，转换更便捷 |
| 空值处理 | 默认值为0，无空值 | 未初始化时为null，可能触发空指针异常 |
| 功能扩展 | 无额外方法 | 提供`parseInt()`、`valueOf()`等方法，支持泛型和集合 |

## 那为什么还要保留int类型？
因基本类型在**效率和内存占用**上远超包装类：
- 内存方面：64位JVM开启引用压缩后，一个Integer对象占16字节，而int仅占4字节，前者是后者的4倍。
- 效率方面：基本类型变量直接存储数据，读写无需通过对象引用，操作速度更快；包装类需实例化对象，且自动装箱/拆箱会额外消耗性能。

因此，无需对象特性（如泛型、集合）时，用int更高效。

## 说一下 integer的缓存
Java的Integer类内部实现了**静态缓存池**，用于复用特定范围的Integer对象：
- 默认缓存范围：-128至127。
- 缓存逻辑：通过`Integer.valueOf(int)`方法创建该范围内的整数对象时，不会新建实例，而是复用缓存中的现有对象；超出范围则新建对象。

例如，`Integer a = 100`和`Integer b = 100`会指向同一缓存对象，而`Integer c = 200`和`Integer d = 200`会指向不同对象。

例如，`Integer a = 100`和`Integer b = 100`会指向同一缓存对象，而`Integer c = 200`和`Integer d = 200`会指向不同对象。
