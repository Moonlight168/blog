---
order: 13
---
# 设计模式
## volatile和synchronized如何实现单例模式
通过"双重检查锁定"（Double-Checked Locking）模式，结合`volatile`和`synchronized`，可实现线程安全、高性能的单例模式，代码如下：
```java
public class Singleton {
    // 1. volatile修饰实例变量：禁止指令重排序，保证可见性
    private static volatile Singleton instance = null;

    // 2. 私有构造方法：防止外部直接new创建对象
    private Singleton() {}

    // 3. 静态获取实例方法：双重检查锁定
    public static Singleton getInstance() {
        // 第一次检查：未加锁，快速判断实例是否已存在（避免频繁加锁）
        if (instance == null) {
            // 加锁：仅当实例未创建时，才进入同步代码块（保证线程安全）
            synchronized (Singleton.class) {
                // 第二次检查：防止多个线程同时进入同步块后，重复创建实例
                if (instance == null) {
                    instance = new Singleton(); // volatile禁止此步骤指令重排序
                }
            }
        }
        return instance;
    }
}
```

### 核心作用解析
1. **volatile的必要性**  
   `instance = new Singleton()`在JVM中会拆分为3步指令：
    1. 分配对象内存空间；
    2. 初始化对象（调用构造方法）；
    3. 将instance指向分配的内存地址。  
       若不加`volatile`，JVM可能进行**指令重排序**（如1→3→2），导致线程A执行到3时，instance已非null，但对象未初始化；此时线程B进入第一次检查，会直接返回未初始化的instance，引发空指针异常。`volatile`可禁止指令重排序，确保3在2之后执行。

2. **synchronized的必要性**  
   当多个线程同时进入"第一次检查"（instance为null时），`synchronized`保证只有一个线程能进入同步块，避免多个线程重复创建实例，确保单例唯一性。

3. **双重检查的必要性**  
   第一次检查（无锁）：避免实例已创建后，后续线程仍进入同步块，减少锁竞争，提升性能；  
   第二次检查（有锁）：防止多个线程在实例未创建时，同时等待同步锁，锁释放后重复创建实例。

## 代理模式和适配器模式有什么区别？
|对比维度|代理模式（Proxy Pattern）|适配器模式（Adapter Pattern）|
|----|----|----|
|**核心目的**|控制对目标对象的访问，为目标对象添加额外功能（如日志、权限校验、缓存），不改变目标对象的接口。|解决接口不兼容问题，将一个类的接口转换为客户端期望的另一个接口，使原本因接口不匹配无法协作的类能一起工作。|
|**角色结构**|包含3个核心角色：<br>- 抽象主题（Subject）：目标对象和代理的共同接口；<br>- 真实主题（Real Subject）：被代理的目标对象；<br>- 代理（Proxy）：实现Subject接口，持有Real Subject引用，控制访问并添加额外逻辑。|包含3个核心角色：<br>- 目标接口（Target）：客户端期望的接口；<br>- 被适配者（Adaptee）：现有接口不兼容的类；<br>- 适配器（Adapter）：实现Target接口，持有Adaptee引用，将Adaptee的方法适配为Target的方法。|
|**接口关系**|代理与目标对象实现**相同接口**，客户端无需感知代理的存在，可直接通过抽象主题接口调用。|适配器与被适配者实现**不同接口**，适配器将被适配者的接口转换为目标接口，客户端仅依赖目标接口。|
|**应用场景**|1. 远程代理：代理远程对象（如RPC中的代理）；<br>2. 保护代理：控制目标对象的访问权限（如仅管理员可调用）；<br>3. 缓存代理：为目标对象的结果添加缓存（如查询结果缓存）。|1. 类适配器：通过继承被适配者实现适配；<br>2. 对象适配器：通过组合被适配者实现适配；<br>3. 场景示例：将旧系统的接口适配为新系统的接口，兼容第三方组件的接口。|
|**代码示例逻辑**|```java
// 抽象主题（接口）
interface Image { void display(); }
// 真实主题（被代理对象）
class RealImage implements Image {
@Override public void display() { System.out.println("显示图片"); }
}
// 代理（添加日志功能）
class ProxyImage implements Image {
private RealImage realImage;
@Override public void display() {
System.out.println("日志：开始显示图片"); // 额外功能
if (realImage == null) realImage = new RealImage();
realImage.display(); // 调用目标对象方法
System.out.println("日志：结束显示图片"); // 额外功能
}
}
```
|```java
// 目标接口（客户端期望）
interface MediaPlayer { void play(String type); }
// 被适配者（旧接口，不兼容）
class AdvancedMediaPlayer {
    public void playMp4(String file) { System.out.println("播放MP4：" + file); }
}
// 适配器（适配旧接口到目标接口）
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedPlayer;
    @Override public void play(String type) {
        if ("mp4".equals(type)) {
            // 将MediaPlayer的play转换为AdvancedMediaPlayer的playMp4
            advancedPlayer.playMp4(type);
        }
    }
}
```
|