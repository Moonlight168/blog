---
order: 4
title: 泛型
---

## 什么是泛型？
泛型是Java的重要特性，允许类、接口、方法在定义时使用**类型参数**，使用时再指定具体类型。

其核心目的是**编译时类型检查**，避免运行时类型转换异常，同时提升代码复用性。

## 为什么需要泛型？
1. **代码复用**：无需为不同数据类型编写重复代码。例如，未用泛型时，需重载`add(int a, int b)`、`add(float a, float b)`等方法；用泛型后，可复用为一个方法：
   ```java
   private static <T extends Number> double add(T a, T b) {
       return a.doubleValue() + b.doubleValue();
   }
   ```
2. **类型安全**：编译时约束集合或方法的类型，避免存入错误类型数据。例如，未用泛型时，`List`可存入任意类型，取出时强制转换易出错；用泛型后，`List<String>`仅允许存入String，编译时即可拦截错误：
   ```java
   // 未用泛型（风险）
   List list = new ArrayList();
   list.add("string");
   list.add(100); // 允许存入Integer，取出时转换易出错

   // 用泛型（安全）
   List<String> list = new ArrayList<>();
   list.add("string");
   list.add(100); // 编译报错，不允许存入非String类型
   ```
   
## 泛型底层是如何实现的？
```component HoverComment
text: "Java 的泛型是通过 **类型擦除** 实现的。"
comment: |
  #### **1. 类型擦除定义**

   * 编译器将泛型类型参数替换为上限类型（通常是`Object`，若有显式边界则为边界类型）。
   * 运行时泛型类型信息被移除，`List<Integer>` 和 `List<String>` 在运行时都为 `List`。
   
   #### **2. 擦除规则**
   
   * **无边界泛型**：擦除为 `Object`。
   
     ```java
     class Box<T> { private T value; } // 编译后：private Object value;
     ```
   * **有边界泛型**：擦除为边界类型。
   
     ```java
     class Box<T extends Number> { private T value; } // 编译后：private Number value;
     ```
   
   #### **3. 类型擦除目的**
   
   * **保持二进制兼容性**：确保泛型代码与老版本代码兼容。
   * **简化实现**：避免为每个泛型类型生成单独的类，减少字节码大小。
   
   #### **4. 后果**
   
   * **运行时无法获取泛型类型信息**：`List<Integer>` 和 `List<String>` 运行时无法区分。
   * **不能创建泛型数组**：如 `new List<Integer>[10]` 编译错误。
   * **基本类型不能作为泛型类型**：如 `List<int>` 编译错误，需使用包装类。
   * **静态成员不能引用泛型参数**：如 `private static T value;` 编译错误。
   
   #### **5. 解决运行时无法获取泛型类型信息的方式**
   
   * **反射**：通过反射获取泛型类型信息，例如使用 `getGenericSuperclass()` 获取类的泛型类型。
   
     ```java
        class Box<T> {}
        Box<Integer> box = new Box<>();
        Type type = box.getClass().getGenericSuperclass(); // 获取泛型类型
        System.out.println(type); // 输出 Box<Integer>
     ```
   
   * **通配符**：使用通配符（`?`）来处理不同类型的泛型参数，配合反射操作实现类型获取。
   
      ``` java
          List<?> list = new ArrayList<>();
          Type type = list.getClass().getGenericSuperclass(); // 获取 List<?> 的类型信息
          System.out.println(type); // 输出 List
      ```
   #### **常见面试问题**
   
   * **Q**：为什么选择类型擦除？
   
      * **A**：为了兼容老版本代码，避免修改现有类库。
   
   * **Q**：类型擦除带来什么问题？
   
      * **A**：无法区分泛型类型、无法创建泛型数组、基本类型不能作为泛型。
```

```component HoverComment
text: "**类型擦除**就是：**泛型在编译后会被'擦掉'，运行时不再保留具体泛型类型。**"
comment: |
  **类型擦除 = 编译器自动帮你加上强制类型转换 + 删除泛型信息**
```

```java
List<String> list = new ArrayList<>();
```

编译器知道： “这个 List 只能放 String”。

但 **编译完之后的字节码里，类型信息会被擦掉**，变成：

```java
List list = new ArrayList();  // JVM 看到的是这个效果
```

所以运行时 `list.get(0)` 返回的是 **Object**。


- 那为什么还能拿到 String？

因为 **编译器在需要的地方给你自动补 cast（类型强制转换）**：

你的写法：

```java
String s = list.get(0);
```

字节码会变成：

```java
String s = (String) list.get(0);  // 编译器补的 cast
```


### 为什么要这样？

因为 Java 为了兼容旧代码（Java5 前没有泛型），所以采用了：

**泛型 = 编译期检查 + 运行期擦除**

* 编译器会检查你是不是只放了 String
* 运行时 JVM 只看到一个普通的 List（没有类型）
* 编译器必须自动生成 `(String)` 来确保类型安全
