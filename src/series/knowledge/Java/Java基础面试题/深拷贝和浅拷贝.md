---
order: 3
---
# 深拷贝和浅拷贝
## 深拷贝和浅拷贝的区别？
（此处应有"浅拷贝与深拷贝对象引用关系"的示意图，图片名称：浅拷贝深拷贝对比图）

| 对比维度 | 浅拷贝（Shallow Copy） | 深拷贝（Deep Copy） |
|----------|-------------------------|---------------------|
| 拷贝范围 | 仅拷贝对象本身和内部值类型字段 | 拷贝对象本身 + 内部所有引用类型字段（递归拷贝） |
| 引用关系 | 原对象与拷贝对象的引用类型字段指向同一对象 | 原对象与拷贝对象的引用类型字段指向不同对象（全新副本） |
| 数据独立性 | 引用类型字段修改会相互影响 | 完全独立，修改一方不影响另一方 |
| 实现复杂度 | 较简单（如`Object.clone()`默认浅拷贝） | 较复杂（需递归处理引用类型或用序列化） |

示例：
- 浅拷贝：Student对象含"姓名（String）""住址（Address引用类型）"，浅拷贝后，两个Student的`Address`指向同一对象，修改一个的住址会影响另一个。
- 深拷贝：拷贝Student时，同时新建`Address`对象并复制其属性，两个Student的`Address`是独立对象，修改互不影响。

## 实现深拷贝的三种方法是什么？
在Java中，实现对象深拷贝主要有三种方法：

### 1. 实现 Cloneable 接口并重写 clone() 方法
需对象及其所有引用类型字段均实现`Cloneable`接口，并重写`clone()`方法，通过递归克隆引用类型字段实现深拷贝。
```java
class MyClass implements Cloneable {
    private String field1;
    private NestedClass nestedObject; // 引用类型字段

    @Override
    protected Object clone() throws CloneNotSupportedException {
        MyClass cloned = (MyClass) super.clone(); // 先浅拷贝当前对象
        // 递归克隆引用类型字段，实现深拷贝
        cloned.nestedObject = (NestedClass) nestedObject.clone();
        return cloned;
    }
}

class NestedClass implements Cloneable {
    private int nestedField;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 引用类型字段自身也需实现clone()
    }
}
```

### 2. 使用序列化和反序列化
将对象序列化为字节流，再反序列化为新对象，需对象及其所有引用类型字段实现`Serializable`接口。
```java
import java.io.*;

class MyClass implements Serializable {
    private String field1;
    private NestedClass nestedObject;

    // 深拷贝方法
    public MyClass deepCopy() {
        try {
            // 序列化：将对象写入字节流
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            oos.flush();
            oos.close();

            // 反序列化：从字节流读取对象（生成新对象）
            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
            ObjectInputStream ois = new ObjectInputStream(bis);
            return (MyClass) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
}

class NestedClass implements Serializable {
    private int nestedField;
}
```

### 3. 手动递归复制
针对特定对象结构，手动创建新对象并复制所有字段（包括引用类型字段的递归复制），适用于对象结构简单的场景。
```java
class MyClass {
    private String field1;
    private NestedClass nestedObject;

    // 深拷贝方法
    public MyClass deepCopy() {
        MyClass copy = new MyClass();
        copy.setField1(this.field1); // 复制值类型字段
        // 手动复制引用类型字段（调用其深拷贝方法）
        copy.setNestedObject(this.nestedObject.deepCopy());
        return copy;
    }

    // getter/setter省略
}

class NestedClass {
    private int nestedField;

    // 引用类型字段的深拷贝方法
    public NestedClass deepCopy() {
        NestedClass copy = new NestedClass();
        copy.setNestedField(this.nestedField);
        return copy;
    }

    // getter/setter省略
}