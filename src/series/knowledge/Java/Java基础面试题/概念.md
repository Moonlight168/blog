---
title: "概念"
order: 1
---
# 概念
## 说一下Java的特点
主要有以下六点：
1. **跨平台：** 一次编译，到处运行，因为 JVM 做了底层适配。
2. **面向对象：** 封装、继承、多态这些特性让代码更好维护、扩展。
3. **内存管理完善：** 有自动垃圾回收，不用手动管理内存，相对更安全。
4. **生态丰富：** 框架、类库特别多，比如 Spring 全家桶，写业务效率很高。
5. **安全性强：** JVM 隔离、字节码校验、类加载机制，让程序更可靠。
6. **多线程支持好：** 内置线程模型，配合 JUC 包，处理并发很方便。
                  
## Java 的优势和劣势是什么？
**优势：**

1. 跨平台，一次编写到处运行。
2. 生态成熟，类库和框架非常丰富。
3. 社区庞大，问题容易找到解决方案。
4. 内存管理自动化，写起来更安全。
5. 面向对象，结构清晰、可维护性高。
6. 并发能力强，JUC 工具完善。

**劣势：**

1. 运行依赖 JVM，启动速度比原生语言慢。
2. 内存占用相对偏高。
3. 灵活性不如动态语言，开发效率有时受语法限制。
4. ```component HoverComment
    text: 高并发场景下需要大量调优，对开发者要求高。
    comment: |
      **1. 线程调优**
      为不同业务配置合适的线程池参数（核心线程数、最大线程数、队列长度），避免频繁创建线程和阻塞，让线程保持高利用率。
    
      **2. 锁调优**
      减少锁的粒度和持有时间，避免全局锁；能使用 CAS、并发工具类（如 ConcurrentHashMap、LongAdder）则尽量不使用 synchronized，提高吞吐。
    
      **3. 内存与 GC 调优**
      减少临时对象创建，优化缓存命中；根据服务类型选择合适的 GC（G1/ZGC），调整堆大小，使 GC 停顿更小、更稳定。
    
      **4. JVM 参数调优**
      结合业务实际设置堆大小、元空间、GC 类型、最大暂停时间、线程栈大小等 JVM 参数，使系统在高并发下更加平稳可靠。
    
      **5. 架构层调优**
      使用多层缓存（本地缓存 + Redis）、消息队列削峰填谷、读写分离、分库分表、限流熔断降级等方式提升系统整体吞吐和可用性。
    ```

## Java为什么是跨平台的？
因为 Java 程序不是直接跑在操作系统上的，而是跑在 JVM 上。

```component HoverComment
text: 操作系统差异由不同的JVM来适配。
comment: |
  常见的 JVM 有这些：
  1. **HotSpot** —— 最主流的 JVM（OpenJDK、Oracle 都在用）
  2. **OpenJ9** —— IBM 出的，内存占用更低
  3. **GraalVM** —— 支持多语言、AOT 编译
  4. **Azul 的 Zing / Zulu** —— 主打低延迟、高性能
``` 

## JVM、JDK、JRE三者关系？
它们之间的关系如下：
- **JVM（Java虚拟机）**：是Java程序运行的环境，负责将Java字节码（由Java编译器生成）解释或编译成机器码并执行。它提供内存管理、垃圾回收、安全性等功能，是Java程序跨平台的核心。
- **JDK（Java开发工具包）**：是开发Java程序的工具集合，包含JVM、编译器（javac）、调试器（jdb）等开发工具，以及Java标准库、开发工具库等。提供开发、编译、调试和运行Java程序所需的全部工具和环境。
- **JRE（Java运行时环境）**：是Java程序运行的最小环境，包含JVM和一组Java类库，仅支持Java程序执行，不包含开发工具。

## 为什么 Java 既是编译型又是解释型语言？

Java 的执行流程是“**先编译、再解释或编译执行**”。

* **先编译**：Java 源代码 `.java` 会先被编译成 `.class` 字节码，这保证了可移植性。
* **再解释/编译执行**：字节码进入 JVM 后：

   * 热点代码会被 **JIT 即时编译** 成机器码，加速执行；
   * 非热点代码由 **解释器逐行解释**，减少启动成本。

因此 Java 采用 **解释器 + JIT 编译器的混合模式**，既保证跨平台，又有较高执行效率。

### 编译型语言 vs 解释型语言

**编译型语言**

* 执行前整体编译成机器码
* 执行快，但跨平台性差
* 如：C、C++

**解释型语言**

* 执行时逐行解释，无独立可执行文件
* 跨平台好，但速度慢
* 如：Python、JavaScript

### Python 和 Java 的区别

* ```component HoverComment
    text: "**Java**：先编译成字节码，由 **JVM 解释或 JIT 编译执行** → 编译+解释型语言"
    comment: |
      **JIT（Just-In-Time Compiler，即时编译器）** 是 JVM 中负责把"热点代码"动态编译成机器码的组件，用来提升 Java 程序的执行速度。
    ```
* **Python**：运行时由解释器（如 CPython）**逐行解释执行** → 纯解释型语言

## java创建对象有哪些方式？
Java中创建对象的常见方式有5种：
1. **使用new关键字**：直接调用类的构造方法，最常用。
   ```java
   MyClass obj = new MyClass();
   ```
2. **使用Class类的newInstance()方法**：通过反射创建对象，需类有默认构造方法（无参构造）。
   ```java
   MyClass obj = (MyClass) Class.forName("com.example.MyClass").newInstance();
   ```
3. **使用Constructor类的newInstance()方法**：通过反射创建对象，支持调用有参构造方法，更灵活。
   ```java
   // 获取指定构造器（此处以无参构造为例）
   Constructor<MyClass> constructor = MyClass.class.getConstructor();
   MyClass obj = constructor.newInstance();
   ```
4. **使用clone()方法**：类需实现`Cloneable`接口并重写`clone()`方法，创建对象的副本（默认浅拷贝）。
   ```java
   MyClass obj1 = new MyClass();
   MyClass obj2 = (MyClass) obj1.clone();
   ```
5. **使用反序列化**：将序列化后的字节流（如文件中的对象）反序列化为对象，类需实现`Serializable`接口。
   ```java
   // 序列化（写入文件）
   ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("object.ser"));
   out.writeObject(obj);
   out.close();

   // 反序列化（读取对象）
   ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser"));
   MyClass obj = (MyClass) in.readObject();
   in.close();
   ```

## New出的对象什么时候回收？
`new`创建的对象由Java**垃圾回收器（GC）** 自动回收，回收时机由GC根据算法判断，核心是"对象不再被引用"。

GC判断对象可回收的主要算法：
1. **引用计数法**：对象的引用计数器为0时，表示无引用，可回收。例如，`MyClass obj = new MyClass(); obj = null;`，对象引用计数变为0，可被回收。
2. **可达性分析算法**：从"根对象"（如方法区静态属性、栈中局部变量）出发，遍历引用链；若对象无任何引用链可达（不可达），则可回收。例如，方法执行完毕，局部变量对象成为不可达对象，可被回收。

此外，若对象重写了`finalize()`方法，GC回收前会调用该方法（仅一次），对象可在方法中尝试"自救"（重新建立引用）；但`finalize()`执行时机不确定，且可能导致性能问题，不推荐使用。

GC的回收操作是自动的，开发者无法精确控制回收时间，但可通过`System.gc()`建议GC执行（仅建议，不保证立即执行）。

## 如何获取私有对象？
Java中，私有对象（`private`修饰的成员变量或方法）仅能在类内部访问，外部需通过以下两种方式间接获取：

### 1. 使用公共访问器方法（getter 方法）
类的设计者通常为私有成员变量提供`public`的`getter`方法，外部通过调用该方法安全获取私有对象。这是符合面向对象封装原则的推荐方式。
```java
class MyClass {
    // 私有成员变量
    private String privateField = "私有字段的值";

    // 公共getter方法
    public String getPrivateField() {
        return privateField;
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        // 通过getter获取私有字段值
        String value = obj.getPrivateField();
        System.out.println(value); // 输出：私有字段的值
    }
}
```

### 2. 使用反射机制
反射可绕过`private`访问限制，在运行时获取私有成员。需注意，这种方式破坏封装性，可能引发安全问题，需谨慎使用。
```java
import java.lang.reflect.Field;

class MyClass {
    private String privateField = "私有字段的值";
}

public class Main {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        MyClass obj = new MyClass();
        // 1. 获取Class对象
        Class<?> clazz = obj.getClass();
        // 2. 获取私有字段（getDeclaredField()获取所有字段，包括private）
        Field privateField = clazz.getDeclaredField("privateField");
        // 3. 设置字段可访问（绕过private限制）
        privateField.setAccessible(true);
        // 4. 获取私有字段的值
        String value = (String) privateField.get(obj);
        System.out.println(value); // 输出：私有字段的值
    }
}