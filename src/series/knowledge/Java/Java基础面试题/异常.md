---
title: 异常
order: 8
---

## 说一下Java异常体系结构

Java异常基于`Throwable`类，分为两大分支：

- **Error**：JVM严重错误，如`OutOfMemoryError`（OM）、`StackOverflowError`
- **Exception**：程序可处理异常
  - **受检异常**：编译时强制处理，如`IOException`、`FileNotFoundException`
  - **运行时异常**：继承自`RuntimeException`，如`NullPointerException`、`ArrayIndexOutOfBoundsException`

## 什么是OM？
**回答：**
OM通常指Java中的`OutOfMemoryError`（内存溢出错误），是JVM错误的一种，表示Java虚拟机无法申请到足够的内存空间来完成对象分配或内存操作。

- **类型**：属于`Error`体系，JVM无法处理，会导致程序崩溃
- **本质**：堆、栈、方法区等内存区域耗尽
- **表现**：程序突然崩溃，打印错误堆栈信息

## 什么会导致OM？
**回答：**
导致内存溢出（OutOfMemoryError）的常见原因包括：

### 1. 堆内存溢出（最常见）
- **原因**：对象创建过多且无法被GC回收，导致堆内存耗尽
- **表现**：`java.lang.OutOfMemoryError: Java heap space`
- **常见场景**：
  - 内存泄漏（如静态集合持有对象引用）
  - 大数据处理（如一次性加载大量数据）
  - 无限循环创建对象

### 2. 栈内存溢出
- **原因**：方法调用栈深度过大，导致栈帧无法创建
- **表现**：`java.lang.StackOverflowError`（严格来说是栈溢出，属于OM的一种）
- **常见场景**：
  - 递归调用没有终止条件
  - 方法调用链过长

### 3. 方法区/元空间溢出
- **原因**：类加载过多或动态生成类过多，导致方法区/元空间耗尽
- **表现**：`java.lang.OutOfMemoryError: PermGen space`（JDK8之前）或`Metaspace`（JDK8及以后）
- **常见场景**：
  - 大量动态生成的类（如CGLib代理、反射）
  - 第三方框架过度使用（如Spring、Hibernate）

### 4. 直接内存溢出
- **原因**：使用NIO的直接内存分配过多，超出限制
- **表现**：`java.lang.OutOfMemoryError: Direct buffer memory`
- **常见场景**：
  - 大量使用ByteBuffer.allocateDirect()
  - 网络通信中使用大缓冲区

### 5. 其他原因
- **线程数量过多**：每个线程占用一定内存，导致系统内存耗尽
- **JNI调用**：Java调用本地方法时，本地代码内存泄漏
- **JVM参数设置不合理**：堆内存设置过小，无法满足应用需求

## Java的异常处理机制有哪些？

### 1. try-catch-finally
```java
try {
    // 可能会异常的代码
} catch (SpecificException e) {
    // 处理特定异常
} catch (Exception e) {
    // 处理其他异常
} finally {
    // 总是执行的代码（资源清理）
}
```

### 2. throw和throws
```java
// 手动抛出异常
public void check(int value) {
    if (value < 0) throw new IllegalArgumentException("值不能为负数");
}

// 方法声明抛出异常
public void read() throws IOException {
    // 可能抛出IOException的代码
}
```

下面是 **结构更清晰、重点更突出、可读性更强、面试更易背的优化版本**（保留你的内容，但做了精炼与格式增强）。

---

## 现代主流的异常处理机制是什么？

### 异常链（Exception Chaining）

* **核心作用：保留原始异常，方便排查根因**
* 通过构造方法把原异常作为 `cause` 传递下去

```java
try {
    userService.getUser(userId); // 可能抛出 SQLException
} catch (SQLException e) {
    // 包装异常，同时保留原始异常信息
    throw new ServiceException("服务调用失败", e);
}
```

**为什么需要异常链？**

* **保留根因**：知道是 SQL 写错？网络故障？连接池问题？
* **调试友好**：异常栈完整，从业务层→DAO层链路清晰
* **跨层传递不丢信息**：适合分层架构（Controller → Service → DAO）


### Try-With-Resources（Java 7+）

* **自动关闭资源，防止资源泄漏**
* **替代 finally 的繁琐写法**

```java
try (FileInputStream in = new FileInputStream("a.txt");
     BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
    // 使用资源
} catch (IOException e) {
    // 异常处理
}
```

### 异常处理最佳实践


#### 自定义异常（业务强相关）

* **意义：让业务语义更清晰**，例如 `OrderException`、`UserNotFoundException`
* 可继承

  * `Exception`（受检）
  * `RuntimeException`（非受检）

```java
public class BusinessException extends Exception {
    private String code;

    public BusinessException(String msg) { super(msg); }
    public BusinessException(String msg, String code) {
        super(msg);
        this.code = code;
    }
}
```

**使用示例：**

```java
public void processOrder(Order order) throws BusinessException {
    if (order == null) {
        throw new BusinessException("订单不能为空", "ORDER_NULL");
    }
}
```


#### 异常处理策略

* **记录日志**：日志里保存完整错误（包括堆栈）
* **优雅降级**：服务不可用时快速返回默认值 / fallback
* **监控告警**：异常接入 Prometheus、Sentry、SkyWalking

### 函数式异常处理（Java 8+）

* **减少 if-null 判断**
* **减少大量 try-catch**

```java
// null 安全
String result = Optional.ofNullable(getData())
        .map(String::toUpperCase)
        .orElse("默认值");

// Stream 异常处理
List<String> list2 = list.stream()
        .map(this::safeParse)      // 返回 Optional
        .flatMap(Optional::stream) // 过滤空值
        .collect(Collectors.toList());
```

### 全局异常处理（Web 常用）

* **完全不用在 Controller 中写 try-catch**
* **实现统一响应格式（JSON）**

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<?> handleBiz(BusinessException e) {
        return ResponseEntity.badRequest().body(e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleAll(Exception e) {
        return ResponseEntity.status(500).body("系统异常");
    }
}
```


## Java类加载中常见的异常类有哪些？

1. **`ClassNotFoundException`**

  * **类型**：编译时检查异常（受检异常）
  * **原因**：`Class.forName("xxx")` 或类路径中找不到指定类

2. **`NoClassDefFoundError`**

  * **类型**：运行时错误（Error）
  * **原因**：编译时存在类，但运行时 JVM 找不到（可能类路径变动或依赖缺失）
  * **区别**：`ClassNotFoundException` 是主动加载失败，`NoClassDefFoundError` 是被动引用失败

3. **`ClassFormatError`**

  * **类型**：运行时错误
  * **原因**：类文件格式错误或被篡改，不符合 JVM 规范

4. **`UnsupportedClassVersionError`**

  * **类型**：运行时错误
  * **原因**：类文件版本高于当前 JVM 版本
  * **示例**：用 JDK 17 编译的类在 JDK 11 上运行

5. **`LinkageError` 系列**

  * **`VerifyError`**：字节码校验失败
  * **`NoSuchMethodError` / `NoSuchFieldError`**：类的结构变化导致方法或字段找不到