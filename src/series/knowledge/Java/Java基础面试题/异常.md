---
order: 8
---
# 异常
## 介绍一下Java异常
Java异常体系基于`Throwable`类，其下分为`Error`（错误）和`Exception`（异常）两大分支，分别对应不同类型的异常情况。

（此处应有"Java异常类层次结构"的示意图，图片名称：Java异常体系结构图）

### 1. Error（错误）
- 定义：表示**运行时环境的严重错误**，程序无法处理，通常是JVM或系统级问题。
- 特点：无需捕获或声明抛出，程序应直接终止，避免尝试恢复。
- 示例：`OutOfMemoryError`（内存溢出）、`StackOverflowError`（栈溢出）、`NoClassDefFoundError`（类未找到）。

### 2. Exception（异常）
- 定义：表示**程序本身可处理的异常条件**，分为两类：
   1. **非运行时异常（受检异常）**：
      - 特点：编译时强制要求捕获或声明抛出（`throws`），否则编译报错。
      - 场景：外部环境错误，如文件不存在、网络连接失败。
      - 示例：`FileNotFoundException`（文件未找到）、`IOException`（IO异常）、`ClassNotFoundException`（类未找到）。
   2. **运行时异常（非受检异常）**：
      - 特点：继承自`RuntimeException`，编译时无需强制处理，通常是程序逻辑错误导致。
      - 场景：空指针访问、数组越界、类型转换错误。
      - 示例：`NullPointerException`（空指针）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换异常）。

## Java异常处理有哪些？
Java中常用的异常处理方式有四种，核心是通过`try-catch-finally`、`throw`、`throws`实现：

### 1. try-catch语句块
捕获并处理可能抛出的异常，`try`包含可能出错的代码，`catch`按异常类型匹配处理。可多个`catch`块处理不同异常（子类异常在前，父类异常在后）。
```java
try {
    // 可能抛出异常的代码（如文件读取、除法运算）
    int result = 10 / 0;
} catch (ArithmeticException e1) {
    // 处理算术异常（如除零）
    System.out.println("算术异常：" + e1.getMessage());
} catch (Exception e2) {
    // 处理其他异常（父类异常，放在最后）
    System.out.println("其他异常：" + e2.getMessage());
}
```

### 2. finally块
定义**无论是否发生异常都会执行的代码**，常用于释放资源（如关闭文件流、数据库连接）。
```java
FileInputStream in = null;
try {
    in = new FileInputStream("file.txt");
    // 读取文件
} catch (FileNotFoundException e) {
    System.out.println("文件未找到：" + e.getMessage());
} finally {
    // 无论是否异常，都关闭流
    if (in != null) {
        try {
            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 3. throw语句
手动抛出指定类型的异常，用于在代码中主动触发异常（如参数校验失败）。
```java
public void checkAge(int age) {
    if (age < 0) {
        // 手动抛出非法参数异常
        throw new IllegalArgumentException("年龄不能为负数：" + age);
    }
}
```

### 4. throws关键字
在方法声明中声明**可能抛出的异常类型**，将异常传递给调用者处理（自身不处理）。
```java
// 声明方法可能抛出IO异常，由调用者处理
public void readFile() throws IOException {
    FileInputStream in = new FileInputStream("file.txt");
    in.close();
}

// 调用者处理异常（try-catch）
public static void main(String[] args) {
    try {
        new MyClass().readFile();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 抛出异常为什么不用throws？
无需用`throws`声明异常，主要有两种情况：

### 1. 异常是未检查异常（非受检异常）
未检查异常继承自`RuntimeException`或`Error`，编译器**不强制要求处理**（无需捕获或声明），因此无需用`throws`声明。

示例：`NullPointerException`、`ArrayIndexOutOfBoundsException`均为未检查异常，方法中抛出时无需`throws`：
```java
public void test() {
    String str = null;
    str.length(); // 抛出NullPointerException，无需throws声明
}
```

### 2. 异常在方法内部已被捕获处理
若方法内部用`try-catch`捕获并处理了异常，未向外传递，则无需用`throws`声明。

示例：方法内部处理`IOException`，无需`throws`：
```java
public void readFile() {
    try {
        FileInputStream in = new FileInputStream("file.txt");
        in.close();
    } catch (IOException e) {
        // 内部处理异常，不向外传递
        e.printStackTrace();
    }
}
```

## try catch中的语句运行情况
`try-catch`语句的运行逻辑如下：
1. **try块执行**：`try`中的代码按顺序执行；若执行过程中**未抛出异常**，则跳过所有`catch`块，直接执行`finally`块（若有），再执行后续代码。
2. **异常抛出与catch匹配**：若`try`中抛出异常，立即终止`try`块执行，按`catch`块顺序匹配异常类型：
   - 找到**匹配的catch块**：执行该`catch`块的处理逻辑，然后执行`finally`块（若有），再执行后续代码。
   - 未找到匹配的catch块：异常向上传递给调用者，若调用者也未处理，继续向上传递，直至JVM（JVM会打印异常栈信息并终止程序）。

示例：
```java
try {
    System.out.println("Step 1: try块开始");
    int result = 10 / 0; // 抛出ArithmeticException
    System.out.println("Step 2: try块结束（不会执行）");
} catch (ArithmeticException e) {
    System.out.println("Step 3: 处理算术异常");
} finally {
    System.out.println("Step 4: finally块（必执行）");
}
System.out.println("Step 5: 后续代码（会执行）");

// 输出顺序：Step 1 → Step 3 → Step 4 → Step 5
```

## try{return "a"} fianlly{return "b"}这条语句返回啥
该语句返回**"b"**。

原因：`finally`块的执行优先级高于`try`块的`return`——无论`try`块是否抛出异常，`finally`块都会执行；若`finally`块包含`return`语句，会**覆盖**`try`块的`return`结果，直接返回`finally`中的值。

执行流程：
1. 执行`try`块中的`return "a"`，此时会暂存返回值"a"，但不立即返回。
2. 执行`finally`块中的`return "b"`，直接返回"b"，覆盖暂存的"a"。
3. 程序最终返回"b"，`try`块的`return`不再执行。