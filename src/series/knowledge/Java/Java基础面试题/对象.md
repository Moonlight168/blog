---
order: 5
---
# 对象
## java创建对象有哪些方式？
Java中创建对象的常见方式有5种：
1. **使用new关键字**：直接调用类的构造方法，最常用。
   ```java
   MyClass obj = new MyClass();
   ```
2. **使用Class类的newInstance()方法**：通过反射创建对象，需类有默认构造方法（无参构造）。
   ```java
   MyClass obj = (MyClass) Class.forName("com.example.MyClass").newInstance();
   ```
3. **使用Constructor类的newInstance()方法**：通过反射创建对象，支持调用有参构造方法，更灵活。
   ```java
   // 获取指定构造器（此处以无参构造为例）
   Constructor<MyClass> constructor = MyClass.class.getConstructor();
   MyClass obj = constructor.newInstance();
   ```
4. **使用clone()方法**：类需实现`Cloneable`接口并重写`clone()`方法，创建对象的副本（默认浅拷贝）。
   ```java
   MyClass obj1 = new MyClass();
   MyClass obj2 = (MyClass) obj1.clone();
   ```
5. **使用反序列化**：将序列化后的字节流（如文件中的对象）反序列化为对象，类需实现`Serializable`接口。
   ```java
   // 序列化（写入文件）
   ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("object.ser"));
   out.writeObject(obj);
   out.close();

   // 反序列化（读取对象）
   ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser"));
   MyClass obj = (MyClass) in.readObject();
   in.close();
   ```

## Java创建对象除了new还有别的什么方式?
除`new`关键字外，Java还可通过以下3种方式创建对象：
1. **通过反射创建**：利用`Class`或`Constructor`类的`newInstance()`方法，运行时动态创建对象。
   ```java
   public class MyClass {
       public MyClass() {} // 无参构造
   }

   public class Main {
       public static void main(String[] args) throws Exception {
           Class<?> clazz = MyClass.class;
           MyClass obj = (MyClass) clazz.newInstance(); // 反射创建
       }
   }
   ```
2. **通过反序列化创建**：将序列化的对象字节流（如文件、网络流）反序列化为新对象，类需实现`Serializable`接口。
   ```java
   import java.io.*;

   public class MyClass implements Serializable {
       // 类定义
   }

   public class Main {
       public static void main(String[] args) throws Exception {
           // 序列化：保存对象到文件
           MyClass obj = new MyClass();
           ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("object.ser"));
           out.writeObject(obj);
           out.close();
           
           // 反序列化：从文件读取对象（新对象）
           ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser"));
           MyClass newObj = (MyClass) in.readObject();
           in.close();
       }
   }
   ```
3. **通过clone()方法创建**：类需实现`Cloneable`接口并重写`clone()`方法，创建对象的副本。
   ```java
   public class MyClass implements Cloneable {
       @Override
       public Object clone() throws CloneNotSupportedException {
           return super.clone();
       }
   }

   public class Main {
       public static void main(String[] args) throws CloneNotSupportedException {
           MyClass obj1 = new MyClass();
           MyClass obj2 = (MyClass) obj1.clone(); // 克隆创建新对象
       }
   }
   ```

## New出的对象什么时候回收？
`new`创建的对象由Java**垃圾回收器（GC）** 自动回收，回收时机由GC根据算法判断，核心是"对象不再被引用"。

GC判断对象可回收的主要算法：
1. **引用计数法**：对象的引用计数器为0时，表示无引用，可回收。例如，`MyClass obj = new MyClass(); obj = null;`，对象引用计数变为0，可被回收。
2. **可达性分析算法**：从"根对象"（如方法区静态属性、栈中局部变量）出发，遍历引用链；若对象无任何引用链可达（不可达），则可回收。例如，方法执行完毕，局部变量对象成为不可达对象，可被回收。

此外，若对象重写了`finalize()`方法，GC回收前会调用该方法（仅一次），对象可在方法中尝试"自救"（重新建立引用）；但`finalize()`执行时机不确定，且可能导致性能问题，不推荐使用。

GC的回收操作是自动的，开发者无法精确控制回收时间，但可通过`System.gc()`建议GC执行（仅建议，不保证立即执行）。

## 如何获取私有对象？
Java中，私有对象（`private`修饰的成员变量或方法）仅能在类内部访问，外部需通过以下两种方式间接获取：

### 1. 使用公共访问器方法（getter 方法）
类的设计者通常为私有成员变量提供`public`的`getter`方法，外部通过调用该方法安全获取私有对象。这是符合面向对象封装原则的推荐方式。
```java
class MyClass {
    // 私有成员变量
    private String privateField = "私有字段的值";

    // 公共getter方法
    public String getPrivateField() {
        return privateField;
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        // 通过getter获取私有字段值
        String value = obj.getPrivateField();
        System.out.println(value); // 输出：私有字段的值
    }
}
```

### 2. 使用反射机制
反射可绕过`private`访问限制，在运行时获取私有成员。需注意，这种方式破坏封装性，可能引发安全问题，需谨慎使用。
```java
import java.lang.reflect.Field;

class MyClass {
    private String privateField = "私有字段的值";
}

public class Main {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        MyClass obj = new MyClass();
        // 1. 获取Class对象
        Class<?> clazz = obj.getClass();
        // 2. 获取私有字段（getDeclaredField()获取所有字段，包括private）
        Field privateField = clazz.getDeclaredField("privateField");
        // 3. 设置字段可访问（绕过private限制）
        privateField.setAccessible(true);
        // 4. 获取私有字段的值
        String value = (String) privateField.get(obj);
        System.out.println(value); // 输出：私有字段的值
    }
}