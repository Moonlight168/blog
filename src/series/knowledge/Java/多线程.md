---
title: 多线程
date: 2025-05-17
icon: /assets/icon/分布式.png
---

##  ⭐Java 中的多线程实现方式有哪些？
1. **继承 `Thread` 类**

    * 创建子类继承 `Thread`，重写 `run()` 方法。
    * 调用 `start()` 启动线程。

   ```java
   class MyThread extends Thread {
       public void run() {
           System.out.println("Thread running");
       }
   }

   public class Main {
       public static void main(String[] args) {
           MyThread t = new MyThread();
           t.start();  // 启动线程
       }
   }
   ```

2. **实现 `Runnable` 接口**

    * 实现 `Runnable` 接口，重写 `run()` 方法。
    * 传入 `Thread` 构造函数，调用 `start()` 启动。

   ```java
   class MyRunnable implements Runnable {
       public void run() {
           System.out.println("Runnable running");
       }
   }

   public class Main {
       public static void main(String[] args) {
           MyRunnable r = new MyRunnable();
           Thread t = new Thread(r);
           t.start();  // 启动线程
       }
   }
   ```

3. **使用 `Callable` 和 `Future`**

    * 实现 `Callable` 接口，支持返回值和异常处理。
    * 通过 `ExecutorService.submit()` 提交任务，使用 `Future.get()` 获取结果。

   ```java
   import java.util.concurrent.*;

   class MyCallable implements Callable<String> {
       public String call() {
           return "Callable running";
       }
   }

   public class Main {
       public static void main(String[] args) throws Exception {
           ExecutorService executor = Executors.newFixedThreadPool(1);
           // 提交Callable任务并获取Future对象，用于获取线程执行结果
           Future<String> future = executor.submit(new MyCallable());
           // 通过future.get()阻塞等待线程执行完成，并获取返回值
           System.out.println(future.get());  // 输出 Callable 执行结果           executor.shutdown();
       }
   }
   ```

4. **使用线程池 (`ExecutorService`)**

    * 管理和调度线程，减少线程创建开销。
    * 常用线程池：`FixedThreadPool`，`CachedThreadPool`。

   ```java
   import java.util.concurrent.*;

   public class Main {
       public static void main(String[] args) {
           ExecutorService executor = Executors.newFixedThreadPool(2);
           executor.submit(() -> System.out.println("Thread pool running"));
           executor.shutdown();
       }
   }
   ```

5. **使用 `ForkJoinPool`**

    * 适合分治任务，通过 `ForkJoinTask` 执行并行计算。

   ```java
   import java.util.concurrent.*;

   class MyTask extends RecursiveTask<Integer> {
       private final int n;

       public MyTask(int n) {
           this.n = n;
       }

       @Override
       protected Integer compute() {
           if (n <= 1) {
               return 1;
           } else {
               MyTask task1 = new MyTask(n - 1);
               task1.fork();
               return n * task1.join();
           }
       }
   }

   public class Main {
       public static void main(String[] args) {
           ForkJoinPool pool = new ForkJoinPool();
           MyTask task = new MyTask(5);
           System.out.println(pool.invoke(task));  // 输出 120
       }
   }
   ```

#### **总结：**

* **继承 `Thread`**：简单，适合单任务。
* **`Runnable`**：灵活，适合多个任务共享。
* **`Callable` + `Future`**：支持返回值。
* **线程池**：高效管理线程。
* **`ForkJoinPool`**：大规模并行计算。


##  什么是线程安全？如何实现？

**回答：**
线程安全指在多线程环境下运行结果正确、状态不被破坏。常见方式有：

* 使用 `synchronized`、Lock 加锁；
* 使用线程安全类如 `ConcurrentHashMap`；
* 使用原子类（如 `AtomicInteger`）进行 CAS 操作。


## **HashMap 和 Hashtable 的区别：**

| **维度**       | **HashMap**                                 | **Hashtable**                   |
| ------------ | ------------------------------------------- | ------------------------------- |
| **线程安全**     | 不是线程安全的，多个线程同时访问时需要手动同步。                    | 线程安全的，所有方法都被 `synchronized` 修饰。 |
| **性能**       | 性能较高，因为不涉及同步操作。                             | 性能较低，因为每个方法都要进行同步。              |
| **null 键和值** | 允许一个 `null` 键和多个 `null` 值。                  | 不允许 `null` 键和 `null` 值。         |
| **迭代器**      | 使用 `Iterator`，是 fail-fast 的（即发现结构修改会抛出异常）。  | 使用 `Enumerator`，不是 fail-fast 的。 |
| **继承关系**     | 继承自 `AbstractMap` 类。                        | 继承自 `Dictionary` 类。             |
| **使用场景**     | 适用于非线程安全的场景，需要高性能时使用。                       | 适用于多线程环境下，需要线程安全时使用。            |
| **可扩展性**     | 提供更好的灵活性，可以通过 `ConcurrentHashMap` 替代线程安全需求。 | 因为本身是线程安全的，但不够高效，已不常使用。         |

#### **总结：**

* **HashMap** 更常用，因为它具有较好的性能和灵活性，适合大多数非线程安全的场景。
* **Hashtable** 由于性能较低和过时，现在很少使用，通常用 `ConcurrentHashMap` 替代。

## 什么是线程的虚假唤醒？为什么if而用 while？

**回答：**

在Java的多线程编程中，使用 `while` 循环而非 `if` 来检查等待条件是**线程安全的关键实践**，主要原因是需要防御**虚假唤醒（Spurious Wakeup）**和**条件状态变化**。


#### **1. 虚假唤醒（Spurious Wakeup）**
- **定义**：线程可能在没有被明确通知（如 `notify()`/`notifyAll()`）的情况下从 `wait()` 中苏醒。
- **原因**：这是Java语言规范允许的行为，通常由底层操作系统或JVM优化导致。
- **风险**：如果使用 `if` 检查条件，线程被虚假唤醒后会直接跳过条件检查，继续执行后续代码，可能导致状态不一致。

**示例**（错误写法，使用 `if`）：
```java
synchronized (lock) {
    if (step != 1) {  // 只检查一次
        lock.wait();
    }
    // 虚假唤醒时，即使step≠1也会执行这里
    printSecond.run();  // 可能在step≠1时执行，导致顺序错乱
}
```

#### **2. 条件状态可能被其他线程改变**
- 当线程被唤醒时，条件可能已经被其他线程再次改变。
- **示例场景**：
    1. 线程B在 `step=1` 时被唤醒。
    2. 线程A抢先执行并将 `step` 重置为0。
    3. 线程B如果只用 `if` 检查，会直接执行后续代码，导致 `step≠1` 时仍执行 `printSecond`。

**正确写法（使用 `while`）**：
```java
synchronized (lock) {
    while (step != 1) {  // 每次苏醒后都重新检查条件
        lock.wait();
    }
    // 只有step==1时才会执行
    printSecond.run();
}
```

#### **为什么避免在多线程编程中使用 `static` 变量？**

1. **线程安全问题**：

    * `static` 变量是类级别的变量，不属于任何一个特定实例。所有线程共享同一个 `static` 变量，这就可能导致多个线程同时访问并修改该变量，从而引发数据不一致问题。

2. **可见性问题**：

    * 即使使用 `synchronized` 或 `volatile` 来保护 `static` 变量，多个线程可能会看到过时的或不一致的值，因为缓存一致性或内存屏障问题可能导致不同线程对 `static` 变量的视图不一致。

3. **不可预期的行为**：

    * 在多线程环境下，`static` 变量的状态可能会在不同线程之间传递，这可能导致不可预期的行为，特别是在不当使用的情况下。

4. **设计问题**：

    * `static` 变量通常会使代码的可测试性和可维护性降低。它使得状态在类级别上共享，这与对象的封装原则冲突，容易导致耦合和难以理解的代码。

#### **如何避免**：

* 使用实例变量而非 `static` 变量。
* 如果必须使用 `static` 变量，确保对其访问进行适当的同步或使用线程安全的数据结构（如 `AtomicInteger`）。


## **什么是锁？**

锁是多线程编程中的机制，用于控制对共享资源的访问，确保每次只有一个线程访问资源，避免并发问题。

## **为什么需要锁？**

1. **防止数据竞态**：避免多个线程同时修改共享资源导致数据不一致。
2. **保证线程安全**：确保只有一个线程能访问共享资源，保持数据完整性。
3. **避免死锁和阻塞**：合理使用锁避免线程相互等待。
4. **控制访问顺序**：协调线程访问资源，避免冲突。


## **Java中的主要锁机制？**

1. **内置锁（Synchronized）**

    * **描述**：通过 `synchronized` 关键字实现锁，保证同一时刻只有一个线程能执行被同步的代码块。
    * **应用**：可用于方法或代码块。

2. **显示锁（ReentrantLock）**

    * **描述**：`java.util.concurrent.locks.ReentrantLock` 提供了更灵活的锁控制，支持可重入锁、尝试加锁、超时加锁等功能。
    * **应用**：适用于需要更多控制的场景（如死锁避免）。

3. **读写锁（ReadWriteLock）**

    * **描述**：`java.util.concurrent.locks.ReadWriteLock`，提供读锁和写锁。允许多个线程并发读取，但写操作时需要独占锁。
    * **应用**：适用于读多写少的场景。

4. **自旋锁（SpinLock）**

    * **描述**：线程在获取锁时不断循环判断是否可以获得锁，不会立即挂起线程，减少上下文切换的开销。
    * **应用**：适用于短时间锁定资源的场景。

5. **乐观锁（CAS）**

    * **描述**：通过 `java.util.concurrent.atomic` 包中的原子变量实现，通过比较和交换操作保证数据一致性。
    * **应用**：适用于无锁并发控制和高效的锁竞争场景。

6. **偏向锁、轻量级锁、重量级锁**

    * **描述**：Java虚拟机实现的锁优化，分别用于单线程、线程竞争较小、线程竞争较大的场景。
    * **应用**：自动根据竞争情况进行优化。

#### **总结：**

* **Synchronized**：简单、常用，适合小范围同步。
* **ReentrantLock**：提供更多控制，适合复杂锁需求。
* **ReadWriteLock**：优化读多写少场景。
* **CAS**：无锁并发控制。

## **`synchronized` 的使用方式：**

1. **同步实例方法**

    * **作用**：锁定当前对象实例 (`this`)，确保同一时间只有一个线程能执行该实例的方法。

   ```java
   public synchronized void method() {
       // 同步代码
   }
   ```

2. **同步静态方法**

    * **作用**：锁定类的 `Class` 对象，确保同一时间只有一个线程能执行该类的静态方法。

   ```java
   public static synchronized void staticMethod() {
       // 同步代码
   }
   ```

3. **同步代码块（实例锁）**

    * **作用**：通过指定某个对象作为锁，锁定特定代码块，其他线程必须等待该锁释放后才能进入该代码块。

   ```java
   public void method() {
       synchronized (lockObject) {
           // 同步代码块
       }
   }
   ```

4. **同步代码块（类锁）**

    * **作用**：锁定类的 `Class` 对象，用于控制对静态代码块的访问。

   ```java
   public void method() {
       synchronized (MyClass.class) {
           // 同步代码块
       }
   }
   ```


## **什么是可重入锁（Reentrant Lock）？**

可重入锁是指同一线程可以多次获取同一把锁，而不会发生死锁的情况。换句话说，线程在已经持有锁的情况下，如果再次请求该锁，能够成功获得，而不会被阻塞。

#### **工作原理：**

* 当一个线程获得了可重入锁后，它可以多次获取该锁，每次获取时都会对锁的计数器进行增加，直到调用 `unlock()` 的次数与锁的获取次数相等时，锁才会真正被释放。

#### **特点：**

1. **避免死锁**：同一线程可以重复获取自己已经拥有的锁，而不会造成阻塞或死锁。
2. **递归调用**：当方法内部调用了自己（递归调用）或者调用了其他需要锁的代码时，可以顺利执行。

#### **常见实现：**

1. **`synchronized`**：Java的内置 `synchronized` 锁就是可重入的。
2. **`ReentrantLock`**：`java.util.concurrent.locks.ReentrantLock` 也是可重入的。

#### **示例：**

1. **使用 `synchronized`（隐式可重入锁）**：

   ```java
   public class ReentrantExample {
       public synchronized void method1() {
           method2();  // 同一线程可以重复获取锁
       }

       public synchronized void method2() {
           System.out.println("Inside method2");
       }
   }
   ```

2. **使用 `ReentrantLock`（显式可重入锁）**：

   ```java
   import java.util.concurrent.locks.ReentrantLock;

   public class ReentrantLockExample {
       private final ReentrantLock lock = new ReentrantLock();

       public void method1() {
           lock.lock();
           try {
               method2();  // 同一线程可以重复获取锁
           } finally {
               lock.unlock();
           }
       }

       public void method2() {
           lock.lock();
           try {
               System.out.println("Inside method2");
           } finally {
               lock.unlock();
           }
       }
   }
   ```

#### **总结：**

* **可重入性**：允许线程在持有锁的情况下再次获得该锁，避免死锁。
* **`synchronized`** 和 **`ReentrantLock`** 都支持可重入性，但 `ReentrantLock` 提供了更多的控制，例如可以尝试锁定、定时锁等。


##  `ReentrantLock`与`synchronized`的区别是什么？
| 特性                | `synchronized`               | `ReentrantLock`              |
|---------------------|-----------------------------|-----------------------------|
| 锁获取方式          | 隐式获取和释放              | 显式调用`lock()`和`unlock()` |
| 可中断性            | 不可中断                    | 可中断（`lockInterruptibly()`） |
| 尝试锁              | 不支持                      | 支持（`tryLock()`）          |
| 公平性              | 非公平                      | 可选择公平或非公平          |
| 条件变量            | 单一`wait/notify`机制       | 可创建多个`Condition`对象    |


## 什么是读写锁（ReadWriteLock）？

`ReadWriteLock` 是一种锁机制，允许多个线程同时读取共享资源，但在写操作时，确保只有一个线程可以修改资源。这种机制能够提高性能，尤其是读操作频繁的场景。

#### **工作原理：**

* **读锁（Read Lock）**：允许多个线程同时持有，只要没有线程持有写锁。多个线程可以并行执行读操作。
* **写锁（Write Lock）**：只有一个线程可以持有，并且在持有写锁时，其他任何线程都无法获取读锁或写锁。

#### **优点：**

* **并发性**：读锁允许多个线程同时读取，提高并发性能。
* **排他性**：写锁是独占的，确保写操作的正确性。

#### **常见实现：**

1. **`ReentrantReadWriteLock`**：Java中 `java.util.concurrent.locks` 包中的实现，提供了读锁和写锁。

#### **示例：**

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockExample {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private int count = 0;

    // 读操作
    public void read() {
        rwLock.readLock().lock();
        try {
            System.out.println("Reading: " + count);
        } finally {
            rwLock.readLock().unlock();
        }
    }

    // 写操作
    public void write(int value) {
        rwLock.writeLock().lock();
        try {
            count = value;
            System.out.println("Writing: " + count);
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    public static void main(String[] args) {
        ReadWriteLockExample example = new ReadWriteLockExample();
        
        // 读操作
        new Thread(example::read).start();
        new Thread(example::read).start();

        // 写操作
        new Thread(() -> example.write(100)).start();
    }
}
```

#### **总结：**

* **读写锁**适用于读多写少的场景，可以提高并发性能。
* **`ReentrantReadWriteLock`** 是 `ReadWriteLock` 的常见实现，允许多个线程并行读取资源，但写操作是独占的。


## 什么是公平锁和非公平锁？
- **公平锁**：线程按照请求锁的顺序获取锁，先到先得
- **非公平锁**：线程获取锁的顺序不确定，可能后请求的线程先获得锁

`ReentrantLock`默认是非公平锁，可以通过构造函数指定为公平锁：
```java
Lock fairLock = new ReentrantLock(true); // 公平锁
```

## 什么情况下选择`synchronized`，什么情况下选择`ReentrantLock`？
- **选择`synchronized`**：
    - 代码简单，不需要高级锁特性
    - 优先考虑代码简洁性和可读性

- **选择`ReentrantLock`**：
    - 需要可中断锁、尝试锁或公平锁
    - 需要使用多个条件变量
    - 对锁的性能有更高要求

c
CAS是一种无锁算法，用于实现原子操作。它包含三个操作数：
- 内存位置（V）
- 预期原值（A）
- 新值（B）

如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。Java中的`Atomic`类（如`AtomicInteger`）基于CAS实现。

## `StampedLock`是什么？
`StampedLock` 是 Java 8 引入的一种锁机制，主要用于提高高并发环境下的性能，特别是在读操作远远多于写操作的场景中。

#### **特点**：

1. **乐观读**：允许线程在不获取锁的情况下读取共享数据（称为乐观锁）。只有在写锁竞争时，才会升级为悲观锁。
2. **悲观读**：类似传统的读锁，获取锁后才能读取数据。
3. **写锁**：与传统的写锁类似，写操作需要独占锁。

#### **优点**：

* 提供更高的并发性，特别是读多写少的场景。
* 通过乐观锁减少了不必要的锁竞争，提高了效率。

#### **使用方式**：

* `readLock()`：获取乐观锁。
* `tryOptimisticRead()`：尝试乐观锁，如果读取的数据未被修改则可直接使用，若被修改则需要获取悲观锁。
* `writeLock()`：获取写锁。
* `unlock()`：释放锁。

#### **示例**：

```java
import java.util.concurrent.locks.StampedLock;

public class StampedLockExample {
    private final StampedLock lock = new StampedLock();
    private int count = 0;

    // 乐观读操作
    public int optimisticRead() {
        long stamp = lock.tryOptimisticRead(); // 获取乐观锁
        int currentCount = count; // 乐观读取数据
        if (!lock.validate(stamp)) { // 如果数据被修改，进行悲观读操作
            stamp = lock.readLock(); // 获取悲观读锁，可能会阻塞直到没有写锁
            try {
                currentCount = count; // 再次读取数据
            } finally {
                lock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return currentCount; // 返回读取的数据
    }

    // 写操作
    public void increment() {
        long stamp = lock.writeLock();
        try {
            count++;
        } finally {
            lock.unlockWrite(stamp);
        }
    }
}
```

##  锁与原子类的区别是什么？
- **锁**：通过阻塞线程来保证线程安全，适合保护复杂的操作
- **原子类**：基于CAS实现，是非阻塞的，适合简单的原子操作

原子类（如`AtomicInteger`）通常比锁具有更好的性能，特别是在竞争较少的情况下。

## 什么是锁的饥饿和公平性问题？
- **锁饥饿**：某些线程长期无法获得锁，导致程序性能下降
- **公平性**：通过公平锁机制确保所有线程都有机会获得锁

公平锁可以减少锁饥饿问题，但会带来一定的性能开销。


## **乐观锁的典型实现方式有哪些？**
**回答**：
1. **版本号机制**：
    - 每次修改数据时递增版本号。
    - 线程读取数据时记录版本号，更新时检查版本号是否与读取时一致。
    - 示例：数据库表中添加`version`字段。

2. **CAS（Compare-and-Swap）**：
    - 原子操作，三个参数：内存值（V）、预期原值（A）、新值（B）。
    - 如果 V == A，则将 V 更新为 B；否则操作失败。
    - Java中的`AtomicInteger`类基于CAS实现。



## **CAS的底层原理是什么？**
**回答**：
- **硬件支持**：CAS依赖CPU的原子指令（如x86的`CMPXCHG`），确保操作的原子性。
- **Java实现**：
    - `Unsafe`类的`compareAndSwap`方法是CAS的核心。
    - `AtomicInteger`等原子类通过`Unsafe`实现无锁操作。
- **示例**：
  ```java
  public final boolean compareAndSet(int expect, int update) {
      return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
  }
  ```

## **乐观锁有哪些优缺点？**

**优点：**

1. **无锁开销**：无锁机制，提高了并发性能。
2. **非阻塞**：线程不会被阻塞，减少上下文切换。
3. **适合读多写少的场景**：当冲突较少时，性能极高。

**缺点：**

1. **冲突时重试消耗资源**：频繁的冲突会导致线程重试，浪费CPU资源。

**冲突通常指：**

- **数据版本冲突：** 一个线程在读取数据时，其他线程可能已经修改了数据。乐观锁通过记录版本号或时间戳，来检测在操作期间数据是否被其他线程修改。

- **重试消耗：** 乐观锁在检测到冲突时会让线程重试操作，如果冲突发生频繁，线程就会反复重试，消耗CPU资源，影响性能。

2. **不适合长事务**：长时间持有数据可能增加冲突的概率。比如线程A占用数据的时间非常长（例如复杂计算），线程B可能在乐观锁的“验证阶段”发现版本号已被更新，导致线程B必须反复尝试。
3. **ABA问题**：若数据值被修改后再恢复原值，乐观锁无法检测到（可以使用`AtomicStampedReference`解决）。


## **什么是ABA问题？如何解决？**
**回答**：
- **问题描述**：值从A变为B再变回A，CAS操作误认为值未修改。
- **解决方案**：
    - **版本号**：使用`AtomicStampedReference`，每次修改时增加版本号。
    - **时间戳**：记录值的修改时间，确保唯一性。


##  **乐观锁和悲观锁的适用场景分别是什么？**
**回答**：

| **场景**         | **乐观锁**               | **悲观锁**               |
|------------------|------------------------|------------------------|
| **读写比例**       | 读多写少               | 写多读少               |
| **冲突频率**       | 冲突少                 | 冲突多                 |
| **典型实现**       | CAS、版本号             | `synchronized`、`ReentrantLock` |
| **示例**         | 缓存更新、数据库乐观锁   | 临界区代码、数据库行锁   |


## 什么是 Condition 接口？
**回答：**

Condition接口是 Java 并发包（java.util.concurrent.locks）中的一个组件，用于替代传统的`Object.wait()`、`notify()`和`notifyAll()`方法，提供更灵活的线程等待和唤醒机制。

与 Lock 配合使用：Condition实例通过Lock.newCondition()创建，每个Lock可以关联多个Condition对象。


## Condition 的核心方法有哪些？
**回答：**
- 等待方法：
    - `await()`：当前线程进入等待状态，直到被唤醒或中断。
    - `await(long time, TimeUnit unit)`：带超时的等待。
    - `awaitUninterruptibly()`：不可中断的等待。
    - `awaitUntil(Date deadline)`：等待到指定时间。
- 唤醒方法：
    - `signal()`：唤醒一个等待在该 Condition 上的线程。
    - `signalAll()`：唤醒所有等待线程。
