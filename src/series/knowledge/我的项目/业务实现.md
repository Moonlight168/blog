---
series: 我的项目
title: 业务实现
icon: /assets/icon/业务.png
order: 4
---

## **扫码登录如何实现？**

**核心流程：**

1. **生成二维码（UUID）**
   后端生成一个临时 `loginToken`，存 Redis，设短期过期（如 60 秒）。
   前端展示二维码，二维码内容为：

   ```
   https://xxx.com/qrLogin?token=xxxx
   ```

2. **轮询登录状态**
   网页端每 1~2 秒轮询 Redis 查询该 `token` 是否被确认。

3. **手机扫码 → 授权**
   用户打开 App/小程序 → 扫码 → 将登录授权请求发送给后端：

   ```
   loginToken + 用户凭证（如 userId / session / jwt）
   ```

   后端验证后将 Redis 中 `token` 状态改为 “已确认并绑定 userId”。

4. **网页端完成登录**
   轮询收到状态变为已确认 → 后端生成正式 JWT → 浏览器完成登录。


**为什么微信只能扫码登录？**

**因为 PC 端无法直接拿到微信账号体系的凭证。**
微信的登录凭证（OpenID、SessionKey）只能通过 **微信客户端或小程序内部**调用微信 API 获得，网页环境无法拿到微信的用户授权。

所以微信 PC 端必须通过手机授权（扫码登录）才能确认用户身份。

## **分享邀请如何判断邀请来源？如何防刷？**

**一、如何判断是谁邀请的？**

**给邀请链接加 inviterId：**

```
https://xxx.com/register?inviterId=12345
```

新人注册时带上此字段，后端记录邀请关系即可。


**二、防刷方案：**

1. **限制同设备/同 IP 的注册次数**

    * 设备指纹
    * IP 限流（如 1 小时只能注册 1 次）

2. **手机号唯一性**
   一个手机号只能被邀请一次。

3. **风控校验**

    * 注册号段黑名单
    * 代理 IP / 云主机 IP 自动拒绝
    * 频繁注册的设备直接拉黑

4. **行为验证**

    * 图形验证码
    * 滑块验证
    * 短信验证码限制（1 小时 n 次）

5. **延迟发放奖励**
   如：被邀请者满足 **登录+使用 3 天** 才给奖励，减少恶意批量注册。

## 假设有一个用户量级达上千万或上亿的系统，举办营销活动让用户抢同一个产品，如何保证该产品只能被一个人抢到？

核心方案：**Redis分布式锁（Redisson）+ 数据库乐观锁（version/库存字段）双校验**，配合库存预扣减+异步确认，步骤如下：

1. 用户抢单先抢**Redis锁**（按商品ID设锁，防并发）；
2. 抢到锁后，数据库执行 `update 商品表 set 库存=库存-1 where 商品ID=xxx and 库存>0`（乐观锁本质，update语句原子操作防超卖）；
3. 若更新行数>0，抢单成功；否则失败，释放Redis锁；
4. 异步同步订单状态，超时未支付自动回滚库存。

## 有商品售卖系统和商品后台管理系统两个系统，商家在运营管理系统更新商品数量（如苹果今日上限100个、明日上限200个）时，如何让数据实时同步，使用户在售卖系统查询时能看到最新数量？

### **1. 直接数据库同步（简单但实时性好）**

* 两个系统用同一个数据库表
* 后台管理系统更新库存后，售卖系统直接查数据库拿最新数据
* 优点：实时性强、实现简单
* 缺点：数据库压力大，高并发时可能拖垮系统

### **2. 缓存 + 消息队列异步刷新（高性能）**

* **缓存层**：售卖系统把商品库存放 Redis 里
* **消息队列**：
   1. 商家在后台系统更新库存表后，发个消息到 MQ（像 Kafka、RabbitMQ 那种）
   2. 售卖系统订阅 MQ，收到消息就更新 Redis 缓存
* **查询逻辑**：售卖系统先查 Redis，没有再查数据库
* 优点：高并发时查询快、数据库压力小
* 需要注意：确保消息靠谱投递，别让库存数据对不上

### **3. 事件驱动 + 缓存预热（再优化一下）**
 

* 对每日限量、秒杀库存这些特殊情况，后台管理系统一更新就立刻刷新 Redis
* 可以配合过期时间或者预扣库存机制，保证售卖系统在高并发时看到的库存和后台一致
