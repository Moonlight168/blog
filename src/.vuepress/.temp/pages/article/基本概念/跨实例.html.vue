<template><div><p>在分布式系统中，“跨实例”指的是<strong>多个独立部署的服务进程（实例），在协作处理同一任务或操作同一资源时的交互场景</strong>。简单说，就是“你的代码不是只在一台机器/一个进程里跑，而是在多台机器/多个进程里跑，这些进程之间需要协同工作”——这也是分布式系统区别于单体系统的核心特征，更是分布式锁要解决的核心问题。</p>
<h3 id="一、先理解-实例-什么是服务实例" tabindex="-1"><a class="header-anchor" href="#一、先理解-实例-什么是服务实例"><span>一、先理解“实例”：什么是服务实例？</span></a></h3>
<p>在解释“跨实例”前，先明确“实例”的概念：<br>
当你把一个Java服务（如淘票票的支付服务）打包成Jar/War包后，<strong>每启动一次这个Jar包，就生成一个“服务实例”</strong>。每个实例拥有独立的内存空间、线程池，运行在独立的进程中（甚至不同的服务器上）。</p>
<p>举个具体例子：<br>
你开发了一个支付服务<code v-pre>pay-service</code>，为了应对高并发（如淘票票的节假日高峰期），你在3台服务器上各启动了一个<code v-pre>pay-service</code>进程：</p>
<ul>
<li>实例1：运行在服务器A（IP：192.168.0.101）</li>
<li>实例2：运行在服务器B（IP：192.168.0.102）</li>
<li>实例3：运行在服务器C（IP：192.168.0.103）</li>
</ul>
<p>这3个<code v-pre>pay-service</code>进程，就是3个“服务实例”，它们的代码完全相同，但运行环境、内存数据完全独立。</p>
<h3 id="二、-跨实例-场景-多个实例如何交互" tabindex="-1"><a class="header-anchor" href="#二、-跨实例-场景-多个实例如何交互"><span>二、“跨实例”场景：多个实例如何交互？</span></a></h3>
<p>“跨实例”的核心是“多个实例共享同一资源或协作处理同一任务”，最典型的场景就是<strong>并发操作同一数据</strong>——这也是分布式锁要解决的痛点。</p>
<p>以淘票票的“支付”场景为例，看看“跨实例”会带来什么问题：</p>
<ol>
<li>用户小明点击“支付”按钮，请求被负载均衡器分配到<strong>实例1</strong>；</li>
<li>几乎同时，小明误触再次点击“支付”，第二个请求被分配到<strong>实例2</strong>；</li>
<li>两个实例同时执行“支付逻辑”：查询订单状态→调用支付渠道→扣减金额；</li>
<li>若没有分布式锁控制，会导致小明被“重复支付”（扣两次钱）。</li>
</ol>
<p>这个场景中，<strong>实例1和实例2就是“跨实例”</strong>，它们在无协调的情况下操作同一订单资源，引发并发冲突。</p>
<h3 id="三、为什么-本地锁-解决不了跨实例问题" tabindex="-1"><a class="header-anchor" href="#三、为什么-本地锁-解决不了跨实例问题"><span>三、为什么“本地锁”解决不了跨实例问题？</span></a></h3>
<p>很多人会疑惑：“我在代码里用<code v-pre>synchronized</code>或<code v-pre>ReentrantLock</code>加了锁，为什么还会出现跨实例并发问题？”<br>
因为<code v-pre>synchronized</code>、<code v-pre>ReentrantLock</code>是<strong>本地锁</strong>，它们的作用范围仅限于“单个实例内部”，无法跨实例生效。</p>
<p>还是以支付场景为例：</p>
<ul>
<li>实例1中的<code v-pre>synchronized</code>锁，只能控制实例1内部的线程并发（如实例1的线程1和线程2不会同时执行支付）；</li>
<li>但实例1的锁“管不到”实例2，实例2的线程仍能自由执行支付逻辑；</li>
<li>最终两个实例还是会并发操作同一订单，导致重复支付。</li>
</ul>
<p>这就是“跨实例”场景的核心挑战：<strong>本地锁只能控制单实例内的并发，跨实例的并发需要“所有实例都能识别的共享锁”</strong>——这也是分布式锁（如Redisson实现的锁）的价值所在。</p>
<h3 id="四、-跨实例-场景的解决方案-共享锁-统一协调" tabindex="-1"><a class="header-anchor" href="#四、-跨实例-场景的解决方案-共享锁-统一协调"><span>四、“跨实例”场景的解决方案：共享锁+统一协调</span></a></h3>
<p>要解决跨实例的并发问题，核心是让所有实例“共享同一把锁”，通常需要一个<strong>独立的第三方协调组件</strong>（如Redis、ZooKeeper、Etcd）来存储锁信息，确保所有实例都能“看到”锁的状态。</p>
<p>以淘票票的Redisson分布式锁为例，跨实例的协调流程是：</p>
<ol>
<li>实例1和实例2在执行支付前，都会向Redis请求获取“订单123”的锁；</li>
<li>Redis通过<code v-pre>Hash</code>结构记录锁的持有者（如实例1的线程），实例2请求时会发现锁已被占用；</li>
<li>实例1执行完支付后，向Redis释放锁；</li>
<li>Redis删除锁记录，实例2才能获取到锁（若仍有请求）。</li>
</ol>
<p>在这个流程中，Redis就是“统一协调组件”，所有实例通过Redis判断锁的状态，从而实现跨实例的并发控制。</p>
<h3 id="五、总结-跨实例-是分布式系统的核心特征" tabindex="-1"><a class="header-anchor" href="#五、总结-跨实例-是分布式系统的核心特征"><span>五、总结：“跨实例”是分布式系统的核心特征</span></a></h3>
<ul>
<li><strong>定义</strong>：多个独立的服务实例，协作处理同一任务或操作同一资源的场景；</li>
<li><strong>痛点</strong>：本地锁失效，易出现重复操作、数据不一致等并发问题；</li>
<li><strong>解决方案</strong>：通过Redis、ZooKeeper等组件实现分布式锁，让所有实例共享同一把锁；</li>
<li><strong>典型场景</strong>：淘票票的支付防重复、电影票库存防超卖、订单状态同步等。</li>
</ul>
<p>理解“跨实例”，就能理解分布式锁的必要性——它本质是为了解决“多个独立进程如何安全共享资源”的问题，是分布式系统高并发防护的核心技术。</p>
</div></template>


