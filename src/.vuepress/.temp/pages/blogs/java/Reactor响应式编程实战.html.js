import comp from "F:/MyBlogSite/vuepress-theme-hope/my-docs/src/.vuepress/.temp/pages/blogs/java/Reactor响应式编程实战.html.vue"
const data = JSON.parse("{\"path\":\"/blogs/java/Reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98.html\",\"title\":\"Reactor响应式编程实战:从Flux|Mono到Spring Cloud Gateway应用\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Reactor响应式编程实战:从Flux|Mono到Spring Cloud Gateway应用\",\"date\":\"2025-10-18T00:00:00.000Z\",\"category\":\"Java\",\"tags\":[\"Reactor\",\"Spring Cloud Gateway\"]},\"git\":{},\"readingTime\":{\"minutes\":18.9,\"words\":5669},\"filePathRelative\":\"blogs/java/Reactor响应式编程实战.md\",\"excerpt\":\"<p>在微服务架构里，高并发场景就像“早高峰的地铁站”——传统同步编程的“排队检票”模式很容易堵死，而响应式编程的“异步分流”模式能让系统更高效地处理请求。作为Java响应式编程的“基石”，Reactor框架基于<strong>Reactive Streams规范</strong>和<strong>Java 8特性</strong>（Lambda、CompletableFuture）实现，底层还整合了Netty的非阻塞IO能力，专门解决“高并发下的资源浪费”问题；而Spring Cloud Gateway则基于Reactor，把这种能力落地到网关层，帮我们处理路由、过滤等核心需求。今天就从基础到实战，把Reactor和Gateway的核心逻辑讲明白，重点解答“请求体只能读一次”“重新创建的Flux为何能重复订阅”这些高频坑。</p>\"}")
export { comp, data }
