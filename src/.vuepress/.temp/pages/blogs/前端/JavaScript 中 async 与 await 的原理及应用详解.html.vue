<template><div><p>在JavaScript异步编程领域，<code v-pre>async</code>和<code v-pre>await</code>是极为重要的语法特性。它们基于Promise和Generator函数，为异步操作提供了更简洁、易读的语法，极大地改善了开发者处理异步任务的体验。本文将深入剖析<code v-pre>async</code>和<code v-pre>await</code>的原理、执行机制以及实际应用场景。</p>
<h2 id="一、async与await基础概念" tabindex="-1"><a class="header-anchor" href="#一、async与await基础概念"><span>一、async与await基础概念</span></a></h2>
<p><code v-pre>async</code>是用于声明异步函数的关键字，它返回的是一个<code v-pre>Promise</code>对象。<code v-pre>await</code>则只能在<code v-pre>async</code>函数内部使用，用于等待一个<code v-pre>Promise</code>对象的状态变为<code v-pre>fulfilled</code>或<code v-pre>rejected</code> ，并获取其结果。示例代码如下：</p>
<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code" v-pre=""><code class="language-js"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> fetchData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> response</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> await</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> fetch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">'https://api.example.com'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> data</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> await</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B"> response</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">json</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">'获取数据失败:'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码中，<code v-pre>await</code>暂停了函数执行，直到<code v-pre>fetch</code>请求完成并解析出JSON数据，代码结构清晰，错误处理也更加直观。</p>
<h2 id="二、async与await的核心原理" tabindex="-1"><a class="header-anchor" href="#二、async与await的核心原理"><span>二、async与await的核心原理</span></a></h2>
<p><code v-pre>async</code>和<code v-pre>await</code>的实现本质上是<code v-pre>Generator</code>函数和<code v-pre>Promise</code>的语法糖，其核心原理涉及以下几个方面：</p>
<h3 id="_1-generator函数的底层支撑" tabindex="-1"><a class="header-anchor" href="#_1-generator函数的底层支撑"><span>1. Generator函数的底层支撑</span></a></h3>
<p><code v-pre>Generator</code>函数通过<code v-pre>function*</code>定义，能通过<code v-pre>yield</code>暂停和恢复执行，返回迭代器（Iterator）。<code v-pre>async</code>函数本质上是对<code v-pre>Generator</code>函数的封装，自动为其添加执行器，无需手动调用<code v-pre>next()</code> ，即可按顺序执行<code v-pre>await</code>后的操作。</p>
<h3 id="_2-await的暂停与恢复机制" tabindex="-1"><a class="header-anchor" href="#_2-await的暂停与恢复机制"><span>2. await的暂停与恢复机制</span></a></h3>
<p>当遇到<code v-pre>await promise</code>时：</p>
<ul>
<li><strong>暂停执行</strong>：将<code v-pre>promise</code>的<code v-pre>then</code>回调注册到微任务队列，当前<code v-pre>async</code>函数暂停，线程释放给其他任务。</li>
<li><strong>异步回调</strong>：当<code v-pre>promise</code>状态变更（<code v-pre>fulfilled</code>或<code v-pre>rejected</code>）时，回调函数将<code v-pre>async</code>函数的剩余逻辑包装成微任务，推入事件循环。</li>
<li><strong>恢复执行</strong>：事件循环处理微任务时，继续执行<code v-pre>await</code>之后的代码，将<code v-pre>promise</code>的结果作为<code v-pre>await</code>表达式的值。</li>
</ul>
<h3 id="_3-promise的状态流转" tabindex="-1"><a class="header-anchor" href="#_3-promise的状态流转"><span>3. Promise的状态流转</span></a></h3>
<p><code v-pre>async</code>函数默认返回<code v-pre>Promise</code>，<code v-pre>return</code>的值会作为<code v-pre>Promise.resolve()</code>的参数；若抛出错误，则等价于<code v-pre>Promise.reject()</code>。<code v-pre>await</code>等价于<code v-pre>Promise.then()</code>，但语法上更接近同步写法，且错误可通过<code v-pre>try...catch</code>统一捕获，类似于同步代码的异常处理方式。</p>
<h3 id="_4-事件循环与微任务" tabindex="-1"><a class="header-anchor" href="#_4-事件循环与微任务"><span>4. 事件循环与微任务</span></a></h3>
<p><code v-pre>await</code>的异步逻辑依赖JavaScript的事件循环机制。当<code v-pre>await</code>执行时，后续代码会被封装为<strong>微任务</strong>（Microtask），在当前同步任务结束后立即执行，其优先级高于宏任务（如定时器、IO操作）。这确保了<code v-pre>await</code>后的代码按顺序执行，同时不阻塞主线程。</p>
<h2 id="三、多个await的执行机制" tabindex="-1"><a class="header-anchor" href="#三、多个await的执行机制"><span>三、多个await的执行机制</span></a></h2>
<p>当<code v-pre>async</code>函数中存在多个<code v-pre>await</code>时，它们会按照代码顺序<strong>逐个异步执行</strong>：</p>
<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code" v-pre=""><code class="language-js"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> multiAwait</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">() {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">'开始'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> res1</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> await</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">'res1:'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">res1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> res2</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> await</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379">'res2:'</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">res2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75"> res1</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75"> res2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">multiAwait</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">();</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行流程如下：</p>
<ol>
<li>执行<code v-pre>async</code>函数内的同步代码。</li>
<li>遇到第一个<code v-pre>await</code>，将后续代码封装为微任务，放入微任务队列，函数暂时返回<code v-pre>Promise</code>。</li>
<li>主线程执行完同步任务后，处理微任务队列，依次执行每个<code v-pre>await</code>的后续逻辑 。</li>
</ol>
<p>若需要并行执行多个异步任务，可使用<code v-pre>Promise.all()</code>：</p>
<div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34"><pre class="shiki shiki-themes one-light one-dark-pro vp-code" v-pre=""><code class="language-js"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">async</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> function</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF"> parallelAwait</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> p1</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B"> p2</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD">  const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B">res1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B">res2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD"> await</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">all</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">([</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">p1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">p2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">]);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">res1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75">res2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">); </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF">}</span></span></code></pre>
<div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、async-await的优势与应用场景" tabindex="-1"><a class="header-anchor" href="#四、async-await的优势与应用场景"><span>四、async/await的优势与应用场景</span></a></h2>
<p><code v-pre>async</code>和<code v-pre>await</code>的主要优势在于：</p>
<ul>
<li><strong>代码简洁</strong>：避免了Promise链式调用的多层嵌套，即“回调地狱”问题。</li>
<li><strong>错误处理统一</strong>：通过<code v-pre>try...catch</code>捕获异步错误，使代码更易维护。</li>
<li><strong>同步化书写</strong>：用同步代码的语法书写异步逻辑，提升代码可读性。</li>
</ul>
<p>其典型应用场景包括网络请求、文件读取、数据库操作等需要异步处理的场景。</p>
<p>通过掌握<code v-pre>async</code>和<code v-pre>await</code>的原理及应用，开发者可以更高效、优雅地处理异步任务，提升JavaScript应用的性能和开发效率。</p>
</div></template>


