import comp from "F:/MyBlogSite/vuepress-theme-hope/my-docs/src/.vuepress/.temp/pages/series/knowledge/Java/Java基础面试题/序列化.html.vue"
const data = JSON.parse("{\"path\":\"/series/knowledge/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%8F%E5%88%97%E5%8C%96.html\",\"title\":\"序列化\",\"lang\":\"zh-CN\",\"frontmatter\":{\"order\":12},\"git\":{},\"readingTime\":{\"minutes\":5.12,\"words\":1536},\"filePathRelative\":\"series/knowledge/Java/Java基础面试题/序列化.md\",\"excerpt\":\"\\n<h2>怎么把一个对象从一个JVM转移到另一个JVM?</h2>\\n<ol>\\n<li>\\n<p><strong>序列化与反序列化</strong><br>\\n将对象序列化为字节流，通过网络传输或文件存储发送到另一个JVM，再在目标JVM中反序列化字节流恢复对象。Java原生通过<code>ObjectOutputStream</code>（序列化）和<code>ObjectInputStream</code>（反序列化）实现，需确保对象类实现<code>Serializable</code>接口。</p>\\n</li>\\n<li>\\n<p><strong>消息传递机制</strong><br>\\n利用消息队列（如RabbitMQ、Kafka）或网络套接字（Socket），自定义协议将对象序列化后发送。例如，通过Socket建立两个JVM间的连接，将序列化后的字节流写入输出流，目标JVM从输入流读取并反序列化。</p>\\n</li>\\n<li>\\n<p><strong>远程方法调用（RPC）</strong><br>\\n使用RPC框架（如gRPC、Dubbo），框架内部封装对象序列化、网络传输和反序列化逻辑，开发者可直接调用远程JVM上的对象方法，无需手动处理传输细节。例如，gRPC基于Protocol Buffers序列化对象，实现跨语言、跨JVM的方法调用。</p>\\n</li>\\n<li>\\n<p><strong>共享数据库或缓存</strong><br>\\n将对象存储在共享数据库（如MySQL）或分布式缓存（如Redis）中，两个JVM通过读写共享存储实现对象\\\"转移\\\"。适用于无需实时传输、仅需共享数据的场景，需将对象转换为数据库字段或缓存支持的格式（如JSON）。</p>\\n</li>\\n</ol>\"}")
export { comp, data }
