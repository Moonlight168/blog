# 填空题
## 第三章 贪心算法
### 1.（**贪心选择**）是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

### 2. 背包问题的贪心算法

```c
void Knapsack(int n,float M,float v[],float w[],float x[])
{
       Sort(n,v,w); // 按单位重量价值降序排序物品
       int i;
       for (i=1;i<=n;i++) x[i]=0; // 初始化解向量
       float c=M; // 剩余背包容量
       float total_value=0; // 总价值
       for (i=1;i<=n;i++) {
             if (w[i]>c) break; // 如果当前物品重量大于背包容量，跳出循环
             x[i]=1; // 放入整个物品
             total_value+=v[i]; // 更新背包价值           
             (  c -= w[i]  ); // 更新背包容量（第一空答案）
        }
        if (i<=n) { 
             (  x[i] = c/w[i]  ); // 为了将背包填满，取当前物品的一部分（第二空答案）
             total_value+=x[i]*v[i]; // 更新背包的价值
        }
}
```

**解析：**
1. **贪心算法解决背包问题的基本思想**：
   - 选择单位重量价值最高的物品优先放入背包
   - 当物品无法完整放入时，取其一部分填满背包
   - 该算法适用于分数背包问题，能得到最优解

2. **代码执行流程**：
   - 首先对物品按单位重量价值降序排序（Sort函数实现）
   - 初始化解向量x，所有元素为0
   - 遍历排序后的物品，依次放入背包
   - 当剩余容量不足时，计算能放入的比例
   - 最后计算总价值

3. **填空解析**：
   - **第一空**：放入物品后，需要将剩余背包容量减去当前物品的重量，即 `c -= w[i]`
   - **第二空**：当物品无法完整放入时，取当前物品的一部分，比例为剩余容量与物品重量的比值，即 `x[i] = c/w[i]`

**核心知识点**：贪心算法解决分数背包问题的关键是按单位重量价值排序，然后依次放入物品，最后处理剩余容量的部分物品。

## 第四章 回溯法
### 1. N皇后问题的放置函数

在N皇后问题中，设x[i]为第i个的皇后位置，现有一个函数判断第k个皇后与先前皇后不同列、不同斜线，请完成下列填空。

```c
bool Place(int k)   //考察皇后k放置在x[k]列是否发生冲突
    {
         for (i=1; i<k; i++)  
             if ( （x[k] == x[i]） || （abs(k - i) == abs(x[k] - x[i])））
                 return false;
             return true;
     }
```

**解析：**
1. **N皇后问题的约束条件**：
   - 任意两个皇后不能在同一行（由解向量的定义保证，x[i]表示第i行皇后的列位置）
   - 任意两个皇后不能在同一列
   - 任意两个皇后不能在同一斜线上

2. **冲突检测逻辑**：
   - **解向量的表示**：在N皇后问题中，解向量x[i]表示第i行皇后所在的列号。因此，第i个皇后的位置可以表示为(i, x[i])，其中：
     - i是行号（从1到n）
     - x[i]是列号（从1到n）
   - 遍历前k-1个皇后，检查与第k个皇后是否冲突
   - **同一列冲突**：如果x[k] == x[i]，表示第k个皇后（位置(k, x[k])）与第i个皇后（位置(i, x[i])）在同一列
   - **同一斜线冲突**：如果abs(k - i) == abs(x[k] - x[i])，表示第k个皇后与第i个皇后在同一斜线上
     - `k - i`是行差（第k行与第i行的行数差），`abs(k - i)`是行差的绝对值
     - `x[k] - x[i]`是列差（第k行皇后与第i行皇后的列数差），`abs(x[k] - x[i])`是列差的绝对值
     - 当行差绝对值等于列差绝对值时，两个皇后在同一斜线上（斜率为1或-1）
   - **示例**：若皇后A在(1, 2)，皇后B在(3, 4)，则行差为2，列差为2，绝对值相等，说明在同一斜线上；若皇后C在(2, 4)，皇后D在(4, 2)，则行差为2，列差为-2，绝对值相等，也在同一斜线上

3. **填空解析**：
   - **第一空**：需要检查是否在同一列，即`x[k] == x[i]`
   - **第二空**：需要检查是否在同一斜线，即`abs(k - i) == abs(x[k] - x[i])`

**核心知识点**：N皇后问题的冲突检测需要检查同一列和同一斜线，同一斜线的条件是行差绝对值等于列差绝对值。

## 第六章 动态规划
1. 若序列X={B,C,A,D,B,C,D}，Y={A,C,B,A,B,D,C,D}，请给出序列X和Y的最长公共子序列 (**BABCD**)(**CABCD**)(**CADCD**)。

**解析：**
1. **最长公共子序列(LCS)定义**：LCS是指两个序列中最长的公共子序列，子序列不需要连续但保持相对顺序。

2. **动态规划解法**：
   - **DP数组定义**：
     - `dp[i][j]` 表示序列X的前i个元素(X[1..i])和序列Y的前j个元素(Y[1..j])的最长公共子序列长度
     - 数组大小为(m+1)×(n+1)，其中m=len(X), n=len(Y)，多一行一列是为了处理边界条件
     - `dp[0][j] = 0` 和 `dp[i][0] = 0` 表示空序列与任何序列的LCS长度为0
   - **状态转移方程**：
     - 若X[i]=Y[j]，则`dp[i][j] = dp[i-1][j-1] + 1`，表示当前字符匹配，LCS长度加1
     - 否则`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`，表示取X前i-1个与Y前j个，或X前i个与Y前j-1个的较大LCS长度

3. **答案验证**：
   - **BABCD**：B(1)、A(3)、B(5)、C(6)、D(7)
   - **CABCD**：C(2)、A(3)、B(5)、C(6)、D(7)
   - **CADCD**：C(2)、A(3)、D(4)、C(6)、D(7)
   均为长度为5的有效LCS，符合最长公共子序列定义。