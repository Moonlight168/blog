# 算法设计复习指南

## 考核方式

![考核方式](image/复习指南/1768031829674.png)

![期末考试](image/复习指南/1768031846659.png)

## 课程目标

![课程目标](image/复习指南/1768031779064.png)

## 主要章节与核心知识点

### 第一章 算法基础

1. **算法复杂度分析**

   - **时间复杂度与空间复杂度的定义**
   - **渐近符号**：O（上界）、Ω（下界）、θ（紧界）
   - 常数因子不影响渐近复杂度
   - **常见复杂度比较**：O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(2ⁿ) < O(n!)

2. **算法设计基本概念**

   - **算法的五大特性**：输入、输出、有穷性、确定性、可行性
   - **算法设计的目标**：正确性、可读性、健壮性、效率（时间+空间）

3. **常见算法复杂度**

   | 复杂度 | 典型算法示例 |
   |--------|--------------|
   | O(1) | 数组访问 |
   | O(logn) | 二分查找 |
   | O(n) | 线性搜索、直接插入排序 |
   | O(nlogn) | 快速排序、归并排序 |
   | O(n²) | 冒泡排序、选择排序 |
   | O(n³) | 矩阵乘法（朴素算法） |
   | O(2ⁿ) | 递归斐波那契 |
   | O(n!) | 全排列 |

### 第二章 分治法

1. **分治法的基本要素**

   - **分解**：将原问题分解为若干规模较小、结构相似的子问题
   - **解决**：递归解决子问题，或直接解决小规模子问题
   - **合并**：将子问题的解合并为原问题的解

2. **分治法适用条件**

   - 子问题结构与原问题相似
   - 子问题相互独立（无重叠子问题）
   - 子问题的解可以合并

3. **典型应用**

   - 二分查找
   - 快速排序
   - 归并排序
   - 大整数乘法
   - 矩阵乘法（Strassen算法）
   - 寻找第k小元素

4. **分治法代码示例 寻找第k小元素**

   ```python
   def partition(arr, low, high):
       """分区函数：将数组以pivot为基准分区
       数组是无序的，通过交换元素将小于等于pivot的元素放到左侧，大于的放到右侧
       返回pivot的最终位置
       """
       pivot = arr[high]  # 选择最右元素作为基准
       i = low - 1  # 小于pivot区域的右边界
       
       for j in range(low, high):
           if arr[j] <= pivot:  # 当前元素小于等于pivot
               i += 1  # 扩展小于pivot区域
               arr[i], arr[j] = arr[j], arr[i]  # 交换元素
       
       # 将pivot放到正确位置
       arr[i + 1], arr[high] = arr[high], arr[i + 1]
       return i + 1  # 返回pivot的最终位置
   
   def quickselect(arr, low, high, k):
       """快速选择算法：寻找数组中第k小的元素
       数组是无序的，通过分区将问题规模减半
       """
       if low <= high:
           pi = partition(arr, low, high)  # 分区，得到pivot位置
           
           if pi == k - 1:  # pivot正好是第k小元素
               return arr[pi]
           elif pi > k - 1:  # 第k小元素在左半部分
               return quickselect(arr, low, pi - 1, k)
           else:  # 第k小元素在右半部分
               return quickselect(arr, pi + 1, high, k)
       return -1
   
   def find_kth_smallest(arr, k):
       """寻找第k小元素的入口函数
       创建副本避免修改原数组
       """
       if k < 1 or k > len(arr):
           return None
       return quickselect(arr.copy(), 0, len(arr) - 1, k)
   ```

1. **贪心算法的基本思想**

   - 每一步选择局部最优解，希望通过局部最优达到全局最优
   - **贪心选择性质**：全局最优解可以通过一系列局部最优选择得到
   - **最优子结构性质**：问题的最优解包含其子问题的最优解

2. **贪心算法的适用条件**

   - 具有贪心选择性质
   - 具有最优子结构性质

3. **典型应用**

   - 活动安排问题
   - 哈夫曼编码
   - 单源最短路径（Dijkstra算法）
   - 最小生成树（Prim算法、Kruskal算法）
   - 背包问题（分数背包）

4. **贪心算法与动态规划的区别**

   | 算法 | 搜索策略 | 子问题处理 | 适用场景 |
   |------|---------|-----------|---------|
   | 贪心算法 | 自顶向下 | 每次选择局部最优 | 具有贪心选择性质 |
   | 动态规划 | 自底向上 | 解决重叠子问题 | 子问题重叠 |

5. **贪心算法代码示例 - 活动安排问题**

   ```python
   def activity_selection(start, finish):
       """贪心算法解决活动安排问题
       选择最多的互不冲突的活动，优先选择结束时间最早的活动
       """
       n = len(start)
       activities = list(zip(start, finish))  # 配对开始和结束时间
       activities.sort(key=lambda x: x[1])  # 按结束时间升序排序
       
       selected = [activities[0]]  # 选中第一个活动
       last_finish = activities[0][1]  # 记录上一个活动的结束时间
       
       for i in range(1, n):
           # 如果当前活动的开始时间 >= 上一个活动的结束时间，不冲突
           if activities[i][0] >= last_finish:
               selected.append(activities[i])  # 选中当前活动
               last_finish = activities[i][1]  # 更新结束时间
       
       return selected
   ```

### 第四章 回溯法

1. **回溯法的基本思想**

   - 系统地搜索问题的所有解
   - 采用深度优先搜索策略，通过剪枝避免无效搜索
   - **解空间树**：子集树（0-1选择）、排列树（排列问题）

2. **回溯法的关键技术**

   - **剪枝函数**：约束函数（可行性剪枝）、限界函数（最优性剪枝）
   - 解空间的组织与遍历

3. **典型应用**

   - 0-1背包问题
   - 旅行商问题
   - n皇后问题
   - 图的着色问题
   - 子集和问题

4. **时间复杂度分析**

   - 子集树问题：O(n×2ⁿ)
   - 排列树问题：O(n×n!)
   - **上界函数**：用于剪枝优化，计算当前状态下可能的最大价值上限

5. **回溯法代码示例 - N皇后问题**

   ```python
   def solve_n_queens(n):
       """回溯法解决N皇后问题
       找出所有n×n棋盘上放置n个皇后的方案，使得它们互不攻击
       board[i] = j 表示第i行第j列放置了皇后
       """
       result = []
       board = [-1] * n  # 初始化为-1表示没有放置皇后
       
       def is_safe(row, col):
           """检查在(row, col)位置放置皇后是否安全
           检查列冲突和对角线冲突
           """
           for i in range(row):
               # 列冲突：board[i] == col
               # 对角线冲突：abs(board[i] - col) == row - i
               if board[i] == col or abs(board[i] - col) == row - i:
                   return False
           return True
       
       def backtrack(row):
           """回溯函数：递归尝试在第row行放置皇后
           """
           if row == n:  # 所有行都放置了皇后，找到一个解
               result.append(board[:])
               return
           
           for col in range(n):
               if is_safe(row, col):  # 检查当前位置是否安全
                   board[row] = col  # 放置皇后
                   backtrack(row + 1)  # 递归处理下一行
                   board[row] = -1  # 回溯：撤销当前位置的皇后
       
       backtrack(0)  # 从第0行开始回溯
       return result
   ```

### 第五章 分支限定法

1. **分支限定法的基本思想**

   - **分支**：将问题分解为子问题
   - **限定**：计算子问题的上下界，剪枝无效分支
   - 采用广度优先搜索或优先队列搜索策略

2. **分支限定法与回溯法的区别**

   | 算法 | 搜索策略 | 目标 | 适用场景 |
   |------|---------|------|---------|
   | 回溯法 | 深度优先搜索 | 寻找所有解 | 需要所有可行解 |
   | 分支限定法 | 广度优先或优先队列 | 寻找最优解 | 需要最优解 |

3. **典型应用**

   - 旅行商问题
   - 0-1背包问题
   - 整数规划问题

4. **分支策略与限界函数**

   - **分支策略**：如何将问题分解为子问题
   - **限界函数**：计算子问题的上下界，用于剪枝

5. **分支限定法代码示例 - 0-1背包问题**

   ```python
   import heapq
   
   def knapsack_branch_bound(weights, values, capacity):
       """分支限定法解决0-1背包问题
       
       算法整体思路：
       1. 将物品按价值重量比降序排序，优先考虑价值密度高的物品
       2. 使用优先队列（最大堆）管理搜索节点，每次优先搜索上界最高的节点
       3. 计算每个节点的上界，剪枝那些不可能超过当前最优解的分支
       4. 记录搜索过程中找到的最大价值和对应的物品组合
       
       0-1背包规则：物品要么全部拿，要么不拿，不能分开拿
       """
       n = len(weights)
       
       def bound(node, level, current_value, current_weight):
           """计算当前节点的上界（理论最大价值）
           
           参数：
           - node: 当前节点（未使用）
           - level: 当前处理到的物品索引（-1表示初始状态）
           - current_value: 当前已选物品的总价值
           - current_weight: 当前已选物品的总重量
           
           返回：
           当前节点可能达到的最大价值上限
           
           上界计算原理（非常重要）：
           ------------------------
           1. 虽然0-1背包不允许部分拿取物品，但为了计算上界，
              我们使用"分数背包"的方式来得到理论最大值
           2. 分数背包允许部分拿取物品，所以它的最大价值一定大于等于
              实际0-1背包的最大价值（因为它更灵活）
           3. 这个理论最大值就是当前节点的上界
           4. 如果一个节点的上界 <= 当前找到的最优解，说明这个分支不可能找到更好的解，
              可以直接剪枝，不再搜索
           
           上界计算步骤：
           1. 如果当前重量已经超过容量，返回0（无法再增加价值）
           2. 先尽可能完整地拿取剩余物品
           3. 如果还有剩余空间，计算部分拿取下一个物品的价值
           4. 总和就是理论上的最大价值（上界）
           """
           # 1. 如果当前重量已经超过或等于容量，无法再装任何物品
           if current_weight >= capacity:
               return 0  # 价值无法再增加，返回0
           
           bound_value = current_value  # 初始上界为当前价值
           next_item = level + 1  # 下一个要考虑的物品索引
           total_weight = current_weight  # 当前总重量
           
           # 2. 尽可能完整地拿取剩余物品
           # 从下一个物品开始，依次检查是否能完整装入
           while next_item < n and total_weight + weights[next_item] <= capacity:
               total_weight += weights[next_item]  # 加上当前物品重量
               bound_value += values[next_item]  # 加上当前物品价值
               next_item += 1  # 处理下一个物品
           
           # 3. 如果还有剩余空间，计算部分拿取下一个物品的价值
           # 注意：这只是理论计算，实际0-1背包中不能这样做
           if next_item < n:  # 还有未处理的物品
               # 计算剩余空间
               remaining_space = capacity - total_weight
               # 计算下一个物品的单位价值（价值/重量）
               unit_value = values[next_item] / weights[next_item]
               # 计算部分拿取的价值（剩余空间 * 单位价值）
               bound_value += remaining_space * unit_value
           
           return bound_value  # 返回计算得到的上界
       
       # 4. 预处理：按价值重量比降序排序物品
       # 这样可以优先考虑价值密度高的物品，提高剪枝效率
       items = []
       for i in range(n):
           value_density = values[i] / weights[i]  # 价值重量比
           items.append((value_density, weights[i], values[i], i))  # 存储信息
       items.sort(reverse=True)  # 按价值密度降序排序
       
       # 5. 初始化优先队列
       # 优先队列中的元素格式：(-上界, 当前物品索引, 当前价值, 当前重量, 选中物品列表)
       # 使用负上界是因为Python的heapq是最小堆，我们需要最大堆
       # 初始节点：上界为bound(-1, 0, 0)，处理到第-1个物品（还没开始），
       # 价值和重量都为0，选中物品列表为空
       priority_queue = []
       initial_bound = bound(None, -1, 0, 0)  # 计算初始上界
       heapq.heappush(priority_queue, (-initial_bound, -1, 0, 0, []))
       
       # 6. 初始化最优解
       max_value = 0  # 当前找到的最大价值
       best_items = []  # 当前找到的最优物品组合
       
       # 7. 开始搜索
       while priority_queue:
           # 取出上界最高的节点（因为用了负上界，所以取最小值）
           neg_bound, current_level, current_value, current_weight, selected_items = heapq.heappop(priority_queue)
           current_bound = -neg_bound  # 转换回正数上界
           
           # 8. 如果当前节点已经处理完所有物品
           if current_level == n - 1:
               # 如果当前价值大于已知最大价值，更新最优解
               if current_value > max_value:
                   max_value = current_value
                   best_items = selected_items.copy()
               continue  # 处理下一个节点
           
           # 9. 处理下一个物品
           next_level = current_level + 1
           # 获取下一个物品的信息
           next_density, next_weight, next_value, next_index = items[next_level]
           
           # 10. 分支1：选择拿取当前物品
           if current_weight + next_weight <= capacity:  # 检查是否超重
               # 计算拿取后的新价值和新重量
               new_value = current_value + next_value
               new_weight = current_weight + next_weight
               # 更新选中物品列表
               new_selected = selected_items + [next_index]
               
               # 如果拿取后的值已经超过当前最优解，更新最优解
               if new_value > max_value:
                   max_value = new_value
                   best_items = new_selected.copy()
               
               # 计算拿取当前物品后的上界
               new_bound = bound(None, next_level, new_value, new_weight)
               # 如果上界大于当前最优解，说明这个分支还有可能找到更好的解，入队
               if new_bound > max_value:
                   heapq.heappush(priority_queue, (-new_bound, next_level, new_value, new_weight, new_selected))
           
           # 11. 分支2：选择不拿取当前物品
           # 计算不拿取当前物品后的上界
           skip_bound = bound(None, next_level, current_value, current_weight)
           # 如果上界大于当前最优解，说明这个分支还有可能找到更好的解，入队
           if skip_bound > max_value:
               heapq.heappush(priority_queue, (-skip_bound, next_level, current_value, current_weight, selected_items))
       
       # 12. 返回最优解
       return max_value, best_items
   ```

### 第六章 动态规划

1. **动态规划的基本思想**

   - 将原问题分解为相互重叠的子问题，通过求解子问题来求解原问题
   - 自底向上计算，保存子问题的解，避免重复计算
   - 核心是找到**状态转移方程**

2. **动态规划的适用条件**

   - **最优子结构性质**：原问题的最优解包含子问题的最优解
   - **重叠子问题性质**：子问题重复出现，需要保存子问题的解

3. **动态规划的基本要素**

   - **状态定义**：描述问题的不同阶段和状态
   - **状态转移方程**：描述状态之间的转移关系
   - **初始条件**：问题的边界条件
   - **计算顺序**：自底向上，从小到大计算

4. **典型应用**

   - 0-1背包问题
   - 最长公共子序列问题
   - 最短路径问题
   - 矩阵链乘法问题
   - 最优二叉搜索树问题
   - 编辑距离问题

5. **与其他算法的比较**

   | 算法 | 子问题特点 | 搜索策略 | 适用场景 |
   |------|-----------|---------|---------|
   | 分治法 | 子问题不重叠 | 递归 | 子问题独立 |
   | 贪心算法 | 无重叠子问题 | 自顶向下 | 具有贪心选择性质 |
   | 动态规划 | 子问题重叠 | 自底向上 | 具有最优子结构和重叠子问题 |

6. **动态规划代码示例 - 0-1背包问题**

   ```python
   def knapsack_dp(weights, values, capacity):
       """动态规划解决0-1背包问题（标准版）
       dp[i][w]表示前i个物品在容量w下的最大价值
       """
       n = len(weights)
       # 创建二维DP表
       dp = [[0] * (capacity + 1) for _ in range(n + 1)]
       
       # 填充DP表
       for i in range(1, n + 1):
           for w in range(1, capacity + 1):
               # 如果当前物品可以放入背包
               if weights[i - 1] <= w:
                   # 状态转移方程：取两种选择的最大值
                   # 1. 不选当前物品：价值为dp[i-1][w]
                   # 2. 选当前物品：价值为dp[i-1][w-weights[i-1]] + values[i-1]
                   dp[i][w] = max(
                       dp[i - 1][w],
                       dp[i - 1][w - weights[i - 1]] + values[i - 1]
                   )
               else:
                   # 物品超重，只能不选
                   dp[i][w] = dp[i - 1][w]
       
       max_value = dp[n][capacity]
       
       # 回溯寻找选中的物品
       selected = []
       w = capacity
       for i in range(n, 0, -1):
           if dp[i][w] != dp[i - 1][w]:
               selected.append(i - 1)
               w -= weights[i - 1]
       
       return max_value, selected[::-1]
   
   def knapsack_dp_optimized(weights, values, capacity):
       """动态规划解决0-1背包问题（空间优化版）
       使用一维数组优化空间复杂度从O(n*capacity)到O(capacity)
       """
       n = len(weights)
       # 创建一维DP数组
       dp = [0] * (capacity + 1)
       
       # 填充DP数组，从后往前遍历容量
       for i in range(n):
           for w in range(capacity, weights[i] - 1, -1):
               # 状态转移方程
               dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
       
       return dp[capacity]
   ```

### 第七章 智能算法

1. **智能算法的基本概念**

   - 智能算法是一类启发式算法，模拟自然现象或生物行为
   - 适用于求解复杂的组合优化问题
   - 主要特点：全局搜索能力强，不依赖问题的具体结构

2. **粒子群优化算法（PSO）**

   - **基本思想**：模拟鸟群或鱼群的群体智能行为，通过粒子间的协作和竞争寻找最优解
   - **核心概念**：
     - **粒子**：问题的潜在解
     - **位置**：粒子在解空间中的位置
     - **速度**：粒子的移动速度
     - **适应度函数**：评价粒子的优劣
     - **个体最优解**：粒子自身找到的最优解
     - **全局最优解**：整个粒子群找到的最优解
   - **算法流程**：初始化粒子群 → 计算适应度 → 更新个体最优和全局最优 → 更新粒子位置和速度 → 迭代直到满足终止条件
   - **应用领域**：函数优化、神经网络训练、组合优化问题

3. **模拟退火算法（SA）**

   - **基本思想**：模拟固体退火过程，通过控制温度的冷却来寻找最优解
   - **核心概念**：
     - **温度**：控制搜索的随机性，温度越高，接受劣解的概率越大
     - **冷却速率**：控制温度下降的速度
     - **邻域函数**：生成当前解的邻居解
     - **Metropolis准则**：决定是否接受劣解
   - **算法流程**：初始化温度和初始解 → 生成邻居解 → 计算能量差 → 按Metropolis准则接受或拒绝 → 降低温度 → 迭代直到满足终止条件
   - **应用领域**：旅行商问题、图着色问题、电路设计

4. **禁忌搜索算法（TS）**

   - **基本思想**：通过记忆机制避免重复搜索，允许接受劣解以跳出局部最优
   - **核心概念**：
     - **禁忌表**：记录最近访问过的解或操作，避免重复搜索
     - **禁忌长度**：禁忌表的大小，控制记忆的时间
     - **候选解**：当前解的邻居解
     - **特赦规则**：当找到更优解时，可忽略禁忌表的限制
   - **算法流程**：初始化当前解和禁忌表 → 生成候选解 → 选择最优候选解（考虑禁忌表） → 更新禁忌表 → 迭代直到满足终止条件
   - **应用领域**：旅行商问题、车间调度问题、资源分配问题

5. **智能算法的优缺点**

   | 算法 | 优点 | 缺点 |
   |------|------|------|
   | PSO | 实现简单，收敛速度快 | 容易陷入局部最优 |
   | SA | 全局搜索能力强 | 参数设置敏感，收敛速度慢 |
   | TS | 记忆机制避免重复搜索 | 禁忌表长度难以确定 |

   - **优点**：全局搜索能力强，适用于复杂问题，不需要问题的梯度信息
   - **缺点**：收敛速度可能较慢，参数设置敏感，理论基础相对薄弱