# 单选题
## 第一章 操作系统引论
### 1. 操作系统是一组 ( **C** )
A、设备管理程序
B、中断处理程序
C、文件管理程序
D、资源管理程序
### 2. 下面关于操作系统启动过程的描述，顺序正确的是（**A**）？
（1）检查硬件  （2）寻址执行BIOS映射区  （3）加载引导扇区  （4）初始化系统  （5）启动内核
A、(2)(1)(3)(5)(4)      
B、(2)(1)(3)(4)(5)      
C、(3)(1)(2)(5)(4)   
D、(1)(2)(3)(4)(5)
### 3. 下列选项中，不可能在用户态发生的是（ **D** ）
A、系统调用
B、缺页
C、进程切换
D、外部中断

**解析：**
**用户态（User Mode）**：CPU执行用户程序时的状态，权限较低，只能访问用户地址空间和有限的指令集，无法直接访问系统资源。

**选项分析**：
- **A、系统调用**：可能在用户态发生。用户程序可以主动发起系统调用（如`open()`、`read()`），此时会从用户态切换到内核态执行系统调用服务程序，完成后返回用户态。
- **B、缺页**：可能在用户态发生。当用户程序访问的虚拟内存页不在物理内存中时，会触发缺页中断，此时从用户态切换到内核态处理缺页（如加载页面到内存），处理完成后返回用户态。
- **C、进程切换**：可能在用户态发生。用户程序可以通过系统调用（如`sleep()`、`exit()`）间接触发进程切换，这些系统调用会导致内核进行进程调度和切换。
- **D、外部中断**：不可能在用户态发生。外部中断（如I/O设备中断、时钟中断）是由硬件直接触发的，CPU会立即切换到内核态处理中断，不会在用户态执行过程中发生。

### 4. 当CPU执行操作系统代码时，称处理机处于（**B**）。
A、就绪态；  B、管态；  C、自由态；  D、目态；

**解析：**

**核心概念：**
- **管态（Supervisor Mode/Kernel Mode）**：又称内核态，是CPU的特权模式，此时CPU可以执行所有指令（包括特权指令），访问所有内存空间和系统资源，主要用于执行操作系统内核代码。

**选项分析：**
- **A、就绪态**：错误。就绪态是进程的一种状态，表示进程已准备好执行，等待CPU分配时间片，与CPU执行模式无关。
- **B、管态**：正确。CPU执行操作系统内核代码时处于管态（内核态），具有最高权限。
- **C、自由态**：错误。操作系统中没有"自由态"这种CPU执行模式，属于干扰项。
- **D、目态**：错误。目态就是用户态（User Mode），是CPU执行用户程序时的状态，权限较低，无法直接访问系统资源。

### 5. 一次系统调用的完成需要进行（**A**）次模式转换。
A、2  
B、1  
C、0  
D、3

**解析：**

**核心概念：**
- **模式转换**：CPU在用户态和内核态之间的切换，用户态权限低，内核态权限高。
- **系统调用**：用户程序请求操作系统内核提供服务的接口。

**系统调用的完整流程：**
1. **用户态 → 内核态**：用户程序执行系统调用指令（如`int 0x80`），触发软中断，CPU从用户态切换到内核态。
2. **内核态执行系统调用**：操作系统内核处理用户的请求，完成相应的服务。
3. **内核态 → 用户态**：系统调用处理完成后，CPU从内核态切换回用户态，继续执行用户程序。

**模式转换次数分析：**
- 第一次转换：用户程序发起系统调用时，从用户态到内核态
- 第二次转换：系统调用完成后，从内核态回用户态
- 总共有2次模式转换

## 第二章 进程的描述与控制
### 1. 若进程用信箱来传递信息，那么发送信息者的进程名应（**C**）
A、作为receive原语的参数  
B、存放在信箱说明中  
C、存放在信件中  
D、作为send原语的参数

**解析：**

**核心概念：**
- **信箱通信**：是一种间接通信方式，进程之间通过信箱（mailbox）交换信息。信箱是一种数据结构，包含信箱头（说明信箱的属性，如信箱名、大小、状态等）和信箱体（存放信件的空间）。
- **send原语**：发送进程调用send原语将信件发送到指定信箱，参数通常包括**信箱名**和**信件内容**。
- **receive原语**：接收进程调用receive原语从指定信箱接收信件，参数通常包括**信箱名**和**存放信件的缓冲区**。

**信件结构分析：**
- 信件通常包含三个部分：**发送者进程名**、**接收者进程名**和**信件内容**。
- 发送者进程名必须存放在信件中，这样接收进程才能知道是谁发送的信息，便于后续的通信和处理。

**选项分析：**
- **A、作为receive原语的参数**：错误。receive原语的参数是信箱名和存放信件的缓冲区，不需要发送者进程名作为参数。
- **B、存放在信箱说明中**：错误。信箱说明（信箱头）是信箱的数据结构属性，用于描述信箱本身，不存放具体信件的发送者信息。
- **C、存放在信件中**：正确。发送者进程名是信件的重要组成部分，必须存放在信件中，以便接收进程识别发送方。
- **D、作为send原语的参数**：错误。send原语的参数是信箱名和信件内容，发送者进程名应该包含在信件内容中，而不是作为send原语的独立参数。

### 2. 对进程的管理和控制用的原语是（**D**）。

A、指令  
B、信号量  
C、信箱 
D、原语

**解析：**

**核心概念：**
- **进程管理**：包括进程的创建、调度、同步、通信、终止等操作，这些操作必须是原子性的（要么全部完成，要么全部不完成）。
- **原语（Primitive）**：是由若干条机器指令组成的一段程序，用于完成某个特定功能，在执行过程中不允许被中断，具有原子性。

**选项分析：**
- **A、指令**：错误。指令是CPU能识别和执行的基本操作命令，单条指令无法完成复杂的进程管理功能。
- **B、信号量**：错误。信号量主要用于进程同步和互斥，是一种工具，而不是直接用于管理和控制进程的机制。
- **C、信箱**：错误。信箱是进程间通信的一种方式，用于进程之间传递信息，不是进程管理的主要机制。
- **D、原语**：正确。进程的管理和控制操作（如创建进程的create原语、终止进程的terminate原语、阻塞进程的block原语等）都是通过原语实现的，确保了操作的原子性和正确性。

### 3. 多线程模型中不包括（**A**）。
A、一对多模型  
B、多对多模型  
C、一对一模型  
D、多对一模型

**解析：**
多线程模型是指用户级线程与内核级线程之间的映射关系，主要包括以下三种标准模型：

- **多对一模型（Many-to-One）**：多个用户级线程映射到一个内核级线程。这种模型的优点是线程管理开销小，但缺点是如果一个线程阻塞，整个进程都会阻塞。
- **一对一模型（One-to-One）**：一个用户级线程映射到一个内核级线程。这种模型的优点是一个线程阻塞不会影响其他线程，但缺点是线程管理开销大。
- **多对多模型（Many-to-Many）**：多个用户级线程映射到多个内核级线程。这种模型结合了前两种模型的优点，既能有效利用多核处理器，又能控制线程管理开销。

**选项分析：**
- **A、一对多模型**：错误。标准的多线程模型中没有"一对多模型"这一分类，这不是操作系统中定义的多线程模型。
- **B、多对多模型**：正确。是三种标准多线程模型之一。
- **C、一对一模型**：正确。是三种标准多线程模型之一。
- **D、多对一模型**：正确。是三种标准多线程模型之一。

### 4. 某个分时系统采用一对一线程模型。内存中有10个进程并发运行，其中9个进程各有一个线程，另外一个进程A拥有11个线程。则A获得的CPU时间占总的时间的（**D**）。
A、1/20  
B、1/10  
C、1  
D、11/20

**解析：**
在**一对一线程模型**中，每个用户级线程都会映射到一个内核级线程。操作系统的调度单位是内核级线程，即CPU时间是按照内核级线程来分配的。

- 9个进程各有1个线程，共9个内核级线程
- 进程A有11个线程，共11个内核级线程
- 系统总共有9 + 11 = 20个内核级线程
- CPU时间平均分配给每个内核级线程，每个内核级线程获得1/20的CPU时间
- 进程A的11个内核级线程总共获得11 × (1/20) = 11/20的CPU时间

### 5. 某个分时系统采用多对一线程模型。内存中有10个进程并发运行，其中9个进程中只各有一个线程，另外一个进程A拥有11个线程。则A获得的CPU时间占总时间的（**B**）。
A、1/20  
B、1/10  
C、0  
D、1

**解析：**
在**多对一线程模型**中，多个用户级线程映射到一个内核级线程。操作系统的调度单位仍然是内核级线程，但此时进程内的所有线程共享一个内核级线程的CPU时间。

- 系统中有10个进程，每个进程无论有多少个用户级线程，都只有1个内核级线程
- 系统总共有10个内核级线程
- CPU时间平均分配给每个内核级线程，每个内核级线程获得1/10的CPU时间
- 进程A的11个用户级线程共享进程A的1个内核级线程，因此进程A总共获得1 × (1/10) = 1/10的CPU时间

## 第三章 处理机调度与死锁
### 1. 设有4个作业同时到达，每个作业的执行时间均为2个小时，它们在一台处理机上按单道方式执行，则平均周转时间为（ **A** ）
A、5小时  
B、8小时  
C、2.5小时  
D、1小时  

**解析：**
**核心概念：**
- **周转时间**：作业从提交到完成的总时间，等于等待时间加上执行时间。
- **单道方式执行**：处理机一次只能执行一个作业，作业按顺序执行，一个作业完成后才执行下一个。

**计算过程：**
4个作业同时到达，按单道方式顺序执行，每个作业执行时间均为2小时。

- 作业1：周转时间=0+2=2小时
- 作业2：周转时间=2+2=4小时
- 作业3：周转时间=4+2=6小时
- 作业4：周转时间=6+2=8小时

**平均周转时间**：(2+4+6+8)/4 = 20/4 = 5小时

### 2. 某系统采用短作业优先的调度策略，现有作业序列：作业1（提交时间：8:00,运行时间1.50），作业2（提交时间：8:30,运行时间0.80）作业3（提交时间：9:00,运行时间0.10），作业4（提交时间：9:30,运行时间0.30），单位：小时，以十进制计。其平均带权周转时间为：（ **B** ）
A、5.52  
B、3.00 
C、12.23 
D、4.65  

**解析：**
**核心概念：**
- **带权周转时间**：作业的周转时间除以其运行时间，即 `带权周转时间 = 周转时间 / 运行时间`
- **周转时间**：作业从提交到完成的总时间，即 `周转时间 = 完成时间 - 提交时间`
- **短作业优先（SJF）**：每次选择运行时间最短的作业执行

**时间线计算（以8:00为0时刻）：**

**执行顺序分析：**
1. 8:00（0时刻）：只有作业1已提交，立即执行
2. 8:30（0.5时刻）：作业2提交，但作业1仍在执行，作业2等待
3. 9:00（1.0时刻）：作业3提交，作业1仍在执行，作业2和3等待
4. 9:30（1.5时刻）：作业1完成，作业4提交。此时已提交的作业有2、3、4，按SJF算法选择运行时间最短的作业3（0.10小时）执行
5. 作业3完成后，选择作业4（0.30小时）执行
6. 最后执行作业2（0.80小时）

| 作业 | 提交时间 | 运行时间 | 开始时间 | 完成时间 | 周转时间 | 带权周转时间 |
|------|----------|----------|----------|----------|----------|--------------|
| 1    | 0.00     | 1.50     | 0.00     | 1.50     | 1.50     | 1.50/1.50=1.00 |
| 3    | 1.00     | 0.10     | 1.50     | 1.60     | 0.60     | 0.60/0.10=6.00 |
| 4    | 1.50     | 0.30     | 1.60     | 1.90     | 0.40     | 0.40/0.30≈1.333 |
| 2    | 0.50     | 0.80     | 1.90     | 2.70     | 2.20     | 2.20/0.80=2.75 |

**平均带权周转时间**：(1.00 + 6.00 + 1.333 + 2.75) / 4 ≈ 11.083 / 4 ≈ 2.771，最接近选项B的3.00

### 3. 下面哪种死锁处理策略引入的不合理因素最严重？（ **A** ）
A、死锁忽略 
B、死锁预防 
C、死锁检测+恢复 
D、死锁避免 

**解析：**
**核心概念：**
- **死锁**：多个进程因竞争资源而造成的一种互相等待的局面，若无外力作用，这些进程都将无法继续执行

**选项分析：**
- **A、死锁忽略**：又称鸵鸟算法，假装死锁不会发生，不采取任何措施。当死锁发生时，系统可能崩溃，数据丢失，引入的不合理因素最严重
- **B、死锁预防**：通过限制资源请求顺序或方式来避免死锁，可能导致资源利用率降低，但不会导致系统崩溃
- **C、死锁检测+恢复**：定期检测死锁，发现后通过回滚进程或释放资源恢复，开销较大但可控
- **D、死锁避免**：在资源请求时预判是否会导致死锁，只允许安全的请求，开销较大但合理

### 4. 下面哪个操作一定会引起CPU调度算法的执行？（ **B** ）
A、fork() 
B、exit() 
C、open() 
D、printf()

**解析：**
**核心概念：**
- **CPU调度**：操作系统从就绪队列中选择一个进程分配CPU时间
- **调度触发条件**：进程状态改变（如运行→阻塞、运行→就绪、进程终止）

**选项分析：**
- **A、fork()**：创建新进程，可能触发调度（如果新进程优先级更高），但不是一定会
- **B、exit()**：进程终止，CPU必须选择新的进程执行，一定会触发调度算法
- **C、open()**：文件打开操作，属于I/O，可能阻塞但不一定触发调度
- **D、printf()**：输出函数，可能导致I/O，但不一定触发调度

### 5. SJF算法的就绪队列是按照进程的（**D**）排列。
A、提交时间 
B、等待时间 
C、到达时间 
D、下一个CPU脉冲时间

**解析：**
**核心概念：**
- **SJF算法**：短作业优先（Shortest Job First）调度算法，每次选择运行时间最短的作业或进程执行
- **就绪队列**：操作系统中存放就绪状态进程的队列

**选项分析：**
- **A、提交时间**：错误。提交时间是作业或进程到达系统的时间，不是SJF算法的排列依据
- **B、等待时间**：错误。等待时间是进程在就绪队列中等待的时间，不是SJF算法的排列依据
- **C、到达时间**：错误。到达时间是进程进入就绪队列的时间，FCFS（先来先服务）算法按照到达时间排列
- **D、下一个CPU脉冲时间**：正确。SJF算法按照进程的运行时间（即下一个CPU脉冲时间）排列，运行时间最短的进程排在前面

### 6. 银行家算法是一种 ( **B** )算法.
A、死锁预防  
B、死锁避免 
C、死锁检测 
D、死锁解除

**解析：**
**核心概念：**
- **银行家算法**：一种用于避免死锁的算法，通过模拟资源分配来判断系统是否处于安全状态
- **死锁避免**：在资源分配前预判是否会导致死锁，只允许安全的请求

**选项分析：**
- **A、死锁预防**：错误。死锁预防通过限制资源请求顺序或方式来避免死锁，如破坏死锁的四个必要条件之一
- **B、死锁避免**：正确。银行家算法是典型的死锁避免算法，在资源分配前检查系统是否仍处于安全状态
- **C、死锁检测**：错误。死锁检测定期检查系统是否发生死锁，不预先避免
- **D、死锁解除**：错误。死锁解除是在死锁发生后采取措施恢复，如回滚进程或释放资源

### 7. 下面哪种调度算法能让刚等待完IO的进程优先执行？（ **A** ）
A、多级反馈队列调度 
B、时间片轮转调度 
C、短作业优先 
D、先来先服务

**解析：**
**核心概念：**
- **IO等待**：进程因等待IO操作完成而进入阻塞状态，IO完成后回到就绪状态
- **调度算法**：决定就绪队列中进程执行顺序的算法

**选项分析：**
- **A、多级反馈队列调度**：正确。多级反馈队列调度算法为不同优先级的进程设置不同的队列，刚完成IO的进程通常会被放入较高优先级的队列，优先获得CPU时间
- **B、时间片轮转调度**：错误。时间片轮转调度按时间片依次执行进程，不考虑进程的IO等待情况
- **C、短作业优先**：错误。短作业优先按进程运行时间排列，不考虑IO等待情况
- **D、先来先服务**：错误。先来先服务按进程到达时间排列，不考虑IO等待情况

### 8. 下列方法中哪一个是破坏了"循环等待"条件（ **D** ）
A、剥夺资源法 
B、银行家算法 
C、一次性分配策略 
D、资源有序分配策略

**解析：**
**核心概念：**
- **死锁的四个必要条件**：互斥条件、请求和保持条件、不剥夺条件、循环等待条件
- **破坏死锁**：只需破坏四个必要条件中的任意一个即可避免死锁

**选项分析：**
- **A、剥夺资源法**：错误。剥夺资源法破坏的是"不剥夺条件"，允许系统剥夺进程已拥有的资源
- **B、银行家算法**：错误。银行家算法是死锁避免算法，不是破坏死锁条件的方法
- **C、一次性分配策略**：错误。一次性分配策略破坏的是"请求和保持条件"，要求进程一次性请求所有资源
- **D、资源有序分配策略**：正确。资源有序分配策略通过给资源编号，进程必须按编号顺序请求资源，避免了进程间形成循环等待

### 9. 中程调度的目的是（**B** ）。
A、提高CPU的利用率 
B、节省内存 
C、提高CPU的效率 
D、降低系统开销

**解析：**
**核心概念：**
- **中程调度**：又称中级调度或内存调度，负责将进程从内存交换到外存，或从外存交换到内存
- **调度层次**：高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）

**选项分析：**
- **A、提高CPU的利用率**：错误。提高CPU利用率是进程调度（低级调度）的目的
- **B、节省内存**：正确。中程调度通过将暂时不用的进程换出到外存，释放内存空间，节省内存
- **C、提高CPU的效率**：错误。提高CPU效率通常通过优化算法或硬件实现，不是中程调度的目的
- **D、降低系统开销**：错误。中程调度涉及进程的换入换出，会增加一定的系统开销

### 10. 进程从新建状态转换到就绪状态的工作由（**C** ）完成。
A、中级调度 
B、进程调度 
C、作业调度 
D、低级调度

**解析：**

**核心概念：**
- **进程状态转换**：新建 → 就绪 → 运行 → 阻塞 → 终止
- **调度层次**：
  - 高级调度（作业调度）：负责将作业从外存调入内存，创建进程，进入就绪状态
  - 中级调度（内存调度）：负责进程在内存和外存之间的转换
  - 低级调度（进程调度）：负责从就绪队列选择进程执行

**选项分析：**
- **A、中级调度**：错误。中级调度负责进程在内存和外存之间的转换，不涉及新建到就绪的转换
- **B、进程调度**：错误。进程调度负责从就绪队列选择进程执行，是运行状态的转换
- **C、作业调度**：正确。作业调度将作业调入内存，创建进程，进程从新建状态转换为就绪状态
- **D、低级调度**：错误。低级调度就是进程调度，负责运行状态的转换

## 第四章 进程同步
### 1. 从下面对临界区的论述中，选出一条正确的论述。（**C**）
A、临界区是指进程中用于实现进程同步的那段代码 
B、临界区是指进程中用于访问共享资源的那段代码 
C、临界区是指进程中访问临界资源的那段代码 
D、临界区是指进程中用于实现进程通信的那段代码

### 2. 在操作系统中，P、V操作是一种（**B**）。
A、机器指令 
B、进程低级通信原语 
C、系统调用命令 
D、作业控制命令

**解析：**

**核心概念：**
- **P、V操作**：是操作系统中用于实现进程同步和互斥的原语操作，由荷兰计算机科学家Dijkstra提出。
- **原语**：是由若干条机器指令组成的一段程序，具有原子性（执行过程中不能被中断）。

**选项分析：**
- **A、机器指令**：错误。P、V操作不是硬件直接支持的机器指令，而是操作系统实现的软件原语。
- **B、进程低级通信原语**：正确。P、V操作主要用于进程间的同步与互斥，是一种低级通信方式，通过信号量机制实现进程间的间接通信。
- **C、系统调用命令**：错误。系统调用是用户程序请求操作系统服务的接口，而P、V操作是操作系统内部的原语，通常作为系统调用的一部分实现。
- **D、作业控制命令**：错误。作业控制命令是用户与操作系统交互的命令，用于控制作业的执行，如ls、cp等，与P、V操作无关。

### 3. 进程A和B共享同一临界资源，并且进程A正处于对应的临界区内执行。请从下列描述中选择一条正确的描述。（**A**）
A、进程A的执行能被中断，而且只要B进程就绪，就可以将CPU调度给B进程。
B、进程A的执行能被中断，但中断A后，不能将CPU调度给B进程。
C、进程A的执行能被中断，而且只要B进程就绪，就必定将CPU调度给B进程。
D、进程A的执行不能被中断，即临界区的代码具有原子性。

**解析：**

**核心概念：**
- **临界区**：进程中访问临界资源的那段代码。
- **临界资源**：一次仅允许一个进程使用的共享资源，如打印机、共享变量等。
- **进程调度**：操作系统根据调度算法从就绪队列中选择进程执行，CPU可以被中断并调度给其他进程。

**选项分析：**
- **A、进程A的执行能被中断，而且只要B进程就绪，就可以将CPU调度给B进程**：正确。进程在临界区内执行时，CPU是可以被中断的，操作系统可以根据调度算法将CPU调度给其他就绪进程（包括B进程）。但由于临界资源的互斥访问机制，B进程即使获得CPU，也无法进入自己的临界区，会被阻塞等待。
- **B、进程A的执行能被中断，但中断A后，不能将CPU调度给B进程**：错误。进程调度是操作系统的基本功能，即使A在临界区，只要B就绪，操作系统就可以调度B执行，只是B无法进入临界区。
- **C、进程A的执行能被中断，而且只要B进程就绪，就必定将CPU调度给B进程**：错误。"必定"说法太绝对，进程调度取决于调度算法，如FCFS算法中，如果A还在执行，即使B就绪，也不会立即调度B。
- **D、进程A的执行不能被中断，即临界区的代码具有原子性**：错误。临界区的原子性是通过同步机制（如锁、信号量）保证的，而不是通过禁止中断实现的。现代操作系统中，进程在临界区内执行时CPU可以被中断。

### 4. 进程并发地在处理机上执行时，（**A**）。
A、进程之间可能具有交往，也可能无关
B、上述都不对
C、进程之间是无关的，系统是封闭的
D、进程之间具有交互性、并发性，它们既相互依赖，又相互制约

**解析：**

**核心概念：**
- **进程并发**：多个进程在同一处理机上交替执行，宏观上同时进行，微观上交替执行。
- **进程交往**：进程之间由于共享资源或相互协作而产生的依赖或制约关系。

**选项分析：**
- **A、进程之间可能具有交往，也可能无关**：正确。进程并发执行时，有些进程之间可能需要共享资源或协作（如生产者-消费者进程），具有交往关系；而有些进程之间可能没有任何共享资源或协作关系，彼此无关（如两个独立运行的应用程序）。
- **C、进程之间是无关的，系统是封闭的**：错误。这种说法太绝对，进程之间可能存在交往关系，系统也不是完全封闭的，进程可以通过系统调用与外部环境交互。
- **D、进程之间具有交互性、并发性，它们既相互依赖，又相互制约**：错误。这种说法也太绝对，并不是所有并发执行的进程之间都具有交互性和相互依赖关系，有些进程之间是完全无关的。

### 5. 在9个生产者，5个消费者，共享容量为7的缓冲区的生产者-消费者问题中。互斥使用缓冲区的信号量S的初值为（**B**）。
A、7
B、1
C、9
D、5

**解析：**

**核心概念：**
- **生产者-消费者问题**：经典的进程同步问题，涉及生产者进程和消费者进程共享一个固定大小的缓冲区。
- **互斥信号量**：用于实现对临界资源的互斥访问，初值通常为1，表示临界资源初始可用。
- **同步信号量**：用于协调生产者和消费者的执行顺序，如空缓冲区数（初值为缓冲区容量）和满缓冲区数（初值为0）。

**选项分析：**
- **B、1**：正确。互斥信号量用于保证对缓冲区的互斥访问，无论生产者和消费者的数量多少，互斥信号量的初值始终为1，表示缓冲区初始可用，一次只允许一个进程访问。

