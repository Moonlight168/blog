# 判断题
## 第一章：操作系统引论
### 多道批处理系统的CPU利用率比单道批处理系统高，但是设备利用率差不多。（×）

**解析：**

**核心概念：**
- **单道批处理系统**：一次只处理一个作业，作业在执行期间独占CPU和所有设备资源，当作业进行I/O操作时，CPU处于空闲状态。
- **多道批处理系统**：同时将多个作业调入内存，在CPU上交替执行，当一个作业进行I/O操作时，CPU可以切换到执行其他作业。

**CPU利用率分析：**
- 单道批处理系统：作业进行I/O操作时，CPU空闲，利用率低。
- 多道批处理系统：作业进行I/O操作时，CPU可以执行其他作业，减少CPU空闲时间，利用率高。
- 题目前半部分"多道批处理系统的CPU利用率比单道批处理系统高"是正确的。

**设备利用率分析：**
- 单道批处理系统：作业独占设备，当作业使用CPU时，设备空闲，利用率低。
- 多道批处理系统：多个作业交替执行，CPU和设备可以并行工作（例如，作业A使用CPU时，作业B可以进行I/O操作），充分利用设备资源，利用率高。
- 题目后半部分"但是设备利用率差不多"是错误的，实际上多道批处理系统的设备利用率也显著高于单道批处理系统。

**结论：**
题目后半部分错误，多道批处理系统不仅CPU利用率比单道批处理系统高，设备利用率也更高，因此整个陈述错误（×）。

## 第二章：进程的描述与控制
### 操作系统对进程的管理和控制都是操作系统的主动行为。(×)

**解析：**
操作系统对进程的管理和控制并非全部都是主动行为，而是包含主动和被动两种模式。

**核心概念：**
- **进程管理**：操作系统对进程的创建、调度、同步、通信和终止等活动的管理。
- **主动行为**：操作系统主动发起的进程管理活动，无需外部触发。
- **被动行为**：操作系统响应外部事件或进程请求而进行的管理活动。

**行为分析：**
- **主动行为示例**：
  - 进程调度：操作系统主动按照调度算法选择就绪进程分配CPU
  - 资源回收：操作系统主动回收终止进程的资源
  - 死锁检测：操作系统定期主动检测系统是否发生死锁

- **被动行为示例**：
  - 进程创建：操作系统响应用户或其他进程的fork/CreateProcess请求
  - 进程终止：操作系统响应进程的exit请求或外部信号
  - 进程同步：操作系统响应进程的wait/signal等同步原语调用
  - 进程通信：操作系统响应进程的send/receive等通信原语调用

**结论：**
操作系统对进程的管理和控制既包含主动行为（如调度、资源回收），也包含大量被动行为（如响应进程请求的创建、终止、同步、通信等）。因此，"都是操作系统的主动行为"的说法是错误的（×）。

## 第三章：处理机调度与死锁
### 一般情况下，SJF可以获得最短的平均等待时间。（√）

**解析：**

**核心概念：**
- **SJF（Shortest Job First）**：短作业优先调度算法，优先选择估计运行时间最短的作业或进程执行。

**调度算法分析：**
- SJF算法通过优先执行短作业，减少了长作业对短作业的等待时间影响，从而降低了平均等待时间。
- 理论上，SJF是最优的非抢占式调度算法，能够获得最短的平均等待时间。
- 但SJF算法存在局限性，如难以准确估计作业运行时间，可能导致长作业饥饿等问题。

### RR调度算法的平均周转时间最短。（×）

**解析：**

**核心概念：**
- **RR（Round Robin）**：时间片轮转调度算法，将CPU时间划分为固定大小的时间片，按顺序轮流分配给就绪队列中的进程。
- **平均周转时间**：所有作业从提交到完成的平均时间。

**调度算法分析：**
- RR算法的特点是公平性好，每个进程都能获得平等的CPU时间，但由于频繁的上下文切换和时间片开销，平均周转时间较长。
- 相比之下，SJF（短作业优先）算法在一般情况下能获得更短的平均周转时间。
- 题目中"RR调度算法的平均周转时间最短"的说法不符合实际情况。

### 优先数调度算法不存在抢占式调度。（×）

**解析：**

**核心概念：**
- **优先数调度算法**：根据进程的优先级进行调度，优先执行优先级高的进程。
- **抢占式调度**：当有更高优先级的进程进入就绪队列时，立即暂停当前正在执行的进程，将CPU分配给更高优先级的进程。
- **非抢占式调度**：一旦进程获得CPU，就一直执行直到完成或阻塞，不会被更高优先级的进程抢占。

## 第四章：进程同步
### 记录型信号量在使用过程中存在“忙等”现象。（×）

**解析：**

**核心概念：**
- **记录型信号量**：一种用于进程同步的机制，包含一个值和一个进程等待队列。
- **忙等现象**：进程在等待资源时不断检查条件，导致CPU资源浪费。

**工作原理：**
- 记录型信号量在资源不可用时，会将进程阻塞并放入等待队列，而非让其不断检查条件。
- 当资源可用时，系统会唤醒等待队列中的进程，避免了"忙等"现象。
- 相比之下，整型信号量才存在"忙等"现象。

### 使用P、V操作后，可以防止系统出现死锁。（×）

**解析：**

**核心概念：**
- **P、V操作**：实现进程同步和互斥的原语。
- **死锁**：多个进程因竞争资源而造成的互相等待局面。

**工作原理：**
- P、V操作只能保证进程的同步和互斥，但不能防止死锁的发生。
- 死锁的发生需要同时满足四个必要条件：互斥条件、请求和保持条件、不剥夺条件、循环等待条件。
- P、V操作本身无法破坏死锁的四个必要条件。

### 经典的读者-写者问题只有进程互斥，不存在进程同步。（×）

**解析：**

**核心概念：**
- **进程互斥**：多个进程不能同时访问临界资源。
- **进程同步**：多个进程按照一定顺序执行，以协调它们的活动。
- **读者-写者问题**：多个读者可以同时读取资源，但读者和写者、写者和写者之间必须互斥。

**为什么题目错误？**
题目认为"只有进程互斥，不存在进程同步"，但实际上：
- 读者计数的递增和递减操作必须通过同步机制（如互斥锁）来保证原子性
- 第一个读者获取锁和最后一个读者释放锁的逻辑需要同步来确保正确性
- 不同优先级策略（读者优先/写者优先）本身就是同步机制

## 第五章：存储器管理
### 动态重定位技术依赖于重定位寄存器。（√）

**解析：**

**核心概念：**
- **动态重定位**：在程序执行过程中，当CPU访问内存时才进行地址转换。
- **重定位寄存器**：用于存储程序在内存中的起始地址。

**工作原理：**
- 动态重定位时，程序中的逻辑地址需要加上重定位寄存器的值才能得到实际的物理地址。
- 重定位寄存器是实现动态重定位的关键硬件支持，没有它就无法完成动态重定位。

### 内存保护的目的是为了提高内存的访问效率。（×）

**解析：**

**核心概念：**
- **内存保护**：确保进程只能访问自己的内存空间，防止越界访问。

**目的分析：**
- 内存保护的主要目的是**保证系统的安全性和稳定性**，防止一个进程的错误操作影响其他进程或系统本身。
- 提高内存访问效率是内存管理的其他机制（如快表、缓存）的目的，不是内存保护的主要目的。

### 在分页系统中，程序中的页面大小和内存中的块大小应该一致。（√）

**解析：**

**核心概念：**
- **分页系统**：将程序的虚拟地址空间划分为页面，将物理内存划分为块。

**工作原理：**
- 页面和块的大小必须一致，这样才能实现一一对应的映射关系。
- 当程序的页面加载到内存时，每个页面恰好占用一个物理块，便于地址转换和内存管理。

### 内存中的地址是绝对地址。（√）

**解析：**

**核心概念：**
- **绝对地址**：又称物理地址，是内存中实际的存储单元地址。
- **相对地址**：又称逻辑地址，是程序中使用的地址。

**地址分析：**
- 内存中的每个存储单元都有一个唯一的绝对地址，CPU通过绝对地址访问内存。
- 程序中的逻辑地址需要通过地址转换（如动态重定位、页表转换）才能转换为绝对地址，然后才能访问内存。

### 段页式存储管理中存在外碎片。（×）

**解析：**

**核心概念：**
- **段页式存储管理**：结合了分段和分页的优点，先将程序划分为段，再将每个段划分为页。
- **外碎片**：内存中存在的零散空闲区域，无法满足任何进程的内存请求。

**碎片分析：**
- 段页式存储管理中，段内的页大小固定，与内存块大小一致，不会产生外碎片。
- 段页式存储管理可能产生段内的内碎片（页面未被完全利用），但不会产生外碎片。

### 可变分区管理主存时，可以采用紧缩技术把分散的主存空闲区集中起来。（√）

**解析：**

**核心概念：**
- **可变分区管理**：根据进程大小动态分配内存，分区大小不固定。
- **紧缩技术**：通过移动内存中的进程，将分散的空闲区合并成一个连续的大空闲区。

**工作原理：**
- 当内存中存在多个分散的小空闲区时，可以使用紧缩技术将所有进程移动到内存的一端，从而将空闲区集中到另一端，形成一个大的连续空闲区。
- 紧缩技术可以提高内存利用率，减少碎片，但需要硬件支持动态重定位。

### 实现进程间数据共享最方便的存储管理技术是分页。（×）

**解析：**

**核心概念：**
- **进程间数据共享**：多个进程访问同一块内存区域。
- **分段存储管理**：将程序划分为逻辑上独立的段，便于实现数据共享和保护。

**共享机制分析：**
- 分段存储管理中，多个进程可以共享同一个段（通过段表项指向同一块物理内存），实现数据共享非常方便。
- 分页存储管理中，页面是物理划分，不是逻辑划分，共享数据需要共享多个页面，管理复杂，不如分段方便。

### 在页式存储管理中，引入快表可以减少每一次的内存访问时间。（×）

**解析：**

**核心概念：**
- **快表（TLB）**：高速缓冲存储器，用于缓存常用的页表项。
- **页式存储管理**：需要通过页表将虚拟地址转换为物理地址。

**工作原理：**
- 没有快表时，每次内存访问需要两次主存访问（访问页表+访问数据）。
- 引入快表后，大部分情况下可以直接从快表中获取页表项，减少一次主存访问，从而减少内存访问时间，但是快表可能无法满足所有访问，比如块表中缺少页表项，就会进行访问页表然后再访问数据。

### 在分页系统中，程序中的页面大小和内存中的帧大小应该一致。（√）

**解析：**

**核心概念：**
- **页面**：程序虚拟地址空间的基本单位。
- **帧**：物理内存的基本分配单位。

**工作原理：**
- 分页系统中，页面和帧的大小必须一致，这样才能实现一一对应的映射关系。
- 当程序的页面加载到内存时，每个页面恰好占用一个物理帧，便于地址转换和内存管理。

### 采用反向页表的系统在实现共享内存时存在困难。（√）

**解析：**

**核心概念：**
- **反向页表**：以物理帧为索引，记录每个帧被哪个进程的哪个页面占用。
- **共享内存**：多个进程共享同一块物理内存。

**共享机制分析：**
- 反向页表中，每个物理帧只能记录一个进程和页面的映射关系。
- 当多个进程共享同一块物理内存时，反向页表需要记录多个映射关系，实现复杂。
- 相比之下，传统页表（每个进程一张页表）实现共享内存更简单，只需让多个进程的页表项指向同一块物理内存。

## 第六章：虚拟存储器
### 在采用工作集模型的请求式分页系统中，一个页面同一时刻可能在两个工作集中。（×）
**解析：** 工作集是指进程在某段时间内频繁访问的页面集合。每个页面同一时刻只能属于一个进程的工作集，因为工作集是进程级别的概念，一个页面只能被一个进程拥有（或共享），而共享页面在不同进程中会有不同的工作集状态。

### 在虚存系统中，只要磁盘空间无限大，作业就能拥有任意大的编址空间。（×）
**解析：** 虚拟内存的大小不仅受磁盘空间限制，还受CPU地址总线位数的限制。例如，32位CPU的虚拟地址空间最大为4GB，即使磁盘空间无限大，也无法突破CPU硬件的地址寻址限制。

### 在一个请求分页系统中发生颠簸（抖动）时，安装一个更快的CPU和一个容量更大的硬盘可以提高CPU利用率。（×）
**解析：** 颠簸（抖动）是由于页面置换过于频繁导致的，主要原因是内存不足或页面置换算法不当。更快的CPU和更大的硬盘并不能解决页面频繁置换的问题，反而可能加剧颠簸。解决抖动的有效方法是增加物理内存或改进页面置换算法。

### 在分页存储管理中，减少页面大小，可以减少内存的浪费。所以页面越小越好。（×）
**解析：** 减少页面大小可以减少内部碎片（每个页面中未使用的空间），但会增加页表大小和页面置换频率，从而增加系统开销。页面大小需要权衡，不是越小越好，通常取2的幂次方，如4KB、8KB等。

### 在请求分页管理的系统中，一个淘汰的页面一定要写回外存。（×）
**解析：** 只有修改过的页面（脏页）才需要写回外存，因为这些页面的内容与外存中的副本不同。未修改的页面（干净页）可以直接丢弃，因为外存中已有完整的副本。

### 一个进程必须把所有代码装入内存才能运行。（×）
**解析：** 虚拟内存技术允许进程按需装入页面，不需要将所有代码都装入内存即可运行。当访问到不在内存中的页面时，会触发缺页中断，操作系统会将所需页面从外存调入内存。

### 当采用分页式虚拟存储管理时，如果在进程执行过程中需访问的页面为无效时，硬件将发出一个缺页中断。（√）
**解析：** 在分页式虚拟存储管理中，页表中包含页面的有效位。当访问的页面有效位为0（无效）时，硬件会触发缺页中断，操作系统会处理这个中断，将页面从外存调入内存，并更新页表。

### 在采用虚存的系统中，要求程序运行前不必全部装入内存但在运行过程中必须一直驻留在内存。（×）
**解析：** 虚存系统的特点是程序运行前不必全部装入内存，运行过程中也可以将不常用的页面换出到外存，不需要一直驻留在内存。当需要时，这些页面可以被重新调入内存。

### 在分页虚拟存储管理中，“二次机会”调度策略和“时钟”调度策略在决定淘汰哪一页时，都用到了引用位。（√）
**解析：** 这两种页面置换算法都依赖引用位来判断页面的最近使用情况：
- **“二次机会”调度策略**：为每个页面增加一个引用位，当需要淘汰页面时，检查引用位，如果为1则将其置0并给予第二次机会，否则淘汰
- **“时钟”调度策略**：将页面组织成环形链表，用指针指向当前检查的页面，当需要淘汰页面时，检查引用位，若为1则置0并移动指针，否则淘汰
- **引用位的作用**：记录页面最近是否被访问过，是这两种算法的核心判断依据

## 第七章：输入/输出系统

### 所有的中断都可以被屏蔽。（×）

**解析：**

**核心概念：**
- **中断屏蔽**：通过设置中断屏蔽字，禁止某些中断请求被响应。
- **不可屏蔽中断（NMI）**：优先级最高的中断，无法被屏蔽，用于处理紧急事件（如电源故障、硬件错误）。

**中断分类：**
- **可屏蔽中断**：可以通过中断屏蔽字禁止响应的中断，如I/O设备中断。
- **不可屏蔽中断**：无法被屏蔽的中断，必须立即响应，如电源故障、内存错误等。

### 通道所执行的通道程序存放在主机的内存中。（√）

**解析：**

**核心概念：**
- **通道**：独立于CPU的I/O处理单元，用于执行通道程序，管理I/O操作。
- **通道程序**：由通道指令组成的程序，用于控制I/O设备的操作。

**工作原理：**
- 通道程序存放在主机的内存中，通道从内存中读取通道指令并执行。
- 通道执行通道程序时，不需要CPU干预，实现了I/O操作的独立执行。
- 通道执行完通道程序后，通过中断向CPU报告执行结果。

**结论：**
通道程序存放在主机的内存中，通道从内存中读取并执行通道程序，实现了I/O操作的独立执行。