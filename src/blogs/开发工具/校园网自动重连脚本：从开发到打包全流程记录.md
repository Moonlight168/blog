---
title: 校园网自动重连工具
date: 2025-11-05
categories: [开发工具]
---

# 校园网自动重连工具

**问题背景**：在课室远程连接宿舍电脑时，宿舍电脑的校园网经常掉线，导致远程桌面突然断开、搞得一上午都不能远程连接。为此，我开发了一套**本地化、无需联网下载驱动**的校园网自动重连守护脚本，支持网络状态分层检测、会话失效自动重建、配置灵活修改，能够后台静默运行，确保远程连接永不掉线。


## 一、工具核心优势与技术选型
### 1. 解决的核心问题
- 无需手动登录：断连后自动检测、自动重试，全程无需干预
- 本地化运行：驱动从本地路径加载，不依赖网络下载，适配无外网环境
- 分层网络检测：先判断是否连校园网，再判断是否已登录，避免无效操作
- 会话失效兜底：浏览器会话断开时自动重建驱动，不报错、不中断
- 配置与代码分离：账号、URL、检测间隔等都在JSON中，改配置不用改代码

### 2. 技术栈选型
| 模块                | 技术/工具                          | 选型原因                                                                 |
|---------------------|-----------------------------------|--------------------------------------------------------------------------|
| 浏览器自动化        | Selenium + EdgeDriver             | Edge浏览器兼容性好，无头模式可后台运行，适合长期驻留                       |
| 驱动管理            | 本地EdgeDriver                    | 避免联网依赖，手动指定路径更稳定，适合校园网环境                           |
| 配置管理            | JSON                              | 轻量易读，支持动态修改账号、检测间隔等参数，无需重新打包                   |
| 网络检测            | subprocess（调用系统ping命令）     | 直接调用系统底层ping，比Python第三方库更稳定，适配Windows/Linux双系统      |
| 日志记录            | logging模块                       | 实时记录网络状态、登录结果，方便排查问题（如登录失败原因）                 |


## 二、项目结构设计（清晰易维护）
先梳理文件结构，确保后续配置、运行、修改都不混乱，尤其注意驱动和配置文件的路径：
```
CampusNetworkAutoLogin/  # 项目根目录
├─ src/                  # 代码文件夹（所有核心逻辑在这里）
│  └─ main.py            # 主程序（驱动初始化、登录、网络检测、重试逻辑）
├─ resource/             # 配置文件文件夹（与代码分离，方便修改）
│  └─ config.json        # 配置文件（账号、URL、驱动路径等）
├─ edgedriver_win64/     # 本地EdgeDriver文件夹（放msedgedriver.exe）
│  └─ msedgedriver.exe   # Edge浏览器驱动（需与本地Edge版本匹配）
└─ requirements.txt      # 依赖列表（一键安装所有Python库）
```


## 三、完整代码解析
### 1. 配置文件：resource/config.json
所有易变参数都放这里，比如换账号、改检测间隔，直接改JSON即可，不用动代码。**注意：EdgeDriver路径要和你电脑上的一致**：
``` text
{
  "username": "2023001234",          // 你的校园网账号（如学号）
  "password": "Campus123!",          // 你的校园网密码
  "campus_login_url": "http://10.0.0.1/login",  // 校园网登录页URL（用自己学校的）
  "online_flag": "已在线",            // 登录成功的特征文字（从登录页F12查看）
  "campus_intranet_ip": "10.0.0.1",  // 校园网内网IP（能ping通说明连了校园网）
  "extranet_test_domain": "www.baidu.com",  // 外网测试地址（能ping通说明已登录）
  "test_timeout": 5,                 // ping测试超时时间（秒）
  "check_interval": 60,              // 网络状态检测间隔（秒，建议60-300）
  "retry_limit": 3,                  // 登录失败最大重试次数
  "auth_id": "authBtn",              // 统一身份认证按钮的ID（F12检查获取）
  "username_id": "usernameInput",    // 账号输入框的ID
  "password_id": "passwordInput",    // 密码输入框的ID
  "account_btn_xpath": "//div[text()='账号登录']",  // 账号登录按钮的XPATH
  "login_btn_xpath": "//button[@type='submit']"    // 登录按钮的XPATH
}
```

### 2. 主程序：src/main.py（核心逻辑）
代码按“配置读取→驱动初始化→网络检测→登录重试→主循环”的流程组织，关键步骤都加了注释，新手也能看懂：
```python
import os
import sys
import json
import time
import logging
import subprocess
from selenium import webdriver
from selenium.webdriver.edge.options import Options
from selenium.webdriver.edge.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import InvalidSessionIdException, TimeoutException

# -------------------------- 全局配置与工具函数 --------------------------
# 配置文件相对路径（与main.py的相对位置：../resource/config.json）
CONFIG_PATH = '../resource/config.json'

def load_config():
    """读取配置文件，适配打包/未打包两种场景（关键：避免路径错误）"""
    # 区分打包状态：sys.frozen为True → 已打包成exe；False → 运行脚本
    if getattr(sys, "frozen", False):
        # 打包后：根目录是exe所在目录（比如桌面）
        root_dir = os.path.dirname(sys.executable)
    else:
        # 未打包：根目录是main.py所在目录（src）的上级目录（项目根目录）
        root_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 拼接配置文件的绝对路径（避免相对路径歧义）
    full_config_path = os.path.join(root_dir, CONFIG_PATH)
    
    # 检查配置文件是否存在（不存在直接退出，避免后续报错）
    if not os.path.exists(full_config_path):
        logging.error(f"配置文件缺失！请确保路径：{full_config_path} 正确")
        sys.exit(1)
    
    # 读取配置并返回（JSON转Python字典）
    with open(full_config_path, "r", encoding="utf-8") as f:
        return json.load(f)

# 加载配置（全局可用，后续不用重复读）
config = load_config()

# 从配置中提取参数（简化后续代码调用）
USERNAME = config["username"]
PASSWORD = config["password"]
CAMPUS_LOGIN_URL = config["campus_login_url"]
ONLINE_FLAG = config["online_flag"]
CAMPUS_INTRANET_IP = config["campus_intranet_ip"]
EXTRANET_TEST_DOMAIN = config["extranet_test_domain"]
TEST_TIMEOUT = config["test_timeout"]
CHECK_INTERVAL = config["check_interval"]
RETRY_LIMIT = config["retry_limit"]
AUTH_ID = config["auth_id"]
USERNAME_ID = config["username_id"]
PASSWORD_ID = config["password_id"]
ACCOUNT_BTN_XPATH = config["account_btn_xpath"]
LOGIN_BTN_XPATH = config["login_btn_xpath"]
# 本地EdgeDriver路径（从配置中读取，灵活修改）
EDGE_DRIVER_PATH = config.get("edge_driver_path", r"F:\edgedriver_win64\msedgedriver.exe")

# 初始化日志（同时输出到控制台和文件，方便排查问题）
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(os.path.join(os.path.dirname(os.path.abspath(__file__)), "login_log.log")),
        logging.StreamHandler()  # 控制台输出
    ]
)

# -------------------------- 驱动初始化函数 --------------------------
def init_edge_driver():
    """初始化本地EdgeDriver（不联网，从指定路径加载，支持无头模式）"""
    edge_options = Options()
    # 关键配置：无头模式（后台运行，不弹出浏览器窗口，适合长期驻留）
    edge_options.add_argument('--headless=new')
    # 禁用GPU加速（减少浏览器崩溃概率，尤其在服务器/低配置电脑）
    edge_options.add_argument('--disable-gpu')
    # 屏蔽无关日志（比如DevTools警告，让日志更干净）
    edge_options.add_experimental_option('excludeSwitches', ['enable-logging'])
    # 禁用浏览器扩展（避免扩展干扰自动化操作）
    edge_options.add_argument('--disable-extensions')

    # 检查本地驱动文件是否存在
    if not os.path.exists(EDGE_DRIVER_PATH):
        logging.error(f"EdgeDriver不存在！请检查路径：{EDGE_DRIVER_PATH}")
        return None

    try:
        # 用指定路径的驱动创建Service，再初始化浏览器
        service = Service(EDGE_DRIVER_PATH)
        driver = webdriver.Edge(service=service, options=edge_options)
        # 隐式等待：元素没找到时最多等30秒（避免页面加载慢导致定位失败）
        driver.implicitly_wait(30)
        logging.info("Edge驱动初始化成功（本地路径加载）")
        return driver
    except Exception as e:
        # 捕获所有异常（比如驱动版本不匹配、权限不足）
        logging.error(f"驱动初始化失败：{str(e)}")
        return None

# -------------------------- 网络检测函数 --------------------------
def ping_test(target: str, count: int = 2) -> bool:
    """通用ping测试（适配Windows/Linux）：返回True=ping通，False=不通"""
    # 系统判断：Windows用"-n"指定ping次数，Linux用"-c"
    param = "-n" if subprocess.os.name == "nt" else "-c"
    # 构造ping命令（比如Windows：ping -n 2 www.baidu.com）
    command = ["ping", param, str(count), target]
    
    try:
        # 执行ping命令，捕获输出（不显示在控制台）
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,  # 重定向标准输出
            stderr=subprocess.PIPE,  # 重定向错误输出
            text=True,               # 输出转字符串
            timeout=TEST_TIMEOUT     # 超时时间（避免卡死）
        )
        # returncode=0 → 命令执行成功（ping通）
        return result.returncode == 0
    except (subprocess.TimeoutExpired, Exception):
        # 超时或其他错误（比如目标不可达），视为ping不通
        return False

def check_network_status() -> str:
    """分层检测网络状态：先判断是否连校园网，再判断是否已登录"""
    # 1. 第一步：检测是否连接到校园网（ping内网IP，比如10.0.0.1）
    if not ping_test(CAMPUS_INTRANET_IP):
        return "未连接到校园网（请检查Wi-Fi/网线）"
    
    # 2. 第二步：已连校园网，检测是否已登录（ping外网，比如百度）
    if ping_test(EXTRANET_TEST_DOMAIN):
        return "网络正常（已登录，可访问外网）"
    else:
        # 能ping通内网但不能ping通外网 → 未登录
        return "已连校园网，但未登录（需自动登录）"

# -------------------------- 登录与重试函数 --------------------------
def login_campus_net(driver):
    """校园网登录核心逻辑：返回True=登录成功，False=失败"""
    try:
        # 先判断是否已登录（避免重复登录）
        if ping_test(EXTRANET_TEST_DOMAIN):
            logging.info("当前已登录校园网，无需重复操作")
            return True
        
        logging.info("开始自动登录校园网...")
        # 打开登录页
        driver.get(CAMPUS_LOGIN_URL)
        
        # 1. 点击"统一身份认证"按钮（等待按钮可点击，避免元素未加载）
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, AUTH_ID))
        ).click()
        
        # 2. 切换到"账号登录"模式（部分登录页默认是扫码，需手动切）
        WebDriverWait(driver, 10).until(
            EC.visibility_of_element_located((By.XPATH, ACCOUNT_BTN_XPATH))
        ).click()
        
        # 3. 输入账号（等待输入框可见，避免输入失败）
        WebDriverWait(driver, 10).until(
            EC.visibility_of_element_located((By.ID, USERNAME_ID))
        ).send_keys(USERNAME)
        
        # 4. 输入密码
        WebDriverWait(driver, 10).until(
            EC.visibility_of_element_located((By.ID, PASSWORD_ID))
        ).send_keys(PASSWORD)
        
        # 5. 点击登录按钮（等待按钮可点击，避免点击无效）
        login_btn = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, LOGIN_BTN_XPATH))
        )
        login_btn.click()
        
        # 6. 验证登录成功（等待页面出现"已在线"等特征文字）
        WebDriverWait(driver, 10).until(
            EC.text_to_be_present_in_element((By.CSS_SELECTOR, 'div[name="PageTips"]'), ONLINE_FLAG)
        )
        
        logging.info("校园网登录成功！")
        return True
    except TimeoutException:
        # 元素定位超时（比如页面加载慢、元素路径变了）
        logging.error("登录超时（元素未找到或页面加载过慢）")
        return False
    except Exception as e:
        # 其他异常（比如会话失效、网络中断）
        logging.error(f"登录失败：{str(e)}")
        return False

def retry_login(driver, attempts=0):
    """登录失败重试机制：会话失效时自动重建驱动，最多重试RETRY_LIMIT次"""
    while attempts < RETRY_LIMIT:
        try:
            # 会话有效性校验（轻量操作：获取页面标题，失效会抛异常）
            current_title = driver.title
            logging.info(f"第{attempts+1}次登录尝试（共{RETRY_LIMIT}次），当前会话正常")
            
            # 执行登录逻辑，成功则返回
            if login_campus_net(driver):
                return True
            
            # 登录失败，等待后重试（避免频繁请求被校园网拦截）
            logging.warning(f"第{attempts+1}次登录失败，{CHECK_INTERVAL}秒后重试...")
            attempts += 1
            time.sleep(CHECK_INTERVAL)
        
        except InvalidSessionIdException:
            # 关键：会话失效（比如浏览器崩溃、DevTools断开），重建驱动
            logging.error(f"第{attempts+1}次尝试发现会话失效，正在重建浏览器...")
            driver.quit()  # 清理无效驱动实例
            driver = init_edge_driver()  # 重新初始化驱动
            # 重建失败则退出重试（驱动有问题，重试也没用）
            if not driver:
                logging.error("驱动重建失败，无法继续重试")
                return False
            attempts += 1
            time.sleep(5)  # 等待新驱动启动
    
    # 达到最大重试次数，返回失败
    logging.error(f"已达到最大重试次数（{RETRY_LIMIT}次），登录失败")
    return False

# -------------------------- 主程序入口 --------------------------
def main():
    """主循环：持续检测网络状态，未登录时自动触发登录"""
    # 启动日志（显示工具基本信息）
    logging.info("=" * 60)
    logging.info("校园网自动重连工具 v1.0 启动成功")
    logging.info(f"检测间隔：{CHECK_INTERVAL}秒 | 登录页：{CAMPUS_LOGIN_URL}")
    logging.info(f"当前账号：{USERNAME} | 启动时间：{time.strftime('%Y-%m-%d %H:%M:%S')}")
    logging.info("=" * 60)

    # 初始化浏览器驱动（启动失败则直接退出）
    driver = init_edge_driver()
    if not driver:
        logging.error("驱动初始化失败，工具无法启动")
        return

    try:
            while True:
                # 检测网络状态
                status = check_network_status()
                logging.info(f"网络状态：{status}")
                # 未连接校园网时退出程序,重试没有意义
                if status == "未连接到校园网（请检查Wi-Fi/网线连接）":
                    logging.error("未连接到校园网，请检查Wi-Fi/网线连接")
                    break

                # 未登录时触发自动登录
                if status == "已连接校园网，但未登录（需登录后访问外网）":
                    if not retry_login(driver):
                        logging.error("登录失败，程序终止")
                        break

                # 等待下次检测
                time.sleep(CHECK_INTERVAL)
        except KeyboardInterrupt:
            logging.info("工具已手动退出")
        finally:
            driver.quit()  # 退出时关闭浏览器驱动


if __name__ == "__main__":
    main()


## 二、步骤1：安装必要依赖 
 ### 1. 安装打包工具和核心依赖 
 打开CMD（或终端），进入项目根目录，执行以下命令： 
 ```bash 
 # 1. 安装pyinstaller（打包工具） 
 pip install pyinstaller 
 
 # 2. 安装项目核心依赖（确保selenium、webdriver-manager等已安装） 
 # 若之前没安装，执行： 
 pip install selenium webdriver-manager 
 
 # 3. 生成requirements.txt（方便后续复用环境，可选但推荐） 
 pip freeze > requirements.txt 
 ``` 
 

 ## 四、步骤3：执行打包命令（指定程序名+路径） 
 ### 1. 进入代码所在目录（src文件夹） 
 在CMD中执行以下命令，切换到 `src` 文件夹（因为 `main.py` 在该目录下）： 
 ```bash 
 # 示例：如果项目根目录在F盘，执行 
 cd F:\MyProjects\Campus Network Auto-Login\src 
 ``` 
 
 ### 2. 执行打包命令（指定程序名+保留resource文件夹） 
 运行以下命令，生成名为 `CampusNetworkAutoLogin.exe` 的单文件，并确保 `resource` 文件夹能被识别： 
 ```bash 
 pyinstaller -F -n "CampusNetworkAutoLogin" main.py 
 ``` 
 
 #### 命令参数说明 
 | 参数                | 作用                                                                 | 
 |---------------------|----------------------------------------------------------------------| 
 | `-F`                | 打包成**单个独立exe文件**（无需其他依赖dll，方便传输）               | 
 | `-n "CampusNetworkAutoLogin"` | 指定生成的exe文件名为 `CampusNetworkAutoLogin.exe`（避免默认的main.exe） | 
 
 
 ## 五、步骤4：找到并测试打包后的程序 
 ### 1. 定位exe文件 
 打包完成后，会在 `src` 文件夹下生成 `dist` 和 `build` 两个文件夹： 
 - 最终的 `CampusNetworkAutoLogin.exe` 在 **`src/dist/`** 文件夹中。 
 
 ### 2. 准备运行环境 
 将 `dist` 文件夹中的 `CampusNetworkAutoLogin.exe` 复制到任意位置（如桌面），并按以下结构放置文件： 
 ``` 
 桌面/ 
 ├─ src
 |  └─ CampusNetworkAutoLogin.exe  # 打包后的程序 
 └─ resource/                   # 必须与exe同级 
    └─ config.json              # 配置文件（确保内容正确） 
 ``` 
 
 ### 3. 测试运行 
 双击 `CampusNetworkAutoLogin.exe`，观察是否能正常打开浏览器、读取配置并登录。 
 - 若提示"配置文件不存在"：检查 `resource` 文件夹是否与exe同级，且 `config.json` 在其中。 
 - 若提示"找不到浏览器驱动"：确保代码中用了 `webdriver-manager`（自动下载驱动），无需手动放驱动文件。
```

