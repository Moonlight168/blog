---
title: Lua脚本
date: 2025-10-19
category: 基本概念
tags: [多线程]
---

## 一、什么是 Lua 脚本

Lua 是一种轻量级的脚本语言。Redis 从 2.6 版本开始内置了对 Lua 的支持，允许我们把一段逻辑写成 Lua 脚本，一次性提交给 Redis 服务器执行。

## 二、Lua 脚本的作用

Lua 脚本在 Redis 中的主要作用是 **将多条命令封装为一个原子操作执行**。这意味着脚本中的所有 Redis 命令会在一次执行中完成，不会被其他客户端的命令打断，从而保证数据操作的一致性和完整性。

它常用于以下场景：

1. **原子操作**：在高并发环境下确保关键业务逻辑不被其他请求干扰，比如秒杀、库存扣减。
2. **减少网络开销**：客户端只需一次请求即可完成多条命令执行。
3. **逻辑复用**：在 Redis 端处理逻辑，减少客户端逻辑复杂度。
4. **性能提升**：执行脚本的效率通常高于多条命令连续执行。

## 三、为什么 Lua 脚本是原子操作

Redis 保证 Lua 脚本的执行是 **单线程、原子的**。其内部机制如下：

1. **单线程模型**
   Redis 的核心是单线程执行命令的，Lua 脚本执行时会被 Redis 当作一条独立命令来处理。
   当一个 Lua 脚本开始执行后，Redis 不会切换去处理其他客户端的请求，直到脚本执行完成。

2. **无中断执行机制**
   Redis 在执行 Lua 脚本时，会将整个脚本加载到 Lua 解释器中运行，脚本中的所有 Redis 命令都在一个上下文中按顺序执行，不会被其他命令插队。
   因此，从外部看，这段脚本的所有操作是一个整体，要么全部执行成功，要么全部执行失败。

3. **原子性保证的本质**
   Redis 将 Lua 脚本的执行过程与事务机制类似处理：

    * 期间不会执行其他命令
    * 不存在部分执行或中断
    * 如果出错，整个脚本终止，不会有部分命令生效

这使得 Lua 脚本天然具备 **原子性（Atomicity）** 特征。

## 四、为什么能解决并发竞争问题

在分布式系统中，并发竞争通常出现在多个客户端同时操作同一资源的情况下，比如多个用户同时抢购一个库存。

如果使用多条普通 Redis 命令执行（如 GET → 判断 → DECR），在命令间可能被其他请求打断，导致数据不一致。

而 Lua 脚本通过将逻辑写在同一个脚本中，一次性提交给 Redis 执行，保证在执行期间不会有其他客户端的命令介入，从而避免了并发修改问题。例如：

```lua
-- 秒杀库存扣减逻辑
local stock = redis.call('GET', 'product_stock')
if tonumber(stock) > 0 then
    redis.call('DECR', 'product_stock')
    return 1
else
    return 0
end
```

这段脚本执行时，Redis 会保证：

* 不会在 `GET` 和 `DECR` 之间被其他请求打断；
* 执行期间库存数据是一致的；
* 并发请求只能依次进入执行，避免超卖。

## 五、总结

Lua 脚本之所以能解决并发问题，是因为 **Redis 在单线程模型下将脚本当作一个整体命令执行**，在执行过程中不允许其他命令插入，从而实现了严格的原子性和一致性。

这使得 Lua 成为在高并发分布式场景中实现安全操作（如秒杀、抢购、分布式锁）的关键手段。
